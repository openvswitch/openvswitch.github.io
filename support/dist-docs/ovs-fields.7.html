<html><head><meta charset="UTF-8"></head><body><pre>
<u>ovs-fields</u>(7)                 Open vSwitch Manual                <u>ovs-fields</u>(7)

<b>NAME</b>
       ovs-fields - protocol header fields in OpenFlow and Open vSwitch

<b>INTRODUCTION</b>
       This  document aims to comprehensively document all of the fields, both
       standard and non-standard, supported by OpenFlow or Open  vSwitch,  re‐
       gardless of origin.

   <b>Fields</b>
       A  <u>field</u>  is  a  property of a packet. Most familiarly, <u>data</u> <u>fields</u> are
       fields that can be extracted from a packet. Most data fields are copied
       directly from protocol headers, e.g. at layer 2,  the  Ethernet  source
       and destination addresses, or the VLAN ID; at layer 3, the IPv4 or IPv6
       source  and  destination;  and  at layer 4, the TCP or UDP ports. Other
       data fields are computed, e.g. <b>ip_frag</b> describes whether a packet is  a
       fragment but it is not copied directly from the IP header.

       Data  fields that are always present as a consequence of the basic net‐
       working technology in use are called called <u>root</u> <u>fields</u>.  Open  vSwitch
       2.7  and earlier considered Ethernet fields to be root fields, and this
       remains the default mode of operation for Open vSwitch bridges. When  a
       packet  is  received  from a non-Ethernet interfaces, such as a layer-3
       LISP tunnel, Open vSwitch 2.7 and earlier force-fit the packet to  this
       Ethernet-centric point of view by pretending that an Ethernet header is
       present  whose  Ethernet  type  that indicates the packet’s actual type
       (and whose source and destination addresses are all-zero).

       Open vSwitch 2.8 and later implement the ``packet type-aware pipeline’’
       concept introduced in OpenFlow 1.5. Such a pipeline does not  have  any
       root  fields. Instead, a new metadata field, <b>packet_type</b>, indicates the
       basic type of the packet, which can be Ethernet, IPv4, IPv6, or another
       type. For backward compatibility, by default Open vSwitch 2.8  imitates
       the  behavior  of  Open vSwitch 2.7 and earlier. Later versions of Open
       vSwitch may change the default, and in  the  meantime  controllers  can
       turn  off this legacy behavior, on a port-by-port basis, by setting <b>op‐</b>
       <b>tions:packet_type</b> to <b>ptap</b> in the <b>Interface</b> table. This  is  significant
       only for ports that can handle non-Ethernet packets, which is currently
       just  LISP, VXLAN-GPE, and GRE tunnel ports. See <b>ovs-vwitchd.conf.db</b>(5)
       for more information.

       Non-root data fields are not always  present.  A  packet  contains  ARP
       fields,  for example, only when its packet type is ARP or when it is an
       Ethernet packet whose Ethernet header indicates the Ethertype for  ARP,
       0x0806.  In  this documentation, we say that a field is <u>applicable</u> when
       it is present in a packet, and <u>inapplicable</u> when it is not. (These  are
       not  standard terms.) We refer to the conditions that determine whether
       a field is applicable as <u>prerequisites</u>. Some VLAN-related fields are  a
       special  case: these fields are always applicable for Ethernet packets,
       but have a designated value or bit that indicates whether a VLAN header
       is present, with the remaining  values  or  bits  indicating  the  VLAN
       header’s content (if it is present).

       An  inapplicable  field  does  not  have  a  value,  not even a nominal
       ``value’’ such as all-zero-bits. In many  circumstances,  OpenFlow  and
       Open  vSwitch  allow references only to applicable fields. For example,
       one may match (see <u>Matching</u>, below) a given field only if the match in‐
       cludes the field’s prerequisite, e.g. matching an ARP field is only al‐
       lowed if one also matches on Ethertype 0x0806 or  the  <b>packet_type</b>  for
       ARP in a packet type-aware bridge.

       Sometimes  a packet may contain multiple instances of a header. For ex‐
       ample, a packet may contain multiple VLAN or MPLS headers, and  tunnels
       can cause any data field to recur. OpenFlow and Open vSwitch do not ad‐
       dress these cases uniformly. For VLAN and MPLS headers, only the outer‐
       most  header  is accessible, so that inner headers may be accessed only
       by ``popping’’ (removing) the outer header. (Open vSwitch supports only
       a single VLAN header in any case.) For tunnels, e.g. GRE or VXLAN,  the
       outer header and inner headers are treated as different data fields.

       Many  network  protocols are built in layers as a stack of concatenated
       headers. Each header typically contains a ``next type’’ field that  in‐
       dicates  the  type  of  the protocol header that follows, e.g. Ethernet
       contains an Ethertype and IPv4 contains a IP protocol type. The  excep‐
       tional  cases,  where protocols are layered but an outer layer does not
       indicate the protocol type for the inner layer, or gives  only  an  am‐
       biguous  indication, are troublesome. An MPLS header, for example, only
       indicates whether another MPLS header or some other  protocol  follows,
       and  in  the latter case the inner protocol must be known from the con‐
       text. In these exceptional cases, OpenFlow and Open vSwitch cannot pro‐
       vide insight into the inner protocol  data  fields  without  additional
       context,  and thus they treat all later data fields as inapplicable un‐
       til an OpenFlow action explicitly specifies what protocol  follows.  In
       the  case  of  MPLS,  the OpenFlow ``pop MPLS’’ action that removes the
       last MPLS header from a packet provides this context, as the  Ethertype
       of the payload. See <u>Layer</u> <u>2.5:</u> <u>MPLS</u> for more information.

       OpenFlow  and  Open vSwitch support some fields other than data fields.
       <u>Metadata</u> <u>fields</u> relate to the origin or treatment of a packet, but they
       are not extracted from the packet data itself. One example is the phys‐
       ical port on which a packet arrived at the switch. <u>Register</u> <u>fields</u>  act
       like  variables: they give an OpenFlow switch space for temporary stor‐
       age while processing a packet. Existing metadata  and  register  fields
       have no prerequisites.

       A  field’s  value  consists  of  an  integral number of bytes. For data
       fields, sometimes those bytes are taken directly from the packet. Other
       data fields are copied from a packet with padding (usually  with  zeros
       and  in  the most significant positions). The remaining data fields are
       transformed in other ways as they are copied from the packets, to  make
       them more useful for matching.

   <b>Matching</b>
       The  most important use of fields in OpenFlow is <u>matching</u>, to determine
       whether particular field values agree with a set of constraints  called
       a  <u>match</u>.  A  match  consists of zero or more constraints on individual
       fields, all of which must be met to satisfy the match.  (A  match  that
       contains no constraints is always satisfied.) OpenFlow and Open vSwitch
       support a number of forms of matching on individual fields:

              <u>Exact</u> <u>match</u>, e.g. <b>nw_src=10.1.2.3</b>
                     Only  a particular value of the field is matched; for ex‐
                     ample, only  one  particular  source  IP  address.  Exact
                     matches  are  written  as <u>field</u><b>=</b><u>value</u>. The forms accepted
                     for <u>value</u> depend on the field.

                     All fields support exact matches.

              <u>Bitwise</u> <u>match</u>, e.g. <b>nw_src=10.1.0.0/255.255.0.0</b>
                     Specific bits in the field must  have  specified  values;
                     for  example,  only  source  IP addresses in a particular
                     subnet. Bitwise matches are written as  <u>field</u><b>=</b><u>value</u><b>/</b><u>mask</u>,
                     where  <u>value</u>  and <u>mask</u> take one of the forms accepted for
                     an exact match on <u>field</u>. Some fields accept  other  forms
                     for       bitwise       matches;       for       example,
                     <b>nw_src=10.1.0.0/255.255.0.0</b>   may   also    be    written
                     <b>nw_src=10.1.0.0/16</b>.

                     Most  OpenFlow switches do not allow every bitwise match‐
                     ing on every field (and before OpenFlow 1.2, the protocol
                     did  not  even  provide  for  the  possibility  for  most
                     fields).  Even switches that do allow bitwise matching on
                     a given field may restrict the masks  that  are  allowed,
                     e.g.  by allowing matches only on contiguous sets of bits
                     starting from the most significant bit, that is, ``CIDR’’
                     masks [RFC 4632]. Open vSwitch does  not  allows  bitwise
                     matching  on every field, but it allows arbitrary bitwise
                     masks on any field that does  support  bitwise  matching.
                     (Older  versions  had some restrictions, as documented in
                     the descriptions of individual fields.)

              <u>Wildcard</u>, e.g. ``any <b>nw_src</b>’’
                     The value of the field  is  not  constrained.  Wildcarded
                     fields  may be written as <u>field</u><b>=*</b>, although it is unusual
                     to mention them at all. (When specifying a  wildcard  ex‐
                     plicitly  in a command invocation, be sure to using quot‐
                     ing to protect against shell expansion.)

                     There is a tiny difference between  wildcarding  a  field
                     and  not  specifying  any match on a field: wildcarding a
                     field requires satisfying the field’s prerequisites.

       Some types of matches on individual fields cannot be expressed directly
       with OpenFlow and Open vSwitch. These can be expressed indirectly:

              <u>Set</u> <u>match</u>, e.g. ``<b>tcp_dst</b> ∈ {80, 443, 8080}’’
                     The value of a field is one of a specified set of values;
                     for example, the TCP destination  port  is  80,  443,  or
                     8080.

                     For  matches  used  in flows (see <u>Flows</u>, below), multiple
                     flows can simulate set matches.

              <u>Range</u> <u>match</u>, e.g. ``1000 ≤ <b>tcp_dst</b> ≤ 1999’’
                     The value of the field must lie within a numerical range,
                     for example, TCP destination ports between 1000 and 1999.

                     Range matches can be expressed as a collection of bitwise
                     matches. For example, suppose that the goal is  to  match
                     TCP source ports 1000 to 1999, inclusive. The binary rep‐
                     resentations of 1000 and 1999 are:

                     01111101000
                     11111001111


                     The  following  series of bitwise matches will match 1000
                     and 1999 and all the values in between:

                     01111101xxx
                     0111111xxxx
                     10xxxxxxxxx
                     110xxxxxxxx
                     1110xxxxxxx
                     11110xxxxxx
                     1111100xxxx


                     which can be written as the following matches:

                     <b>tcp,tp_src=0x03e8/0xfff8</b>
                     <b>tcp,tp_src=0x03f0/0xfff0</b>
                     <b>tcp,tp_src=0x0400/0xfe00</b>
                     <b>tcp,tp_src=0x0600/0xff00</b>
                     <b>tcp,tp_src=0x0700/0xff80</b>
                     <b>tcp,tp_src=0x0780/0xffc0</b>
                     <b>tcp,tp_src=0x07c0/0xfff0</b>


              <u>Inequality</u> <u>match</u>, e.g. ``<b>tcp_dst</b> ≠ 80’’
                     The value of the field differs from  a  specified  value,
                     for example, all TCP destination ports except 80.

                     An inequality match on an <u>n</u>-bit field can be expressed as
                     a  disjunction  of  <u>n</u> 1-bit matches. For example, the in‐
                     equality match ``<b>vlan_pcp</b>  ≠  5’’  can  be  expressed  as
                     ``<b>vlan_pcp</b>  =  0/4 or <b>vlan_pcp</b> = 2/2 or <b>vlan_pcp</b> = 0/1.’’
                     For matches used in flows (see <u>Flows</u>,  below),  sometimes
                     one  can  more  compactly express inequality as a higher-
                     priority flow that matches the  exceptional  case  paired
                     with a lower-priority flow that matches the general case.

                     Alternatively,  an inequality match may be converted to a
                     pair of range matches, e.g. <b>tcp_src</b> <b>≠</b> <b>80</b> may be expressed
                     as ``0 ≤ <b>tcp_src</b> &lt; 80 or 80 &lt; <b>tcp_src</b> ≤ 65535’’, and then
                     each range match may in turn be converted  to  a  bitwise
                     match.

              <u>Conjunctive</u> <u>match</u>, e.g. ``<b>tcp_src</b> ∈ {80, 443, 8080} and <b>tcp_dst</b>
              ∈ {80, 443, 8080}’’
                     As  an OpenFlow extension, Open vSwitch supports matching
                     on conditions on conjunctions of the previously mentioned
                     forms of matching. See the documentation for <b>conj_id</b>  for
                     more information.

       All  of  these supported forms of matching are special cases of bitwise
       matching. In some cases this influences the  design  of  field  values.
       <b>ip_frag</b>  is  the  most prominent example: it is designed to make all of
       the practically useful checks for IP fragmentation possible as a single
       bitwise match.

     <u>Shorthands</u>

       Some matches are very commonly used, so Open vSwitch accepts  shorthand
       notations.  In  some  cases, Open vSwitch also uses shorthand notations
       when it displays matches. The following shorthands  are  defined,  with
       their long forms shown on the right side:

              <b>eth</b>    <b>packet_type=(0,0)</b> (Open vSwitch 2.8 and later)

              <b>ip</b>     <b>eth_type=0x0800</b>

              <b>ipv6</b>   <b>eth_type=0x86dd</b>

              <b>icmp</b>   <b>eth_type=0x0800,ip_proto=1</b>

              <b>icmp6</b>  <b>eth_type=0x86dd,ip_proto=58</b>

              <b>tcp</b>    <b>eth_type=0x0800,ip_proto=6</b>

              <b>tcp6</b>   <b>eth_type=0x86dd,ip_proto=6</b>

              <b>udp</b>    <b>eth_type=0x0800,ip_proto=17</b>

              <b>udp6</b>   <b>eth_type=0x86dd,ip_proto=17</b>

              <b>sctp</b>   <b>eth_type=0x0800,ip_proto=132</b>

              <b>sctp6</b>  <b>eth_type=0x86dd,ip_proto=132</b>

              <b>arp</b>    <b>eth_type=0x0806</b>

              <b>rarp</b>   <b>eth_type=0x8035</b>

              <b>mpls</b>   <b>eth_type=0x8847</b>

              <b>mplsm</b>  <b>eth_type=0x8848</b>

   <b>Evolution</b> <b>of</b> <b>OpenFlow</b> <b>Fields</b>
       The  discussion  so  far  applies to all OpenFlow and Open vSwitch ver‐
       sions. This section starts to draw in specific information by  explain‐
       ing,  in broad terms, the treatment of fields and matches in each Open‐
       Flow version.

     <u>OpenFlow</u> <u>1.0</u>

       OpenFlow 1.0 defined the OpenFlow protocol  format  of  a  match  as  a
       fixed-length data structure that could match on the following fields:

              •      Ingress port.

              •      Ethernet source and destination MAC.

              •      Ethertype (with a special value to match frames that lack
                     an Ethertype).

              •      VLAN ID and priority.

              •      IPv4 source, destination, protocol, and DSCP.

              •      TCP source and destination port.

              •      UDP source and destination port.

              •      ICMPv4 type and code.

              •      ARP IPv4 addresses (SPA and TPA) and opcode.

       Each supported field corresponded to some member of the data structure.
       Some  members represented multiple fields, in the case of the TCP, UDP,
       ICMPv4, and ARP fields whose presence is mutually exclusive. This  also
       meant that some members were poor fits for their fields: only the low 8
       bits of the 16-bit ARP opcode could be represented, and the ICMPv4 type
       and  code were padded with 8 bits of zeros to fit in the 16-bit members
       primarily meant for TCP and UDP ports. An additional bitmap member  in‐
       dicated,  for  each member, whether its field should be an ``exact’’ or
       ``wildcarded’’ match (see <u>Matching</u>), with additional support  for  CIDR
       prefix matching on the IPv4 source and destination fields.

       Simplicity was recognized early on as the main virtue of this approach.
       Obviously,  any fixed-length data structure cannot support matching new
       protocols that do not fit. There was no room, for example, for matching
       IPv6 fields, which was not a priority at the time. Lack of room to sup‐
       port matching the Ethernet addresses inside ARP packets actually caused
       more of a design problem later, leading to an  Open  vSwitch  extension
       action  specialized  for  dropping ``spoofed’’ ARP packets in which the
       frame and ARP Ethernet source addressed differed. (This  extension  was
       never  standardized. Open vSwitch dropped support for it a few releases
       after it added support for full ARP matching.)

       The design of the OpenFlow fixed-length matches also  illustrates  com‐
       promises,  in  both directions, between the strengths and weaknesses of
       software and hardware that have always influenced the design  of  Open‐
       Flow. Support for matching ARP fields that do fit in the data structure
       was  only  added  late  in the design process (and remained optional in
       OpenFlow 1.0), for example, because common switch ASICs did not support
       matching these fields.

       The compromises in favor of software occurred for more complicated rea‐
       sons. The OpenFlow designers did not know how to implement matching  in
       software  that  was  fast, dynamic, and general. (A way was later found
       [Srinivasan].) Thus, the designers sought to support  dynamic,  general
       matching  that  would be fast in realistic special cases, in particular
       when all of the matches were <u>microflows</u>, that is, matches that  specify
       every  field  present  in  a packet, because such matches can be imple‐
       mented as a single hash table lookup. Contemporary  research  supported
       the  feasibility of this approach: the number of microflows in a campus
       network had been measured to peak  at  about  10,000  [Casado,  section
       3.2]. (Calculations show that this can only be true in a lightly loaded
       network [Pepelnjak].)

       As  a result, OpenFlow 1.0 required switches to treat microflow matches
       as the highest possible priority. This let  software  switches  perform
       the  microflow  hash table lookup first. Only on failure to match a mi‐
       croflow did the switch need to fall back to checking the  more  general
       and presumed slower matches. Also, the OpenFlow 1.0 flow match was min‐
       imally  flexible,  with no support for general bitwise matching, partly
       on the basis that this seemed more likely amenable to relatively  effi‐
       cient  software  implementation.  (CIDR  masking for IPv4 addresses was
       added relatively late in the OpenFlow 1.0 design process.)

       Microflow matching was later discovered to aid some hardware  implemen‐
       tations.  The  TCAM  chips used for matching in hardware do not support
       priority in the same way as OpenFlow but instead tie priority to order‐
       ing [Pagiamtzis]. Thus, adding a new match with a priority between  the
       priorities of existing matches can require reordering an arbitrary num‐
       ber  of  TCAM  entries.  On the other hand, when microflows are highest
       priority, they can be managed as a set-aside portion of  the  TCAM  en‐
       tries.

       The  emphasis  on  matching  microflows also led designers to carefully
       consider the bandwidth requirements between switch and  controller:  to
       maximize  the  number of microflow setups per second, one must minimize
       the size of each flow’s description. This favored the fixed-length for‐
       mat in use, because it expressed common TCP and UDP microflows in fewer
       bytes than more flexible ``type-length-value’’  (TLV)  formats.  (Early
       versions  of OpenFlow also avoided TLVs in general to head off protocol
       fragmentation.)

       <u>Inapplicable</u> <u>Fields</u>

       OpenFlow 1.0 does not clearly specify how to treat inapplicable fields.
       The members for inapplicable fields are always  present  in  the  match
       data  structure,  as  are the bits that indicate whether the fields are
       matched, and the ``correct’’ member and  bit  values  for  inapplicable
       fields  is unclear. OpenFlow 1.0 implementations changed their behavior
       over time as priorities shifted. The early OpenFlow reference implemen‐
       tation, motivated to make every flow a  microflow  to  enable  hashing,
       treated  inapplicable  fields  as  exact  matches on a value of 0. Ini‐
       tially, this behavior was implemented in the reference controller only.

       Later, the reference switch was also  changed  to  actually  force  any
       wildcarded  inapplicable fields into exact matches on 0. The latter be‐
       havior sometimes caused problems, because the modified flow was the one
       reported back to the controller later when it queried the  flow  table,
       and  the  modifications  sometimes  meant that the controller could not
       properly recognize the flow that it had added. In  retrospect,  perhaps
       this  problem  should have alerted the designers to a design error, but
       the ability to use a single hash table was held to  be  more  important
       than almost every other consideration at the time.

       When  more flexible match formats were introduced much later, they dis‐
       allowed any mention of inapplicable fields as part  of  a  match.  This
       raised the question of how to translate between this new format and the
       OpenFlow 1.0 fixed format. It seemed somewhat inconsistent and backward
       to  treat  fields as exact-match in one format and forbid matching them
       in the other, so instead the treatment of inapplicable  fields  in  the
       fixed-length  format  was changed from exact match on 0 to wildcarding.
       (A better classifier had by now eliminated software  performance  prob‐
       lems with wildcards.)

       The OpenFlow 1.0.1 errata (released only in 2012) added some additional
       explanation  [OpenFlow 1.0.1, section 3.4], but it did not mandate spe‐
       cific behavior because of variation among implementations.

     <u>OpenFlow</u> <u>1.1</u>

       The  OpenFlow  1.1  protocol   match   format   was   designed   as   a
       type/length/value  (TLV)  format  to  allow for future flexibility. The
       specification standardized only a single type <b>OFPMT_STANDARD</b> (0) with a
       fixed-size payload, described here. The additional fields  and  bitwise
       masks  in  OpenFlow  1.1 cause this match structure to be over twice as
       large as in OpenFlow 1.0, 88 bytes versus 40.

       OpenFlow 1.1 added support for the following fields:

              •      SCTP source and destination port.

              •      MPLS label and traffic control (TC) fields.

              •      One 64-bit register (named ``metadata’’).

       OpenFlow 1.1 increased the width of the ingress port number field  (and
       all other port numbers in the protocol) from 16 bits to 32 bits.

       OpenFlow  1.1  increased  matching flexibility by introducing arbitrary
       bitwise matching on Ethernet and IPv4 address fields  and  on  the  new
       ``metadata’’  register field. Switches were not required to support all
       possible masks [OpenFlow 1.1, section 4.3].

       By a strict reading of the specification, OpenFlow 1.1 removed  support
       for  matching  ICMPv4  type and code [OpenFlow 1.1, section A.2.3], but
       this is likely an editing error  because  ICMP  matching  is  described
       elsewhere [OpenFlow 1.1, Table 3, Table 4, Figure 4]. Open vSwitch does
       support ICMPv4 type and code matching with OpenFlow 1.1.

       OpenFlow  1.1 avoided the pitfalls of inapplicable fields that OpenFlow
       1.0 encountered, by requiring the switch to ignore the specified  field
       values  [OpenFlow  1.1, section A.2.3]. It also implied that the switch
       should ignore the bits that  indicate  whether  to  match  inapplicable
       fields.

       <u>Physical</u> <u>Ingress</u> <u>Port</u>

       OpenFlow  1.1 introduced a new pseudo-field, the physical ingress port.
       The physical ingress port is only a pseudo-field because it  cannot  be
       used  for  matching.  It appears only one place in the protocol, in the
       ``packet-in’’ message that passes a packet received at the switch to an
       OpenFlow controller.

       A packet’s ingress port and physical ingress port are identical  except
       for  packets processed by a switch feature such as bonding or tunneling
       that makes a packet appear to arrive on a ``virtual’’  port  associated
       with  the bond or the tunnel. For such packets, the ingress port is the
       virtual port and the physical ingress port is, naturally, the  physical
       port. Open vSwitch implements both bonding and tunneling, but its bond‐
       ing implementation does not use virtual ports and its tunnels are typi‐
       cally  not  on the same OpenFlow switch as their physical ingress ports
       (which need not be part of any switch), so the ingress port and  physi‐
       cal ingress port are always the same in Open vSwitch.

     <u>OpenFlow</u> <u>1.2</u>

       OpenFlow  1.2 abandoned the fixed-length approach to matching. One rea‐
       son was size, since adding support for IPv6 address matching (now  seen
       as  important),  with  bitwise  masks, would have added 64 bytes to the
       match length, increasing it from 88 bytes in OpenFlow 1.1 to  over  150
       bytes.  Extensibility  had  also become important as controller writers
       increasingly wanted support for new fields  without  having  to  change
       messages  throughout the OpenFlow protocol. The challenges of carefully
       defining fixed-length  matches  to  avoid  problems  with  inapplicable
       fields had also become clear over time.

       Therefore,  OpenFlow  1.2  adopted a flow format using a flexible type-
       length-value (TLV) representation, in which each TLV expresses a  match
       on one field. These TLVs were in turn encapsulated inside the outer TLV
       wrapper  introduced  in  OpenFlow 1.1 with the new identifier <b>OFPMT_OXM</b>
       (1). (This wrapper fulfilled  its  intended  purpose  of  reducing  the
       amount  of churn in the protocol when changing match formats; some mes‐
       sages that included matches remained unchanged from OpenFlow 1.1 to 1.2
       and later versions.)

       OpenFlow 1.2 added support for the following fields:

              •      ARP hardware addresses (SHA and THA).

              •      IPv4 ECN.

              •      IPv6 source and destination addresses, flow label,  DSCP,
                     ECN, and protocol.

              •      TCP,  UDP, and SCTP port numbers when encapsulated inside
                     IPv6.

              •      ICMPv6 type and code.

              •      ICMPv6 Neighbor Discovery target address and  source  and
                     target Ethernet addresses.

       The  OpenFlow  1.2  format, called <u>OXM</u> (<u>OpenFlow</u> <u>Extensible</u> <u>Match</u>), was
       modeled closely on an extension to  OpenFlow  1.0  introduced  in  Open
       vSwitch 1.1 called <u>NXM</u> (<u>Nicira</u> <u>Extended</u> <u>Match</u>). Each OXM or NXM TLV has
       the following format:

               type
        &lt;----------------&gt;
             16        7   1    8      length bytes
       +------------+-----+--+------+ +------------+
       |vendor/class|field|HM|length| |    body    |
       +------------+-----+--+------+ +------------+


       The most significant 16 bits of the NXM or OXM header, called <b>vendor</b> by
       NXM  and  <b>class</b>  by OXM, identify an organization permitted to allocate
       identifiers for fields. NXM allocates  only  two  vendors,  0x0000  for
       fields  supported  by OpenFlow 1.0 and 0x0001 for fields implemented as
       an Open vSwitch extension. OXM assigns classes as follows:

              0x0000 (<b>OFPXMC_NXM_0</b>).
              0x0001 (<b>OFPXMC_NXM_1</b>).
                   Reserved for NXM compatibility.

              0x0002 to 0x7fff
                   Reserved for allocation to ONF members, but  none  yet  as‐
                   signed.

              0x8000 (<b>OFPXMC_OPENFLOW_BASIC</b>)
                   Used for most standard OpenFlow fields.

              0x8001 (<b>OFPXMC_PACKET_REGS</b>)
                   Used for packet register fields in OpenFlow 1.5 and later.

              0x8002 to 0xfffe
                   Reserved for the OpenFlow specification.

              0xffff (<b>OFPXMC_EXPERIMENTER</b>)
                   Experimental use.

       When  <b>class</b>  is  0xffff, the OXM header is extended to 64 bits by using
       the first 32 bits of the body as an <b>experimenter</b> field whose most  sig‐
       nificant byte is zero and whose remaining bytes are an Organizationally
       Unique  Identifier  (OUI) assigned by the IEEE [IEEE OUI], as shown be‐
       low.

            type                 experimenter
        &lt;----------&gt;             &lt;----------&gt;
          16     7   1    8        8     24     (length - 4) bytes
       +------+-----+--+------+ +------+-----+ +------------------+
       |class |field|HM|length| | zero | OUI | |       body       |
       +------+-----+--+------+ +------+-----+ +------------------+
        0xffff                    0x00


       OpenFlow says that support for experimenter fields  is  optional.  Open
       vSwitch  2.4  and  later  does support them, so that it can support the
       following experimenter classes:

              0x4f4e4600 (<b>ONFOXM_ET</b>)
                     Used by official Open Networking Foundation extensions in
                     OpenFlow 1.3 and later. e.g. [TCP Flags Match  Field  Ex‐
                     tension].

              0x005ad650 (<b>NXOXM_NSH</b>)
                     Used  by  Open vSwitch for NSH extensions, in the absence
                     of an official ONF-assigned class. (This OUI is  randomly
                     generated.)

       Taken  as  a  unit,  <b>class</b>  (or  <b>vendor</b>), <b>field</b>, and <b>experimenter</b> (when
       present) uniquely identify a particular field.

       When <b>hasmask</b> (abbreviated <b>HM</b> above) is 0, the OXM is an exact match  on
       an  entire  field.  In  this case, the body (excluding the experimenter
       field, if present) is a single value to be matched.

       When <b>hasmask</b> is 1, the OXM is a bitwise match. The body (excluding  the
       experimenter  field) consists of a value to match, followed by the bit‐
       wise mask to apply. A 1-bit in the mask indicates that the  correspond‐
       ing  bit  in  the value should be matched and a 0-bit that it should be
       ignored. For example, for an IP address field, a value  of  192.168.0.0
       followed  by  a  mask  of  255.255.0.0  would  match  addresses  in the
       196.168.0.0/16 subnet.

              •      Some fields might not support masking at  all,  and  some
                     fields  that do support masking might restrict it to cer‐
                     tain patterns. For example, fields that have  IP  address
                     values  might  be  restricted to CIDR masks. The descrip‐
                     tions of individual fields note these restrictions.

              •      An OXM TLV with a mask that is all zeros  is  not  useful
                     (although  it  is  not  forbidden), because it is has the
                     same effect as omitting the TLV entirely.

              •      It is not meaningful to pair a 0-bit in an OXM mask  with
                     a  1-bit  in  its value, and Open vSwitch rejects such an
                     OXM with the error <b>OFPBMC_BAD_WILDCARDS</b>, as  required  by
                     OpenFlow 1.3 and later.

       The  <b>length</b>  identifies  the number of bytes in the body, including the
       4-byte <b>experimenter</b> header, if it is present. Each OXM TLV has a  fixed
       length;  that  is,  given  <b>class</b>, <b>field</b>, <b>experimenter</b> (if present), and
       <b>hasmask</b>, <b>length</b> is a constant. The <b>length</b> is included explicitly to al‐
       low software to minimally parse OXM TLVs of unknown types.

       OXM TLVs must be ordered so that a field’s prerequisites are  satisfied
       before  it  is parsed. For example, an OXM TLV that matches on the IPv4
       source address field is only allowed following an OXM TLV that  matches
       on  the  Ethertype  for IPv4. Similarly, an OXM TLV that matches on the
       TCP source port must follow a TLV that matches an Ethertype of IPv4  or
       IPv6  and  one  that matches an IP protocol of TCP (in that order). The
       order of OXM TLVs is not otherwise restricted; no canonical ordering is
       defined.

       A given field may be matched only once in a series of OXM TLVs.

     <u>OpenFlow</u> <u>1.3</u>

       OpenFlow 1.3 showed OXM to be largely successful, by adding new  fields
       without  making  any  changes  to how flow matches otherwise worked. It
       added OXMs for the following fields supported by Open vSwitch:

              •      Tunnel ID for ports associated with e.g. VXLAN  or  keyed
                     GRE.

              •      MPLS ``bottom of stack’’ (BOS) bit.

       OpenFlow  1.3  also  added OXMs for the following fields not documented
       here and not yet implemented by Open vSwitch:

              •      IPv6 extension header handling.

              •      PBB I-SID.

     <u>OpenFlow</u> <u>1.4</u>

       OpenFlow 1.4 added OXMs for the following fields  not  documented  here
       and not yet implemented by Open vSwitch:

              •      PBB UCA.

     <u>OpenFlow</u> <u>1.5</u>

       OpenFlow  1.5  added  OXMs  for  the following fields supported by Open
       vSwitch:

              •      Packet type.

              •      TCP flags.

              •      Packet registers.

              •      The output port in the OpenFlow action set.

<b>FIELDS</b> <b>REFERENCE</b>
       The following sections document the fields that Open vSwitch  supports.
       Each  section  provides  introductory  material  on  a group of related
       fields, followed by information on each individual field.  In  addition
       to  field-specific information, each field begins with a table with en‐
       tries for the following important properties:

              Name   The field’s name, used for  parsing  and  formatting  the
                     field,  e.g.  in  <b>ovs-ofctl</b> commands. For historical rea‐
                     sons, some fields have an additional  name  that  is  ac‐
                     cepted  as  an  alternative  in  parsing. This name, when
                     there is one, is listed as well,  e.g.  ``<b>tun</b>  (aka  <b>tun‐</b>
                     <b>nel_id</b>).’’

              Width  The  field’s  width,  always  a  multiple of 8 bits. Some
                     fields don’t use all of the bits, so this may be accompa‐
                     nied by an explanation. For example, OpenFlow embeds  the
                     2-bit  IP  ECN field as as the low bits in an 8-bit byte,
                     and so its width is  expressed  as  ``8  bits  (only  the
                     least-significant 2 bits may be nonzero).’’

              Format How  a  value  for  the  field is formatted or parsed by,
                     e.g., <b>ovs-ofctl</b>. Some possibilities are generic:

                     decimal
                            Formats as a decimal  number.  On  input,  accepts
                            decimal numbers or hexadecimal numbers prefixed by
                            <b>0x</b>.

                     hexadecimal
                            Formats as a hexadecimal number prefixed by <b>0x</b>. On
                            input, accepts decimal numbers or hexadecimal num‐
                            bers  prefixed  by <b>0x</b>. (The default for parsing is
                            <b>not</b> hexadecimal: only a <b>0x</b> prefix causes input  to
                            be treated as hexadecimal.)

                     Ethernet
                            Formats  and  accepts  the common Ethernet address
                            format <u>xx</u><b>:</b><u>xx</u><b>:</b><u>xx</u><b>:</b><u>xx</u><b>:</b><u>xx</u><b>:</b><u>xx</u>.

                     IPv4   Formats  and  accepts   the   dotted-quad   format
                            <u>a</u><b>.</b><u>b</u><b>.</b><u>c</u><b>.</b><u>d</u>.  For bitwise matches, formats and accepts
                            <u>address</u><b>/</b><u>length</u> CIDR notation in  addition  to  <u>ad‐</u>
                            <u>dress</u><b>/</b><u>mask</u>.

                     IPv6   Formats  and  accepts the common IPv6 address for‐
                            mats, plus CIDR notation for bitwise matches.

                     OpenFlow 1.0 port
                            Accepts 16-bit port numbers in decimal, plus Open‐
                            Flow well-known port names (e.g. <b>IN_PORT</b>)  in  up‐
                            percase or lowercase.

                     OpenFlow 1.1+ port
                            Same  syntax  as OpenFlow 1.0 ports but for 32-bit
                            OpenFlow 1.1+ port number fields.

                     Other, field-specific formats are  explained  along  with
                     their fields.

              Masking
                     For  most  fields, this says ``arbitrary bitwise masks,’’
                     meaning that a flow may match any combination of bits  in
                     the  field. Some fields instead say ``exact match only,’’
                     which means that a flow that matches on this  field  must
                     match  on  the  whole field instead of just certain bits.
                     Either way, this reports masking support for  the  latest
                     version of Open vSwitch using OXM or NXM (that is, either
                     OpenFlow  1.2+  or OpenFlow 1.0 plus Open vSwitch NXM ex‐
                     tensions). In particular, OpenFlow 1.0 (without NXM)  and
                     1.1 don’t always support masking even if Open vSwitch it‐
                     self  does;  refer  to  the <b>OpenFlow</b> <b>1.0</b> and <b>OpenFlow</b> <b>1.1</b>
                     rows to learn about masking with these protocol versions.

              Prerequisites
                     Requirements that must be met to match on this field. For
                     example, <b>ip_src</b> has IPv4 as a prerequisite, meaning  that
                     a match must include <b>eth_type=0x0800</b> to match on the IPv4
                     source  address.  The following prerequisites, with their
                     requirements, are currently in use:

                     none   (no requirements)

                     VLAN VID
                            <b>vlan_tci=0x1000/0x1000</b>  (i.e.  a  VLAN  header  is
                            present)

                     ARP    <b>eth_type=0x0806</b> (ARP) or <b>eth_type=0x8035</b> (RARP)

                     IPv4   <b>eth_type=0x0800</b>

                     IPv6   <b>eth_type=0x86dd</b>

                     IPv4/IPv6
                            IPv4 or IPv6

                     MPLS   <b>eth_type=0x8847</b> or <b>eth_type=0x8848</b>

                     TCP    IPv4/IPv6 and <b>ip_proto=6</b>

                     UDP    IPv4/IPv6 and <b>ip_proto=17</b>

                     SCTP   IPv4/IPv6 and <b>ip_proto=132</b>

                     ICMPv4 IPv4 and <b>ip_proto=1</b>

                     ICMPv6 IPv6 and <b>ip_proto=58</b>

                     ND solicit
                            ICMPv6 and <b>icmp_type=135</b> and <b>icmp_code=0</b>

                     ND advert
                            ICMPv6 and <b>icmp_type=136</b> and <b>icmp_code=0</b>

                     ND     ND solicit or ND advert

                     The  TCP,  UDP, and SCTP prerequisites also have the spe‐
                     cial requirement that <b>nw_frag</b> is not being used to select
                     ``later fragments.’’ This is because only the first frag‐
                     ment of a fragmented IPv4 or IPv6 datagram  contains  the
                     TCP or UDP header.

              Access Most  fields  are ``read/write,’’ which means that common
                     OpenFlow actions like <b>set_field</b> can modify  them.  Fields
                     that  are  ``read-only’’ cannot be modified in these gen‐
                     eral-purpose ways, although there may be other ways  that
                     actions can modify them.

              OpenFlow 1.0
              OpenFlow 1.1
                   These rows report the level of support that OpenFlow 1.0 or
                   OpenFlow  1.1,  respectively, has for a field. For OpenFlow
                   1.0, supported fields are reported as either  ``yes  (exact
                   match  only)’’  for  fields that do not support any bitwise
                   masking or ``yes (CIDR match only)’’ for fields  that  sup‐
                   port CIDR masking. OpenFlow 1.1 supported fields report ei‐
                   ther  ``yes  (exact  match  only)’’  or  simply ``yes’’ for
                   fields that do support arbitrary masks. These OpenFlow ver‐
                   sions supported a fixed collection of fields that cannot be
                   extended, so many more fields are reported  as  ``not  sup‐
                   ported.’’

              OXM
              NXM  These  rows  report the OXM and NXM code points that corre‐
                   spond to a given field. Either or both may be ``none.’’

                   A field that has only an OXM code point is usually one that
                   was standardized before it was added  to  Open  vSwitch.  A
                   field  that  has only an NXM code point is usually one that
                   is not yet standardized. When a field has both OXM and  NXM
                   code points, it usually indicates that it was introduced as
                   an  Open  vSwitch  extension under the NXM code point, then
                   later standardized under the OXM code point.  A  field  can
                   have more than one OXM code point if it was standardized in
                   OpenFlow 1.4 or later and additionally introduced as an of‐
                   ficial  ONF  extension  for OpenFlow 1.3. (A field that has
                   neither OXM nor NXM code point  is  typically  an  obsolete
                   field  that  is  supported  in some other form using OXM or
                   NXM.)

                   Each code point in these rows  is  described  in  the  form
                   ``<b>NAME</b>  (<u>number</u>)  since OpenFlow <u>spec</u> and Open vSwitch <u>ver‐</u>
                   <u>sion</u>,’’ e.g. ``<b>OXM_OF_ETH_TYPE</b> (5) since OpenFlow  1.2  and
                   Open vSwitch 1.7.’’ First, <b>NAME</b>, which specifies a name for
                   the  code  point,  starts  with  a prefix that designates a
                   class and, in some cases, a vendor, as listed in  the  fol‐
                   lowing table:

                   Prefix           Vendor       Class
                   ───────────────  ───────────  ───────
                   <b>NXM_OF</b>           (none)       0x0000
                   <b>NXM_NX</b>           (none)       0x0001
                   <b>ERICOXM_OF</b>       (none)       0x1000
                   <b>OXM_OF</b>           (none)       0x8000
                   <b>OXM_OF_PKT_REG</b>   (none)       0x8001
                   <b>NXOXM_ET</b>         0x00002320   0xffff
                   <b>NXOXM_NSH</b>        0x005ad650   0xffff
                   <b>ONFOXM_ET</b>        0x4f4e4600   0xffff

                   For  more information on OXM/NXM classes and vendors, refer
                   back to <b>OpenFlow</b> <b>1.2</b> under <b>Evolution</b>  <b>of</b>  <b>OpenFlow</b>  <b>Fields</b>.
                   The <u>number</u> is the field number within the class and vendor.
                   The OpenFlow <u>spec</u> is the version of OpenFlow that standard‐
                   ized  the code point. It is omitted for NXM code points be‐
                   cause they are nonstandard. The <u>version</u> is the  version  of
                   Open vSwitch that first supported the code point.
<b>CONJUNCTIVE</b> <b>MATCH</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name      Bytes   Mask   RW?   Prereqs   NXM/OXM Support
       ────────  ──────  ─────  ────  ────────  ────────────────
       <b>conj_id</b>   4       no     no    none      OVS 2.4+

       An  individual  OpenFlow  flow  can  match only a single value for each
       field. However, situations often arise where one wants to match one  of
       a  set  of values within a field or fields. For matching a single field
       against a set, it is straightforward  and  efficient  to  add  multiple
       flows  to  the  flow table, one for each value in the set. For example,
       one might use the following flows to send packets with  IP  source  ad‐
       dress <u>a</u>, <u>b</u>, <u>c</u>, or <u>d</u> to the OpenFlow controller:

             <b>ip,ip_src=</b><u>a</u> actions=controller
             <b>ip,ip_src=</b><u>b</u> actions=controller
             <b>ip,ip_src=</b><u>c</u> actions=controller
             <b>ip,ip_src=</b><u>d</u> actions=controller


       Similarly,  these  flows send packets with IP destination address <u>e</u>, <u>f</u>,
       <u>g</u>, or <u>h</u> to the OpenFlow controller:

             <b>ip,ip_dst=</b><u>e</u> actions=controller
             <b>ip,ip_dst=</b><u>f</u> actions=controller
             <b>ip,ip_dst=</b><u>g</u> actions=controller
             <b>ip,ip_dst=</b><u>h</u> actions=controller


       Installing all of the above flows in a single flow table yields a  dis‐
       junctive  effect:  a  packet  is  sent  to  the  controller if <b>ip_src</b> ∈
       {<u>a</u>,<u>b</u>,<u>c</u>,<u>d</u>} or <b>ip_dst</b> ∈ {<u>e</u>,<u>f</u>,<u>g</u>,<u>h</u>} (or both). (Pedantically,  if  both  of
       the above sets of flows are present in the flow table, they should have
       different  priorities, because OpenFlow says that the results are unde‐
       fined when two flows  with  same  priority  can  both  match  a  single
       packet.)

       Suppose, on the other hand, one wishes to match conjunctively, that is,
       to  send a packet to the controller only if both <b>ip_src</b> ∈ {<u>a</u>,<u>b</u>,<u>c</u>,<u>d</u>} and
       <b>ip_dst</b> ∈ {<u>e</u>,<u>f</u>,<u>g</u>,<u>h</u>}. This requires 4 × 4 = 16 flows, one for each possi‐
       ble pairing of <b>ip_src</b> and <b>ip_dst</b>. That is acceptable for our small  ex‐
       ample, but it does not gracefully extend to larger sets or greater num‐
       bers of dimensions.

       The  <b>conjunction</b>  action  is a solution for conjunctive matches that is
       built into Open vSwitch. A <b>conjunction</b> action ties groups of individual
       OpenFlow flows into higher-level ``conjunctive flows’’. Each group cor‐
       responds to one dimension, and each flow within the group  matches  one
       possible  value  for the dimension. A packet that matches one flow from
       each group matches the conjunctive flow.

       To implement a conjunctive flow with <b>conjunction</b>, assign  the  conjunc‐
       tive  flow  a 32-bit <u>id</u>, which must be unique within an OpenFlow table.
       Assign each of the <u>n</u> ≥ 2 dimensions a unique number from 1  to  <u>n</u>;  the
       ordering  is  unimportant.  Add one flow to the OpenFlow flow table for
       each possible value of each dimension with <b>conjunction(</b><u>id</u><b>,</b> <u>k</u><b>/</b><u>n</u><b>)</b> as  the
       flow’s actions, where <u>k</u> is the number assigned to the flow’s dimension.
       Together,  these  flows specify the conjunctive flow’s match condition.
       When the conjunctive match condition is met, Open vSwitch looks up  one
       more  flow  that  specifies the conjunctive flow’s actions and receives
       its statistics. This flow is found by setting <b>conj_id</b> to the  specified
       <u>id</u> and then again searching the flow table.

       The  following  flows provide an example. Whenever the IP source is one
       of the values in the flows that match on the IP source (dimension 1  of
       2), <b>and</b> the IP destination is one of the values in the flows that match
       on  IP destination (dimension 2 of 2), Open vSwitch searches for a flow
       that matches <b>conj_id</b> against the conjunction  ID  (1234),  finding  the
       first flow listed below.

             <b>conj_id=1234</b> <b>actions=controller</b>
             <b>ip,ip_src=10.0.0.1</b> <b>actions=conjunction(1234,</b> <b>1/2)</b>
             <b>ip,ip_src=10.0.0.4</b> <b>actions=conjunction(1234,</b> <b>1/2)</b>
             <b>ip,ip_src=10.0.0.6</b> <b>actions=conjunction(1234,</b> <b>1/2)</b>
             <b>ip,ip_src=10.0.0.7</b> <b>actions=conjunction(1234,</b> <b>1/2)</b>
             <b>ip,ip_dst=10.0.0.2</b> <b>actions=conjunction(1234,</b> <b>2/2)</b>
             <b>ip,ip_dst=10.0.0.5</b> <b>actions=conjunction(1234,</b> <b>2/2)</b>
             <b>ip,ip_dst=10.0.0.7</b> <b>actions=conjunction(1234,</b> <b>2/2)</b>
             <b>ip,ip_dst=10.0.0.8</b> <b>actions=conjunction(1234,</b> <b>2/2)</b>


       Many subtleties exist:

              •      In  the  example  above, every flow in a single dimension
                     has the same form, that is, dimension 1 matches on <b>ip_src</b>
                     and dimension 2 on <b>ip_dst</b>, but this is not a requirement.
                     Different flows within a dimension may match on different
                     bits within a field (e.g. IP network prefixes of  differ‐
                     ent  lengths, or TCP/UDP port ranges as bitwise matches),
                     or even on entirely different fields (e.g. to match pack‐
                     ets for TCP source port 80 or TCP destination port 80).

              •      The flows within  a  dimension  can  vary  their  matches
                     across  more  than one field, e.g. to match only specific
                     pairs of IP source and destination addresses or  L4  port
                     numbers.

              •      A  flow  may have multiple <b>conjunction</b> actions, with dif‐
                     ferent <b>id</b> values. This is useful for multiple conjunctive
                     flows with overlapping  sets.  If  one  conjunctive  flow
                     matches  packets  with  both  <b>ip_src</b> ∈ {<u>a</u>,<u>b</u>} and <b>ip_dst</b> ∈
                     {<u>d</u>,<u>e</u>} and a second  conjunctive  flow  matches  <b>ip_src</b>  ∈
                     {<u>b</u>,<u>c</u>} and <b>ip_dst</b> ∈ {<u>f</u>,<u>g</u>}, for example, then the flow that
                     matches  <b>ip_src=</b><u>b</u> would have two <b>conjunction</b> actions, one
                     for each conjunctive flow. The order of  <b>conjunction</b>  ac‐
                     tions within a list of actions is not significant.

              •      A flow with <b>conjunction</b> actions may also include <b>note</b> ac‐
                     tions for annotations, but not any other kind of actions.
                     (They would not be useful because they would never be ex‐
                     ecuted.)

              •      All  of the flows that constitute a conjunctive flow with
                     a given <u>id</u> must have the same priority. (Flows  with  the
                     same <u>id</u> but different priorities are currently treated as
                     different conjunctive flows, that is, currently <u>id</u> values
                     need  only  be unique within an OpenFlow table at a given
                     priority. This behavior isn’t guaranteed to stay the same
                     in later releases, so please use <u>id</u> values unique  within
                     an OpenFlow table.)

              •      Conjunctive  flows must not overlap with each other, at a
                     given priority, that is, any given packet must be able to
                     match at most one conjunctive flow at a  given  priority.
                     Overlapping  conjunctive  flows  yield  unpredictable re‐
                     sults. (The flows that constitute a conjunctive flow  may
                     overlap  with  those  that constitute the same or another
                     conjunctive flow.)

              •      Following a conjunctive flow match, the  search  for  the
                     flow  with <b>conj_id=</b><u>id</u> is done in the same general-purpose
                     way as other flow table searches, so one  can  use  flows
                     with  <b>conj_id=</b><u>id</u>  to act differently depending on circum‐
                     stances. (One  exception  is  that  the  search  for  the
                     <b>conj_id=</b><u>id</u>  flow  itself  ignores  conjunctive  flows, to
                     avoid recursion.) If the search  with  <b>conj_id=</b><u>id</u>  fails,
                     Open  vSwitch  acts  as  if  the conjunctive flow had not
                     matched at all, and continues searching  the  flow  table
                     for other matching flows.

              •      OpenFlow  prerequisite  checking occurs for the flow with
                     <b>conj_id=</b><u>id</u> in the same way as any other flow, e.g. in  an
                     OpenFlow  1.1+  context, putting a <b>mod_nw_src</b> action into
                     the example above would require adding an <b>ip</b> match,  like
                     this:

                               <b>conj_id=1234,ip</b> <b>actions=mod_nw_src:1.2.3.4,controller</b>


              •      OpenFlow  prerequisite checking also occurs for the indi‐
                     vidual flows that comprise a  conjunctive  match  in  the
                     same way as any other flow.

              •      The  flows that constitute a conjunctive flow do not have
                     useful statistics. They are never updated  with  byte  or
                     packet  counts,  and  so on. (For such a flow, therefore,
                     the idle and hard timeouts work much the same way.)

              •      Sometimes there is a choice of which flows include a par‐
                     ticular match. For example, suppose that we added an  ex‐
                     tra  constraint  to  our  example,  to  match on <b>ip_src</b> ∈
                     {<u>a</u>,<u>b</u>,<u>c</u>,<u>d</u>} and <b>ip_dst</b> ∈ {<u>e</u>,<u>f</u>,<u>g</u>,<u>h</u>} and <b>tcp_dst</b> = <u>i</u>. One way
                     to implement this is to add the  new  constraint  to  the
                     <b>conj_id</b> flow, like this:

                               <b>conj_id=1234,tcp,tcp_dst=</b><u>i</u> actions=mod_nw_src:1.2.3.4,controller


                     but  <b>this</b>  <b>is</b>  <b>not</b> <b>recommended</b> because of the cost of the
                     extra flow table lookup. Instead, add the  constraint  to
                     the  individual flows, either in one of the dimensions or
                     (slightly better) all of them.

              •      A conjunctive match must have <u>n</u> ≥ 2 dimensions (otherwise
                     a conjunctive match is not necessary). Open  vSwitch  en‐
                     forces this.

              •      Each dimension within a conjunctive match should ordinar‐
                     ily  have  more  than one flow. Open vSwitch does not en‐
                     force this.

       <b>Conjunction</b> <b>ID</b> <b>Field</b>
       Name:            <b>conj_id</b>
       Width:           32 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   none
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CONJ_ID</b> (37) since Open vSwitch 2.4

       Used for conjunctive matching. See above for more information.

<b>TUNNEL</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name                   Bytes             Mask   RW?   Prereqs   NXM/OXM Support
       ─────────────────────  ────────────────  ─────  ────  ────────  ─────────────────────
       <b>tun_id</b> aka <b>tunnel_id</b>   8                 yes    yes   none      OF 1.3+ and OVS 1.1+
       <b>tun_src</b>                4                 yes    yes   none      OVS 2.0+
       <b>tun_dst</b>                4                 yes    yes   none      OVS 2.0+
       <b>tun_ipv6_src</b>           16                yes    yes   none      OVS 2.5+
       <b>tun_ipv6_dst</b>           16                yes    yes   none      OVS 2.5+
       <b>tun_gbp_id</b>             2                 yes    yes   none      OVS 2.4+
       <b>tun_gbp_flags</b>          1                 yes    yes   none      OVS 2.4+
       <b>tun_erspan_ver</b>         1 (low 4 bits)    yes    yes   none      OVS 2.10+
       <b>tun_erspan_idx</b>         4 (low 20 bits)   yes    yes   none      OVS 2.10+
       <b>tun_erspan_dir</b>         1 (low 1 bits)    yes    yes   none      OVS 2.10+
       <b>tun_erspan_hwid</b>        1 (low 6 bits)    yes    yes   none      OVS 2.10+
       <b>tun_gtpu_flags</b>         1                 yes    no    none      OVS 2.13+
       <b>tun_gtpu_msgtype</b>       1                 yes    no    none      OVS 2.13+
       <b>tun_metadata0</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata1</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata2</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata3</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata4</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata5</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata6</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata7</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata8</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata9</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata10</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata11</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata12</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata13</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata14</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata15</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata16</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata17</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata18</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata19</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata20</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata21</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata22</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata23</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata24</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata25</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata26</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata27</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata28</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata29</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata30</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata31</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata32</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata33</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata34</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata35</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata36</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata37</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata38</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata39</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata40</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata41</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata42</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata43</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata44</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata45</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata46</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata47</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata48</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata49</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata50</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata51</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata52</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata53</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata54</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata55</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata56</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata57</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata58</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata59</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata60</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata61</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata62</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata63</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_flags</b>              2 (low 1 bits)    yes    yes   none      OVS 2.5+

       The fields in this group relate to tunnels, which Open vSwitch supports
       in several forms (GRE, VXLAN, and so on). Most of these fields  do  ap‐
       pear  in the wire format of a packet, so they are data fields from that
       point of view, but they are metadata from an OpenFlow flow table  point
       of view because they do not appear in packets that are forwarded to the
       controller or to ordinary (non-tunnel) output ports.

       Open vSwitch supports a spectrum of usage models for mapping tunnels to
       OpenFlow ports:

              ``Port-based’’ tunnels
                     In this model, an OpenFlow port represents one tunnel: it
                     matches  a  particular type of tunnel traffic between two
                     IP endpoints, with a particular tunnel key (if  keys  are
                     in  use).  In this situation, <b>in_port</b> suffices to distin‐
                     guish one tunnel  from  another,  so  the  tunnel  header
                     fields  have  little  importance for OpenFlow processing.
                     (They are still populated and may be used if it is conve‐
                     nient.) The tunnel header fields play no role in  sending
                     packets  out  such  an OpenFlow port, either, because the
                     OpenFlow port itself fully specifies the tunnel headers.

                     The following  Open  vSwitch  commands  create  a  bridge
                     <b>br-int</b>,  add  port <b>tap0</b> to the bridge as OpenFlow port 1,
                     establish a port-based GRE tunnel between the local  host
                     and  remote IP 192.168.1.1 using GRE key 5001 as OpenFlow
                     port 2, and arranges to forward all traffic from <b>tap0</b>  to
                     the tunnel and vice versa:

                     <b>ovs-vsctl</b> <b>add-br</b> <b>br-int</b>
                     <b>ovs-vsctl</b> <b>add-port</b> <b>br-int</b> <b>tap0</b> <b>--</b> <b>set</b> <b>interface</b> <b>tap0</b> <b>ofport_request=1</b>
                     <b>ovs-vsctl</b> <b>add-port</b> <b>br-int</b> <b>gre0</b> <b>--</b> <b>\</b>
                         <b>set</b> <b>interface</b> <b>gre0</b> <b>ofport_request=2</b> <b>type=gre</b> <b>\</b>
                                            <b>options:remote_ip=192.168.1.1</b> <b>options:key=5001</b>
                     <b>ovs-ofctl</b> <b>add-flow</b> <b>br-int</b> <b>in_port=1,actions=2</b>
                     <b>ovs-ofctl</b> <b>add-flow</b> <b>br-int</b> <b>in_port=2,actions=1</b>


              ``Flow-based’’ tunnels
                     In  this model, one OpenFlow port represents all possible
                     tunnels of a given type with an endpoint on  the  current
                     host,  for  example,  all GRE tunnels. In this situation,
                     <b>in_port</b> only indicates that traffic was received  on  the
                     particular  kind  of  tunnel.  This  is  where the tunnel
                     header fields are most important: they allow the OpenFlow
                     tables to discriminate among tunnels based  on  their  IP
                     endpoints  or  keys.  Tunnel header fields also determine
                     the IP endpoints and keys of packets sent out such a tun‐
                     nel port.

                     The following  Open  vSwitch  commands  create  a  bridge
                     <b>br-int</b>,  add  port <b>tap0</b> to the bridge as OpenFlow port 1,
                     establish a flow-based GRE tunnel port 3, and arranges to
                     forward all traffic from <b>tap0</b> to  remote  IP  192.168.1.1
                     over a GRE tunnel with key 5001 and vice versa:

                     <b>ovs-vsctl</b> <b>add-br</b> <b>br-int</b>
                     <b>ovs-vsctl</b> <b>add-port</b> <b>br-int</b> <b>tap0</b> <b>--</b> <b>set</b> <b>interface</b> <b>tap0</b> <b>ofport_request=1</b>
                     <b>ovs-vsctl</b> <b>add-port</b> <b>br-int</b> <b>allgre</b> <b>--</b> <b>\</b>
                         <b>set</b> <b>interface</b> <b>allgre</b> <b>ofport_request=3</b> <b>type=gre</b> <b>\</b>
                                              <b>options:remote_ip=flow</b> <b>options:key=flow</b>
                     <b>ovs-ofctl</b> <b>add-flow</b> <b>br-int</b> <b>\</b>
                         <b>’in_port=1</b> <b>actions=set_tunnel:5001,set_field:192.168.1.1-&gt;tun_dst,3’</b>
                     <b>ovs-ofctl</b> <b>add-flow</b> <b>br-int</b> <b>’in_port=3,tun_src=192.168.1.1,tun_id=5001</b> <b>actions=1’</b>


              Mixed models.
                     One  may define both flow-based and port-based tunnels at
                     the same time. For example, it is valid and possibly use‐
                     ful to create and configure both <b>gre0</b> and  <b>allgre</b>  tunnel
                     ports described above.

                     Traffic  is  attributed  on  ingress to the most specific
                     matching tunnel. For example, <b>gre0</b> is more specific  than
                     <b>allgre</b>.  Therefore,  if both exist, then <b>gre0</b> will be the
                     ingress  port  for  any   GRE   traffic   received   from
                     192.168.1.1 with key 5001.

                     On  egress,  traffic  may  be directed to any appropriate
                     tunnel port. If both <b>gre0</b> and <b>allgre</b>  are  configured  as
                     already  described,  then  the  actions  <b>2</b>  and  <b>set_tun‐</b>
                     <b>nel:5001,set_field:192.168.1.1-&gt;tun_dst,3</b> send  the  same
                     tunnel traffic.

              Intermediate models.
                     Ports  may be configured as partially flow-based. For ex‐
                     ample, one may define an OpenFlow  port  that  represents
                     tunnels  between  a pair of endpoints but leaves the flow
                     table to discriminate on the flow key.

       <b>ovs-vswitchd.conf.db</b>(5) describes all the details of tunnel  configura‐
       tion.

       These fields do not have any prerequisites, which means that a flow may
       match on any or all of them, in any combination.

       These fields are zeros for packets that did not arrive on a tunnel.

       <b>Tunnel</b> <b>ID</b> <b>Field</b>
       Name:            <b>tun_id</b> (aka <b>tunnel_id</b>)
       Width:           64 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_TUNNEL_ID</b>  (38)  since  OpenFlow  1.3  and Open
                        vSwitch 1.10
       NXM:             <b>NXM_NX_TUN_ID</b> (16) since Open vSwitch 1.1

       Many kinds of tunnels support a tunnel ID:

              •      VXLAN and Geneve have a 24-bit virtual network identifier
                     (VNI).

              •      LISP has a 24-bit instance ID.

              •      GRE has an optional 32-bit key.

              •      STT has a 64-bit key.

              •      ERSPAN has a 10-bit key (Session ID).

              •      GTPU has a 32-bit key (Tunnel Endpoint ID).

       When a packet is received from a tunnel, this field holds the tunnel ID
       in its least significant bits, zero-extended to fit. This field is zero
       if the tunnel does not support an ID, or if no ID is in use for a  tun‐
       nel  type  that has an optional ID, or if an ID of zero received, or if
       the packet was not received over a tunnel.

       When a packet is output to a tunnel port, the tunnel configuration  de‐
       termines  whether  the tunnel ID is taken from this field or bound to a
       fixed value. See the earlier description of ``port-based’’ and  ``flow-
       based’’ tunnels for more information.

       The following diagram shows the origin of this field in a typical keyed
       GRE tunnel:

          Ethernet            IPv4               GRE           Ethernet
        &lt;-----------&gt;   &lt;---------------&gt;   &lt;------------&gt;   &lt;----------&gt;
        48  48   16           8   32  32    16    16   32    48  48   16
       +---+---+-----+ +---+-----+---+---+ +---+------+---+ +---+---+----+
       |dst|src|type | |...|proto|src|dst| |...| type |key| |dst|src|type| ...
       +---+---+-----+ +---+-----+---+---+ +---+------+---+ +---+---+----+
                0x800        47                 0x6558


       <b>Tunnel</b> <b>IPv4</b> <b>Source</b> <b>Field</b>
       Name:            <b>tun_src</b>
       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_TUN_IPV4_SRC</b> (31) since Open vSwitch 2.0

       When  a  packet is received from a tunnel, this field is the source ad‐
       dress in the outer IP header of the tunneled packet. This field is zero
       if the packet was not received over a tunnel.

       When a packet is output to a flow-based tunnel port, this field  influ‐
       ences  the  IPv4 source address used to send the packet. If it is zero,
       then the kernel chooses an appropriate IP address based using the rout‐
       ing table.

       The following diagram shows the origin of this field in a typical keyed
       GRE tunnel:

          Ethernet            IPv4               GRE           Ethernet
        &lt;-----------&gt;   &lt;---------------&gt;   &lt;------------&gt;   &lt;----------&gt;
        48  48   16           8   32  32    16    16   32    48  48   16
       +---+---+-----+ +---+-----+---+---+ +---+------+---+ +---+---+----+
       |dst|src|type | |...|proto|src|dst| |...| type |key| |dst|src|type| ...
       +---+---+-----+ +---+-----+---+---+ +---+------+---+ +---+---+----+
                0x800        47                 0x6558


       <b>Tunnel</b> <b>IPv4</b> <b>Destination</b> <b>Field</b>
       Name:            <b>tun_dst</b>
       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_TUN_IPV4_DST</b> (32) since Open vSwitch 2.0

       When a packet is received from a tunnel, this field is the  destination
       address  in  the  outer IP header of the tunneled packet. This field is
       zero if the packet was not received over a tunnel.

       When a packet is output to a flow-based tunnel port, this field  speci‐
       fies the destination to which the tunnel packet is sent.

       The following diagram shows the origin of this field in a typical keyed
       GRE tunnel:

          Ethernet            IPv4               GRE           Ethernet
        &lt;-----------&gt;   &lt;---------------&gt;   &lt;------------&gt;   &lt;----------&gt;
        48  48   16           8   32  32    16    16   32    48  48   16
       +---+---+-----+ +---+-----+---+---+ +---+------+---+ +---+---+----+
       |dst|src|type | |...|proto|src|dst| |...| type |key| |dst|src|type| ...
       +---+---+-----+ +---+-----+---+---+ +---+------+---+ +---+---+----+
                0x800        47                 0x6558


       <b>Tunnel</b> <b>IPv6</b> <b>Source</b> <b>Field</b>
       Name:            <b>tun_ipv6_src</b>
       Width:           128 bits
       Format:          IPv6
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_TUN_IPV6_SRC</b> (109) since Open vSwitch 2.5

       Similar to <b>tun_src</b>, but for tunnels over IPv6.

       <b>Tunnel</b> <b>IPv6</b> <b>Destination</b> <b>Field</b>
       Name:            <b>tun_ipv6_dst</b>
       Width:           128 bits
       Format:          IPv6
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_TUN_IPV6_DST</b> (110) since Open vSwitch 2.5

       Similar to <b>tun_dst</b>, but for tunnels over IPv6.

   <b>VXLAN</b> <b>Group-Based</b> <b>Policy</b> <b>Fields</b>
       The VXLAN header is defined as follows [RFC 7348], where the <b>I</b> bit must
       be set to 1, unlabeled bits or those labeled <b>reserved</b> must be set to 0,
       and Open vSwitch makes the VNI available via <b>tun_id</b>:

          VXLAN flags
        &lt;-------------&gt;
        1 1 1 1 1 1 1 1    24    24     8
       +-+-+-+-+-+-+-+-+--------+---+--------+
       | | | | |I| | | |reserved|VNI|reserved|
       +-+-+-+-+-+-+-+-+--------+---+--------+


       VXLAN Group-Based Policy [VXLAN Group Policy Option] adds new interpre‐
       tations to existing bits in the VXLAN header, reinterpreting it as fol‐
       lows, with changes highlighted:

           GBP flags
        &lt;-------------&gt;
        1 1 1 1 1 1 1 1       24        24     8
       +-+-+-+-+-+-+-+-+---------------+---+--------+
       | |D| | |A| | | |group policy ID|VNI|reserved|
       +-+-+-+-+-+-+-+-+---------------+---+--------+


       Open vSwitch makes GBP fields and flags available through the following
       fields.  Only  packets that arrive over a VXLAN tunnel with the GBP ex‐
       tension enabled have these fields set. In other packets they  are  zero
       on receive and ignored on transmit.

       <b>VXLAN</b> <b>Group-Based</b> <b>Policy</b> <b>ID</b> <b>Field</b>
       Name:            <b>tun_gbp_id</b>
       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_TUN_GBP_ID</b> (38) since Open vSwitch 2.4

       For  a packet tunneled over VXLAN with the Group-Based Policy (GBP) ex‐
       tension, this field represents the GBP policy ID, as shown above.

       <b>VXLAN</b> <b>Group-Based</b> <b>Policy</b> <b>Flags</b> <b>Field</b>
       Name:            <b>tun_gbp_flags</b>
       Width:           8 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_TUN_GBP_FLAGS</b> (39) since Open vSwitch 2.4

       For a packet tunneled over VXLAN with the Group-Based Policy (GBP)  ex‐
       tension, this field represents the GBP policy flags, as shown above.

       The field has the format shown below:

           GBP Flags
        &lt;-------------&gt;
        1 1 1 1 1 1 1 1
       +-+-+-+-+-+-+-+-+
       | |D| | |A| | | |
       +-+-+-+-+-+-+-+-+


       Unlabeled bits are reserved and must be transmitted as 0. The VXLAN GBP
       draft defines the other bits’ meanings as:

              <b>D</b> (Don’t Learn)
                     When  set, this bit indicates that the egress tunnel end‐
                     point must not learn the source address of  the  encapsu‐
                     lated frame.

              <b>A</b> (Applied)
                     When  set,  indicates  that  the group policy has already
                     been applied to this packet. Devices must not apply poli‐
                     cies when the A bit is set.

   <b>ERSPAN</b> <b>Metadata</b> <b>Fields</b>
       These fields provide access to features in the ERSPAN tunneling  proto‐
       col [ERSPAN], which has two major versions: version 1 (aka type II) and
       version 2 (aka type III).

       Regardless of version, ERSPAN is encapsulated within a fixed 8-byte GRE
       header  that consists of a 4-byte GRE base header and a 4-byte sequence
       number. The ERSPAN version 1 header format is:

             GRE                ERSPAN v1            Ethernet
        &lt;------------&gt;   &lt;---------------------&gt;   &lt;----------&gt;
        16    16   32     4  18    10    12  20    48  48   16
       +---+------+---+ +---+---+-------+---+---+ +---+---+----+
       |...| type |seq| |ver|...|session|...|idx| |dst|src|type| ...
       +---+------+---+ +---+---+-------+---+---+ +---+---+----+
            0x88be        1      tun_id


       The ERSPAN version 2 header format is:

             GRE                         ERSPAN v2                      Ethernet
        &lt;------------&gt;   &lt;----------------------------------------&gt;   &lt;----------&gt;
        16    16   32     4  18    10       32     22   6    1   3    48  48   16
       +---+------+---+ +---+---+-------+---------+---+----+---+---+ +---+---+----+
       |...| type |seq| |ver|...|session|timestamp|...|hwid|dir|...| |dst|src|type| ...
       +---+------+---+ +---+---+-------+---------+---+----+---+---+ +---+---+----+
            0x22eb        2      tun_id                     0/1


       <b>ERSPAN</b> <b>Version</b> <b>Field</b>
       Name:            <b>tun_erspan_ver</b>
       Width:           8 bits (only the least-significant 4 bits may be nonzero)
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_ET_ERSPAN_VER</b> (12) since Open vSwitch 2.10

       ERSPAN version number: 1 for version 1, or 2 for version 2.

       <b>ERSPAN</b> <b>Index</b> <b>Field</b>
       Name:            <b>tun_erspan_idx</b>
       Width:           32 bits (only the least-significant 20 bits may be nonzero)
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_ET_ERSPAN_IDX</b> (11) since Open vSwitch 2.10

       This field is a 20-bit index/port number  associated  with  the  ERSPAN
       traffic’s  source  port  and  direction (ingress/egress). This field is
       platform dependent.

       <b>ERSPAN</b> <b>Direction</b> <b>Field</b>
       Name:            <b>tun_erspan_dir</b>
       Width:           8 bits (only the least-significant 1 bits may be nonzero)
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_ET_ERSPAN_DIR</b> (13) since Open vSwitch 2.10

       For ERSPAN v2, the mirrored traffic’s direction: 0 for ingress traffic,
       1 for egress traffic.

       <b>ERSPAN</b> <b>Hardware</b> <b>ID</b> <b>Field</b>
       Name:            <b>tun_erspan_hwid</b>
       Width:           8 bits (only the least-significant 6 bits may be nonzero)
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_ET_ERSPAN_HWID</b> (14) since Open vSwitch 2.10

       A 6-bit unique identifier of an ERSPAN v2 engine within a system.

   <b>GTP-U</b> <b>Metadata</b> <b>Fields</b>
       These fields provide access to set-up GPRS Tunnelling Protocol for User
       Plane (GTPv1-U), based on 3GPP TS 29.281. A GTP-U header has  the  fol‐
       lowing format:

          8      8       16    32
       +-----+--------+------+----+
       |flags|msg type|length|TEID| ...
       +-----+--------+------+----+


       The  flags and message type have the Open vSwitch GTP-U specific fields
       described below. Open vSwitch makes the TEID (Tunnel  Endpoint  Identi‐
       fier), which identifies a tunnel endpoint in the receiving GTP-U proto‐
       col entity, available via <b>tun_id</b>.

       <b>GTP-U</b> <b>Flags</b> <b>Field</b>
       Name:            <b>tun_gtpu_flags</b>
       Width:           8 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_ET_GTPU_FLAGS</b> (15) since Open vSwitch 2.13

       This field holds the 8-bit GTP-U flags, encoded as:

         GTP-U Tunnel Flags
        &lt;-------------------&gt;
           3    1   1  1 1 1
       +-------+--+---+-+-+--+
       |version|PT|rsv|E|S|PN|
       +-------+--+---+-+-+--+
           1        0


       The flags are:

              version
                     Used  to  determine  the  version  of the GTP-U protocol,
                     which should be set to 1.

              PT     Protocol type, used as a protocol  discriminator  between
                     GTP (1) and GTP’ (0).

              rsv    Reserved. Must be zero.

              E      If 1, indicates the presence of a meaningful value of the
                     Next Extension Header field.

              S      If 1, indicates the presence of a meaningful value of the
                     Sequence Number field.

              PN     If 1, indicates the presence of a meaningful value of the
                     N-PDU Number field.

       <b>GTP-U</b> <b>Message</b> <b>Type</b> <b>Field</b>
       Name:            <b>tun_gtpu_msgtype</b>
       Width:           8 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_ET_GTPU_MSGTYPE</b> (16) since Open vSwitch 2.13

       This  field  indicates  whether it’s a signalling message used for path
       management, or a user plane message which carries the original  packet.
       The  complete  range  of  message  types  can  be  referred to [3GPP TS
       29.281].

   <b>Geneve</b> <b>Fields</b>
       These fields provide access to additional features in the  Geneve  tun‐
       neling  protocol [Geneve]. Their names are somewhat generic in the hope
       that the same fields could be reused for other protocols in the future;
       for example, the NSH protocol [NSH] supports TLV options whose form  is
       identical to that for Geneve options.

       <b>Generic</b> <b>Tunnel</b> <b>Option</b> <b>0</b> <b>Field</b>
       Name:            <b>tun_metadata0</b>
       Width:           992 bits (124 bytes)
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_TUN_METADATA0</b> (40) since Open vSwitch 2.5

       The  above information specifically covers generic tunnel option 0, but
       Open vSwitch supports 64 options, numbered  0  through  63,  whose  NXM
       field numbers are 40 through 103.

       These  fields  provide OpenFlow access to the generic type-length-value
       options defined by the Geneve tunneling  protocol  or  other  protocols
       with  options  in  the same TLV format as Geneve options. Each of these
       options has the following wire format:

               header                 body
        &lt;-------------------&gt; &lt;------------------&gt;
         16    8    3    5    4×(length - 1) bytes
       +-----+----+---+------+--------------------+
       |class|type|res|length|       value        |
       +-----+----+---+------+--------------------+
                    0


       Taken together, the <b>class</b> and <b>type</b> in the option format mean that there
       are about 16 million distinct kinds of TLV options, too  many  to  give
       individual OXM code points. Thus, Open vSwitch requires the user to de‐
       fine  the  TLV  options of interest, by binding up to 64 TLV options to
       generic tunnel option NXM code points. Each option may have up  to  124
       bytes in its body, the maximum allowed by the TLV format, but bound op‐
       tions may total at most 252 bytes of body.

       Open  vSwitch  extensions  to the OpenFlow protocol bind TLV options to
       NXM code points. The <b>ovs-ofctl</b>(8) program offers one way to  use  these
       extensions,  e.g.  to  configure a mapping from a TLV option with <b>class</b>
       <b>0xffff</b>, <b>type</b> <b>0</b>, and a body length of 4 bytes:

       <b>ovs-ofctl</b> <b>add-tlv-map</b> <b>br0</b> <b>"{class=0xffff,type=0,len=4}-&gt;tun_metadata0"</b>


       Once a TLV option is properly bound, it can be  accessed  and  modified
       like any other field, e.g. to send packets that have value 1234 for the
       option described above to the controller:

       <b>ovs-ofctl</b> <b>add-flow</b> <b>br0</b> <b>tun_metadata0=1234,actions=controller</b>


       An option not received or not bound is matched as all zeros.

       <b>Tunnel</b> <b>Flags</b> <b>Field</b>
       Name:            <b>tun_flags</b>
       Width:           16 bits (only the least-significant 1 bits may be nonzero)
       Format:          tunnel flags
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_TUN_FLAGS</b> (104) since Open vSwitch 2.5

       Flags indicating various aspects of the tunnel encapsulation.

       Matches  on  this  field are most conveniently written in terms of sym‐
       bolic names (given in the diagram below), each preceded by either <b>+</b> for
       a flag that must be set, or <b>-</b> for a flag that must  be  unset,  without
       any  other  delimiters between the flags. Flags not mentioned are wild‐
       carded. For example, <b>tun_flags=+oam</b> matches only OAM  packets.  Matches
       can also be written as <u>flags</u><b>/</b><u>mask</u>, where <u>flags</u> and <u>mask</u> are 16-bit num‐
       bers in decimal or in hexadecimal prefixed by <b>0x</b>.

       Currently, only one flag is defined:

              <b>oam</b>    The tunnel protocol indicated that this is an OAM (Opera‐
                     tions and Management) control packet.

       The switch may reject matches against unknown flags.

       Newer  versions of Open vSwitch may introduce additional flags with new
       meanings. It is therefore not recommended to use an exact match on this
       field since the behavior of these new flags is unknown  and  should  be
       ignored.

       For non-tunneled packets, the value is 0.

<b>METADATA</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name            Bytes   Mask   RW?   Prereqs   NXM/OXM Support
       ──────────────  ──────  ─────  ────  ────────  ─────────────────────
       <b>in_port</b>         2       no     yes   none      OVS 1.1+
       <b>in_port_oxm</b>     4       no     yes   none      OF 1.2+ and OVS 1.7+
       <b>skb_priority</b>    4       no     no    none
       <b>pkt_mark</b>        4       yes    yes   none      OVS 2.0+
       <b>actset_output</b>   4       no     no    none      OF 1.3+ and OVS 2.4+
       <b>packet_type</b>     4       no     no    none      OF 1.5+ and OVS 2.8+

       These  fields  relate  to the origin or treatment of a packet, but they
       are not extracted from the packet data itself.

       <b>Ingress</b> <b>Port</b> <b>Field</b>
       Name:            <b>in_port</b>
       Width:           16 bits
       Format:          OpenFlow 1.0 port
       Masking:         not maskable
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             none
       NXM:             <b>NXM_OF_IN_PORT</b> (0) since Open vSwitch 1.1

       The OpenFlow port on which the packet being processed arrived. This  is
       a  16-bit field that holds an OpenFlow 1.0 port number. For receiving a
       packet, the only values that appear in this field are:

              1 through <b>0xfeff</b> (65,279), inclusive.
                     Conventional OpenFlow port numbers.

              <b>OFPP_LOCAL</b> (<b>0xfffe</b> or 65,534).
                     The ``local’’ port, which in Open vSwitch is always named
                     the same as the bridge itself. This represents a  connec‐
                     tion  between the switch and the local TCP/IP stack. This
                     port is where an IP address is most  commonly  configured
                     on an Open vSwitch switch.

                     OpenFlow  does not require a switch to have a local port,
                     but all existing versions of Open vSwitch have always in‐
                     cluded a local port. <b>Future</b> <b>Directions:</b>  Future  versions
                     of  Open vSwitch might be able to optionally omit the lo‐
                     cal port, if someone submits code  to  implement  such  a
                     feature.

              <b>OFPP_NONE</b> (OpenFlow 1.0) or <b>OFPP_ANY</b> (OpenFlow 1.1+) (<b>0xffff</b> or
              65,535).
              <b>OFPP_CONTROLLER</b> (<b>0xfffd</b> or 65,533).
                   When  a controller injects a packet into an OpenFlow switch
                   with a ``packet-out’’ request, it can specify one of  these
                   ingress ports to indicate that the packet was generated in‐
                   ternally rather than having been received on some port.

                   OpenFlow  1.0 specified <b>OFPP_NONE</b> for this purpose. Despite
                   that,  some  controllers  used  <b>OFPP_CONTROLLER</b>,  and  some
                   switches  only  accepted <b>OFPP_CONTROLLER</b>, so OpenFlow 1.0.2
                   required support for both ports.  OpenFlow  1.1  and  later
                   were  more  clearly  drafted to allow only <b>OFPP_CONTROLLER</b>.
                   For maximum compatibility, Open vSwitch allows  both  ports
                   with all OpenFlow versions.

       Values  not  mentioned above will never appear when receiving a packet,
       including the following notable values:

              0      Zero is not a valid OpenFlow port number.

              <b>OFPP_MAX</b> (<b>0xff00</b> or 65,280).
                     This value has only been clearly  specified  as  a  valid
                     port number as of OpenFlow 1.3.3. Before that, its status
                     was  unclear,  and  so  Open  vSwitch  has  never allowed
                     <b>OFPP_MAX</b> to be used as a port  number,  so  packets  will
                     never be received on this port. (Other OpenFlow switches,
                     of course, might use it.)

              <b>OFPP_UNSET</b> (<b>0xfff7</b> or 65,527)
              <b>OFPP_IN_PORT</b> (<b>0xfff8</b> or 65,528)
              <b>OFPP_TABLE</b> (<b>0xfff9</b> or 65,529)
              <b>OFPP_NORMAL</b> (<b>0xfffa</b> or 65,530)
              <b>OFPP_FLOOD</b> (<b>0xfffb</b> or 65,531)
              <b>OFPP_ALL</b> (<b>0xfffc</b> or 65,532)
                   These  port  numbers  are  used  only in output actions and
                   never appear as ingress ports.

                   Most of these port numbers were defined  in  OpenFlow  1.0,
                   but <b>OFPP_UNSET</b> was only introduced in OpenFlow 1.5.

       Values  that  will  never  appear  when receiving a packet may still be
       matched against in the flow table. There  are  still  circumstances  in
       which those flows can be matched:

              •      The  <b>resubmit</b> Open vSwitch extension action allows a flow
                     table lookup with an arbitrary ingress port.

              •      An action that modifies the ingress port field  (see  be‐
                     low),  such as e.g. <b>load</b> or <b>set_field</b>, followed by an ac‐
                     tion or instruction  that  performs  another  flow  table
                     lookup, such as <b>resubmit</b> or <b>goto_table</b>.

       This  field  is  heavily  used for matching in OpenFlow tables, but for
       packet egress, it has only very limited roles:

              •      OpenFlow requires suppressing output actions to  <b>in_port</b>.
                     That  is,  the  following two flows both drop all packets
                     that arrive on port 1:

                     <b>in_port=1,actions=1</b>
                     <b>in_port=1,actions=drop</b>


                     (This behavior is occasionally useful for flooding  to  a
                     subset of ports. Specifying <b>actions=1,2,3,4</b>, for example,
                     outputs  to  ports  1,  2, 3, and 4, omitting the ingress
                     port.)

              •      OpenFlow has a  special  port  <b>OFPP_IN_PORT</b>  (with  value
                     0xfff8) that outputs to the ingress port. For example, in
                     a  switch  that  has four ports numbered 1 through 4, <b>ac‐</b>
                     <b>tions=1,2,3,4,in_port</b> outputs to ports 1, 2,  3,  and  4,
                     including the ingress port.

       Because  the  ingress port field has so little influence on packet pro‐
       cessing, it does not ordinarily make sense to modify the  ingress  port
       field.  The  field  is writable only to support the occasional use case
       where the ingress port’s roles in packet egress, described  above,  be‐
       come  troublesome.  For  example, <b>actions=load:0-&gt;NXM_OF_IN_PORT[],out‐</b>
       <b>put:123</b> will output to port 123 regardless of  whether  it  is  in  the
       ingress  port.  If the ingress port is important, then one may save and
       restore it on the stack:

       <b>actions=push:NXM_OF_IN_PORT[],load:0-&gt;NXM_OF_IN_PORT[],output:123,pop:NXM_OF_IN_PORT[]</b>


       or, in Open vSwitch 2.7 or later, use the <b>clone</b> action to save and  re‐
       store it:

       <b>actions=clone(load:0-&gt;NXM_OF_IN_PORT[],output:123)</b>


       The  ability to modify the ingress port is an Open vSwitch extension to
       OpenFlow.

       <b>OXM</b> <b>Ingress</b> <b>Port</b> <b>Field</b>
       Name:            <b>in_port_oxm</b>
       Width:           32 bits
       Format:          OpenFlow 1.1+ port
       Masking:         not maskable
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_IN_PORT</b> (0) since OpenFlow 1.2 and Open vSwitch
                        1.7
       NXM:             none

       OpenFlow 1.1 and later use a 32-bit port number, so this field supplies
       a 32-bit view of the ingress port. Current  versions  of  Open  vSwitch
       support only a 16-bit range of ports:

              •      OpenFlow  1.0  ports  <b>0x0000</b> to <b>0xfeff</b>, inclusive, map to
                     OpenFlow 1.1 port numbers with the same values.

              •      OpenFlow 1.0 ports <b>0xff00</b> to <b>0xffff</b>,  inclusive,  map  to
                     OpenFlow 1.1 port numbers <b>0xffffff00</b> to <b>0xffffffff</b>.

              •      OpenFlow  1.1  ports  <b>0x0000ff00</b>  to  <b>0xfffffeff</b>  are not
                     mapped and not supported.

       <b>in_port</b> and <b>in_port_oxm</b> are two views of the same information,  so  all
       of  the comments on <b>in_port</b> apply to <b>in_port_oxm</b> too. Modifying <b>in_port</b>
       changes <b>in_port_oxm</b>, and vice versa.

       Setting <b>in_port_oxm</b> to an unsupported value yields  unspecified  behav‐
       ior.

       <b>Output</b> <b>Queue</b> <b>Field</b>
       Name:            <b>skb_priority</b>
       Width:           32 bits
       Format:          hexadecimal
       Masking:         not maskable
       Prerequisites:   none
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             none

       <b>Future</b> <b>Directions:</b> Open vSwitch implements the output queue as a field,
       but  does  not currently expose it through OXM or NXM for matching pur‐
       poses. If this turns out to be a useful feature,  it  could  be  imple‐
       mented  in  future versions. Only the <b>set_queue</b>, <b>enqueue</b>, and <b>pop_queue</b>
       actions currently influence the output queue.

       This field influences how packets in the flow will be queued, for qual‐
       ity of service (QoS) purposes, when they egress the switch.  Its  range
       of meaningful values, and their meanings, varies greatly from one Open‐
       Flow  implementation  to  another. Even within a single implementation,
       there is no guarantee that all OpenFlow ports have the same queues con‐
       figured or that all OpenFlow ports in an implementation can be  config‐
       ured the same way queue-wise.

       Configuring queues on OpenFlow is not well standardized. On Linux, Open
       vSwitch  supports  queue  configuration via OVSDB, specifically the <b>QoS</b>
       and <b>Queue</b> tables (see <b>ovs-vswitchd.conf.db(5)</b> for  details).  Ports  of
       Open  vSwitch  to  other  platforms  might  require queue configuration
       through some separate protocol (such as a CLI).  Even  on  Linux,  Open
       vSwitch  exposes  only  a  fraction  of  the  kernel’s queuing features
       through OVSDB, so advanced or unusual uses might require use  of  sepa‐
       rate  utilities  (e.g.  <b>tc</b>).  OpenFlow switches other than Open vSwitch
       might use OF-CONFIG or  any  of  the  configuration  methods  mentioned
       above.  Finally,  some  OpenFlow switches have a fixed number of fixed-
       function queues (e.g. eight queues with  strictly  defined  priorities)
       and others do not support any control over queuing.

       The only output queue that all OpenFlow implementations must support is
       zero, to identify a default queue, whose properties are implementation-
       defined. Outputting a packet to a queue that does not exist on the out‐
       put  port  yields  unpredictable  behavior: among the possibilities are
       that the packet might be dropped or transmitted with  a  very  high  or
       very low priority.

       OpenFlow  1.0  only allowed output queues to be specified as part of an
       <b>enqueue</b> action that specified both a queue and an output port. That is,
       OpenFlow 1.0 treats the queue as an argument to an  action,  not  as  a
       field.

       To increase flexibility, OpenFlow 1.1 added an action to set the output
       queue. This model was carried forward, without change, through OpenFlow
       1.5.

       Open  vSwitch implements the native queuing model of each OpenFlow ver‐
       sion it supports. Open vSwitch also includes an extension  for  setting
       the output queue as an action in OpenFlow 1.0.

       When  a  packet  ingresses into an OpenFlow switch, the output queue is
       ordinarily set to  0,  indicating  the  default  queue.  However,  Open
       vSwitch  supports  various  ways  to forward a packet from one OpenFlow
       switch to another within a single host. In these  cases,  Open  vSwitch
       maintains the output queue across the forwarding step. For example:

              •      A  hop  across an Open vSwitch ``patch port’’ (which does
                     not actually involve queuing) preserves the output queue.

              •      When a flow sets the output  queue  then  outputs  to  an
                     OpenFlow  tunnel  port,  the  encapsulation preserves the
                     output queue. If the kernel TCP/IP stack routes  the  en‐
                     capsulated  packet directly to a physical interface, then
                     that output honors the output  queue.  Alternatively,  if
                     the kernel routes the encapsulated packet to another Open
                     vSwitch  bridge, then the output queue set previously be‐
                     comes the initial output queue on ingress to  the  second
                     bridge  and  will thus be used for further output actions
                     (unless overridden by a new ``set queue’’ action).

                     (This description reflects the current behavior  of  Open
                     vSwitch  on Linux. This behavior relies on details of the
                     Linux TCP/IP stack. It could be difficult to  make  ports
                     to other operating systems behave the same way.)

       <b>Packet</b> <b>Mark</b> <b>Field</b>
       Name:            <b>pkt_mark</b>
       Width:           32 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_PKT_MARK</b> (33) since Open vSwitch 2.0

       Packet  mark  comes to Open vSwitch from the Linux kernel, in which the
       <b>sk_buff</b> data structure that represents a packet contains a 32-bit  mem‐
       ber  named  <b>skb_mark</b>.  The  value of <b>skb_mark</b> propagates along with the
       packet it accompanies wherever the packet goes in the kernel. It has no
       predefined semantics but various kernel-user  interfaces  can  set  and
       match  on  it,  which  makes it suitable for ``marking’’ packets at one
       point in their handling and then acting on the mark later.  With  <b>ipta‐</b>
       <b>bles</b>,  for  example, one can mark some traffic specially at ingress and
       then handle that traffic differently at  egress  based  on  the  marked
       value.

       Packet  mark  is an attempt at a generalization of the <b>skb_mark</b> concept
       beyond Linux, at least through more generic naming. Like  <b>skb_priority</b>,
       packet  mark is preserved across forwarding steps within a machine. Un‐
       like <b>skb_priority</b>, packet mark has no direct effect on packet  forward‐
       ing:  the  value  set  in packet mark does not matter unless some later
       OpenFlow table or switch matches on packet mark, or unless  the  packet
       passes  through some other kernel subsystem that has been configured to
       interpret packet mark in specific ways, e.g. through <b>iptables</b>  configu‐
       ration mentioned above.

       Preserving packet mark across kernel forwarding steps relies heavily on
       kernel  support,  which  ports  to  non-Linux operating systems may not
       have. Regardless of operating system  support,  Open  vSwitch  supports
       packet mark within a single bridge and across patch ports.

       The  value  of  packet mark when a packet ingresses into the first Open
       vSwich bridge is typically zero, but it could be nonzero if  its  value
       was previously set by some kernel subsystem.

       <b>Action</b> <b>Set</b> <b>Output</b> <b>Port</b> <b>Field</b>
       Name:            <b>actset_output</b>
       Width:           32 bits
       Format:          OpenFlow 1.1+ port
       Masking:         not maskable
       Prerequisites:   none
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>ONFOXM_ET_ACTSET_OUTPUT</b>  (43)  since  OpenFlow 1.3 and
                        Open  vSwitch  2.4;  <b>OXM_OF_ACTSET_OUTPUT</b>  (43)  since
                        OpenFlow 1.5 and Open vSwitch 2.4
       NXM:             none

       Holds  the  output port currently in the OpenFlow action set (i.e. from
       an <b>output</b> action within a <b>write_actions</b> instruction). Its value  is  an
       OpenFlow port number. If there is no output port in the OpenFlow action
       set,  or  if  the output port will be ignored (e.g. because there is an
       output group in the OpenFlow  action  set),  then  the  value  will  be
       <b>OFPP_UNSET</b>.

       Open  vSwitch  allows any table to match this field. OpenFlow, however,
       only requires this field to be matchable from within an OpenFlow egress
       table (a feature that Open vSwitch does not yet implement).

       <b>Packet</b> <b>Type</b> <b>Field</b>
       Name:            <b>packet_type</b>
       Width:           32 bits
       Format:          packet type
       Masking:         not maskable
       Prerequisites:   none
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_PACKET_TYPE</b> (44) since OpenFlow  1.5  and  Open
                        vSwitch 2.8
       NXM:             none

       The type of the packet in the format specified in OpenFlow 1.5:

        Packet type
        &lt;---------&gt;
        16    16
       +---+-------+
       |ns |ns_type| ...
       +---+-------+


       The  upper 16 bits, <u>ns</u>, are a namespace. The meaning of <u>ns</u><b>_</b><u>type</u> depends
       on the namespace. The packet type field is specified and  displayed  in
       the format <b>(</b><u>ns</u><b>,</b><u>ns</u><b>_</b><u>type</u><b>)</b>.

       Open  vSwitch  currently supports the following classes of packet types
       for matching:

              <b>(0,0)</b>  Ethernet.

              <b>(1,</b><u>ethertype</u><b>)</b>
                     The specified <u>ethertype</u>. Open vSwitch can forward packets
                     with any <u>ethertype</u>, but it can only match on and  process
                     data fields for the following supported packet types:

                     <b>(1,0x800)</b>
                            IPv4

                     <b>(1,0x806)</b>
                            ARP

                     <b>(1,0x86dd)</b>
                            IPv6

                     <b>(1,0x8847)</b>
                            MPLS

                     <b>(1,0x8848)</b>
                            MPLS multicast

                     <b>(1,0x8035)</b>
                            RARP

                     <b>(1,0x894f)</b>
                            NSH

       Consider  the  distinction  between  a  packet  with <b>packet_type=(0,0),</b>
       <b>dl_type=0x800</b> and one with <b>packet_type=(1,0x800)</b>. The former is an Eth‐
       ernet frame that contains an IPv4 packet, like this:

          Ethernet            IPv4
        &lt;-----------&gt;   &lt;---------------&gt;
        48  48   16           8   32  32
       +---+---+-----+ +---+-----+---+---+
       |dst|src|type | |...|proto|src|dst| ...
       +---+---+-----+ +---+-----+---+---+
                0x800


       The latter is an IPv4 packet not encapsulated inside any  outer  frame,
       like this:

              IPv4
        &lt;---------------&gt;
              8   32  32
       +---+-----+---+---+
       |...|proto|src|dst| ...
       +---+-----+---+---+


       Matching  on  <b>packet_type</b>  is  a pre-requisite for matching on any data
       field, but for backward compatibility, when a match on a data field  is
       present  without  a  <b>packet_type</b>  match,  Open vSwitch acts as though a
       match on <b>(0,0)</b> (Ethernet)  had  been  supplied.  Similarly,  when  Open
       vSwitch  sends  flow match information to a controller, e.g. in a reply
       to a request to dump the flow table, Open  vSwitch  omits  a  match  on
       packet type (0,0) if it would be implied by a data field match.

<b>CONNECTION</b> <b>TRACKING</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name          Bytes   Mask   RW?   Prereqs   NXM/OXM Support
       ────────────  ──────  ─────  ────  ────────  ────────────────
       <b>ct_state</b>      4       yes    no    none      OVS 2.5+
       <b>ct_zone</b>       2       no     no    none      OVS 2.5+
       <b>ct_mark</b>       4       yes    yes   none      OVS 2.5+
       <b>ct_label</b>      16      yes    yes   none      OVS 2.5+
       <b>ct_nw_src</b>     4       yes    no    CT        OVS 2.8+
       <b>ct_nw_dst</b>     4       yes    no    CT        OVS 2.8+
       <b>ct_ipv6_src</b>   16      yes    no    CT        OVS 2.8+
       <b>ct_ipv6_dst</b>   16      yes    no    CT        OVS 2.8+
       <b>ct_nw_proto</b>   1       no     no    CT        OVS 2.8+
       <b>ct_tp_src</b>     2       yes    no    CT        OVS 2.8+
       <b>ct_tp_dst</b>     2       yes    no    CT        OVS 2.8+

       Open  vSwitch  supports  ``connection tracking,’’ which allows bidirec‐
       tional streams of packets to be statefully  grouped  into  connections.
       Open  vSwitch connection tracking, for example, identifies the patterns
       of TCP packets that indicates a successfully initiated  connection,  as
       well  as those that indicate that a connection has been torn down. Open
       vSwitch connection tracking can also identify related connections, such
       as FTP data connections spawned from FTP control connections.

       An individual packet passing through the pipeline may be in one of  two
       states,  ``untracked’’  or  ``tracked,’’ which may be distinguished via
       the ``trk’’ flag in <b>ct_state</b>. A packet is <u>untracked</u> at the beginning of
       the Open vSwitch pipeline and  continues  to  be  untracked  until  the
       pipeline  invokes the <b>ct</b> action. The connection tracking fields are all
       zeroes in an untracked packet. When a flow in the Open vSwitch pipeline
       invokes the <b>ct</b> action, the action initializes the  connection  tracking
       fields and the packet becomes <u>tracked</u> for the remainder of its process‐
       ing.

       The  connection  tracker  stores connection state in an internal table,
       but it only adds a new entry to this table when a <b>ct</b> action for  a  new
       connection  invokes  <b>ct</b>  with the <b>commit</b> parameter. For a given connec‐
       tion, when a pipeline has executed <b>ct</b>, but not  yet  with  <b>commit</b>,  the
       connection  is said to be <u>uncommitted</u>. State for an uncommitted connec‐
       tion is ephemeral and does not persist past the end of the pipeline, so
       some features are only available to committed connections. A connection
       would typically be left uncommitted as a way to drop its packets.

       Connection tracking is an Open  vSwitch  extension  to  OpenFlow.  Open
       vSwitch  2.5  added the initial support for connection tracking. Subse‐
       quent versions of Open vSwitch added many refinements and extensions to
       the initial support. Many of these  capabilities  depend  on  the  Open
       vSwitch datapath rather than simply the userspace version. The <b>capabil‐</b>
       <b>ities</b>  column  in  the <b>Datapath</b> table (see <b>ovs-vswitchd.conf.db</b>(5)) re‐
       ports the detailed capabilities of a particular Open vSwitch datapath.

       <b>Connection</b> <b>Tracking</b> <b>State</b> <b>Field</b>
       Name:            <b>ct_state</b>
       Width:           32 bits
       Format:          ct state
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_STATE</b> (105) since Open vSwitch 2.5

       This field holds several flags that can be used to determine the  state
       of the connection to which the packet belongs.

       Matches  on  this  field are most conveniently written in terms of sym‐
       bolic names (listed below), each preceded by either <b>+</b> for a  flag  that
       must  be set, or <b>-</b> for a flag that must be unset, without any other de‐
       limiters between the flags. Flags not mentioned are wildcarded. For ex‐
       ample, <b>tcp,ct_state=+trk-new</b> matches TCP packets  that  have  been  run
       through  the  connection tracker and do not establish a new connection.
       Matches can also be written as <u>flags</u><b>/</b><u>mask</u>, where  <u>flags</u>  and  <u>mask</u>  are
       32-bit numbers in decimal or in hexadecimal prefixed by <b>0x</b>.

       The following flags are defined:

              <b>new</b> (0x01)
                     A new connection. Set to 1 if this is an uncommitted con‐
                     nection.

              <b>est</b> (0x02)
                     Part  of an existing connection. Set to 1 if packets of a
                     committed connection have been  seen  by  conntrack  from
                     both directions.

              <b>rel</b> (0x04)
                     Related  to an existing connection, e.g. an ICMP ``desti‐
                     nation unreachable’’ message or an FTP data  connections.
                     This  flag will only be 1 if the connection to which this
                     one is related is committed.

                     Connections identified as <b>rel</b> are separate from the orig‐
                     inating connection and must be committed separately.  All
                     packets  for  a related connection will have the <b>rel</b> flag
                     set, not just the initial packet.

              <b>rpl</b> (0x08)
                     This packet is in the reply direction, meaning that it is
                     in the opposite direction from the packet that  initiated
                     the  connection.  This flag will only be 1 if the connec‐
                     tion is committed.

              <b>inv</b> (0x10)
                     The state is invalid, meaning that the connection tracker
                     couldn’t identify the connection. This flag is  a  catch-
                     all  for  problems  in  the  connection or the connection
                     tracker, such as:

                     •      L3/L4 protocol handler is not  loaded/unavailable.
                            With the Linux kernel datapath, this may mean that
                            the <b>nf_conntrack_ipv4</b> or <b>nf_conntrack_ipv6</b> modules
                            are not loaded.

                     •      L3/L4  protocol handler determines that the packet
                            is malformed.

                     •      Packets are unexpected length for protocol.

              <b>trk</b> (0x20)
                     This packet is tracked, meaning that  it  has  previously
                     traversed  the  connection  tracker.  If this flag is not
                     set, then no other flags will be set.  If  this  flag  is
                     set,  then the packet is tracked and other flags may also
                     be set.

              <b>snat</b> (0x40)
                     This packet was transformed by source address/port trans‐
                     lation by a preceding <b>ct</b> action. Open vSwitch  2.6  added
                     this flag.

              <b>dnat</b> (0x80)
                     This  packet  was transformed by destination address/port
                     translation by a preceding <b>ct</b> action.  Open  vSwitch  2.6
                     added this flag.

       There  are  additional constraints on these flags, listed in decreasing
       order of precedence below:

              1.  If <b>trk</b> is unset, no other flags are set.

              2.  If <b>trk</b> is set, one or more other flags may be set.

              3.  If <b>inv</b> is set, only the <b>trk</b> flag is also set.

              4.  <b>new</b> and <b>est</b> are mutually exclusive.

              5.  <b>new</b> and <b>rpl</b> are mutually exclusive.

              6.  <b>rel</b> may be set in conjunction with any other flags.

       Future versions of Open vSwitch may define new flags.

       <b>Connection</b> <b>Tracking</b> <b>Zone</b> <b>Field</b>
       Name:            <b>ct_zone</b>
       Width:           16 bits
       Format:          hexadecimal
       Masking:         not maskable
       Prerequisites:   none
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_ZONE</b> (106) since Open vSwitch 2.5

       A connection tracking zone, the zone value passed to the most recent <b>ct</b>
       action. Each zone is an independent  connection  tracking  context,  so
       tracking the same packet in multiple contexts requires using the <b>ct</b> ac‐
       tion multiple times.

       <b>Connection</b> <b>Tracking</b> <b>Mark</b> <b>Field</b>
       Name:            <b>ct_mark</b>
       Width:           32 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_MARK</b> (107) since Open vSwitch 2.5

       The  metadata  committed, by an action within the <b>exec</b> parameter to the
       <b>ct</b> action, to the connection to which the current packet belongs.

       <b>Connection</b> <b>Tracking</b> <b>Label</b> <b>Field</b>
       Name:            <b>ct_label</b>
       Width:           128 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_LABEL</b> (108) since Open vSwitch 2.5

       The label committed, by an action within the <b>exec</b> parameter to  the  <b>ct</b>
       action, to the connection to which the current packet belongs.

       Open vSwitch 2.8 introduced the matching support for connection tracker
       original direction 5-tuple fields.

       For non-committed non-related connections the conntrack original direc‐
       tion  tuple  fields  always  have  the same values as the corresponding
       headers in the packet itself. For any other packets of a committed con‐
       nection the conntrack original direction tuple fields reflect the  val‐
       ues from that initial non-committed non-related packet, and thus may be
       different  from the actual packet headers, as the actual packet headers
       may be in reverse direction (for reply  packets),  transformed  by  NAT
       (when  <b>nat</b>  option  was  applied to the connection), or be of different
       protocol (i.e., when an ICMP response is sent to  an  UDP  packet).  In
       case of related connections, e.g., an FTP data connection, the original
       direction tuple contains the original direction headers from the parent
       connection, e.g., an FTP control connection.

       The  following  fields  are  populated  by the <b>ct</b> action, and require a
       match to a valid connection tracking state as a prerequisite, in  addi‐
       tion  to  the  IP or IPv6 ethertype match. Examples of valid connection
       tracking   state   matches   include   <b>ct_state=+new</b>,    <b>ct_state=+est</b>,
       <b>ct_state=+rel</b>, and <b>ct_state=+trk-inv</b>.

       <b>Connection</b> <b>Tracking</b> <b>Original</b> <b>Direction</b> <b>IPv4</b> <b>Source</b> <b>Address</b> <b>Field</b>
       Name:            <b>ct_nw_src</b>
       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks
       Prerequisites:   CT
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_NW_SRC</b> (120) since Open vSwitch 2.8

       Matches IPv4 conntrack original direction tuple source address. See the
       paragraphs  above for general description to the conntrack original di‐
       rection tuple. Introduced in Open vSwitch 2.8.

       <b>Connection</b> <b>Tracking</b> <b>Original</b> <b>Direction</b> <b>IPv4</b> <b>Destination</b> <b>Address</b> <b>Field</b>
       Name:            <b>ct_nw_dst</b>
       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks
       Prerequisites:   CT
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_NW_DST</b> (121) since Open vSwitch 2.8

       Matches IPv4 conntrack original direction  tuple  destination  address.
       See the paragraphs above for general description to the conntrack orig‐
       inal direction tuple. Introduced in Open vSwitch 2.8.

       <b>Connection</b> <b>Tracking</b> <b>Original</b> <b>Direction</b> <b>IPv6</b> <b>Source</b> <b>Address</b> <b>Field</b>
       Name:            <b>ct_ipv6_src</b>
       Width:           128 bits
       Format:          IPv6
       Masking:         arbitrary bitwise masks
       Prerequisites:   CT
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_IPV6_SRC</b> (122) since Open vSwitch 2.8

       Matches IPv6 conntrack original direction tuple source address. See the
       paragraphs  above for general description to the conntrack original di‐
       rection tuple. Introduced in Open vSwitch 2.8.

       <b>Connection</b> <b>Tracking</b> <b>Original</b> <b>Direction</b> <b>IPv6</b> <b>Destination</b> <b>Address</b> <b>Field</b>
       Name:            <b>ct_ipv6_dst</b>
       Width:           128 bits
       Format:          IPv6
       Masking:         arbitrary bitwise masks
       Prerequisites:   CT
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_IPV6_DST</b> (123) since Open vSwitch 2.8

       Matches IPv6 conntrack original direction  tuple  destination  address.
       See the paragraphs above for general description to the conntrack orig‐
       inal direction tuple. Introduced in Open vSwitch 2.8.

       <b>Connection</b> <b>Tracking</b> <b>Original</b> <b>Direction</b> <b>IP</b> <b>Protocol</b> <b>Field</b>
       Name:            <b>ct_nw_proto</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   CT
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_NW_PROTO</b> (119) since Open vSwitch 2.8

       Matches  conntrack  original direction tuple IP protocol type, which is
       specified as a decimal number between 0 and 255, inclusive (e.g.  1  to
       match ICMP packets or 6 to match TCP packets). In case of, for example,
       an  ICMP  response  to an UDP packet, this may be different from the IP
       protocol type of the packet itself. See the paragraphs above  for  gen‐
       eral  description to the conntrack original direction tuple. Introduced
       in Open vSwitch 2.8.

       <b>Connection</b> <b>Tracking</b> <b>Original</b>  <b>Direction</b>  <b>Transport</b>  <b>Layer</b>  <b>Source</b>  <b>Port</b>
       <b>Field</b>
       Name:            <b>ct_tp_src</b>
       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   CT
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_TP_SRC</b> (124) since Open vSwitch 2.8

       Bitwise  match  on  the  conntrack  original  direction tuple transport
       source, when <b>MFF_CT_NW_PROTO</b> has value 6 for TCP, 17 for  UDP,  or  132
       for  SCTP. When <b>MFF_CT_NW_PROTO</b> has value 1 for ICMP, or 58 for ICMPv6,
       the lower 8 bits of <b>MFF_CT_TP_SRC</b> matches the conntrack original direc‐
       tion ICMP type. See the paragraphs above for general description to the
       conntrack original direction tuple. Introduced in Open vSwitch 2.8.

       <b>Connection</b> <b>Tracking</b> <b>Original</b>  <b>Direction</b>  <b>Transport</b>  <b>Layer</b>  <b>Source</b>  <b>Port</b>
       <b>Field</b>
       Name:            <b>ct_tp_dst</b>
       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   CT
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_TP_DST</b> (125) since Open vSwitch 2.8

       Bitwise  match on the conntrack original direction tuple transport des‐
       tination port, when <b>MFF_CT_NW_PROTO</b> has value 6 for TCP, 17 for UDP, or
       132 for SCTP. When <b>MFF_CT_NW_PROTO</b> has value 1  for  ICMP,  or  58  for
       ICMPv6,  the lower 8 bits of <b>MFF_CT_TP_DST</b> matches the conntrack origi‐
       nal direction ICMP code. See the paragraphs above for general  descrip‐
       tion  to  the  conntrack  original  direction tuple. Introduced in Open
       vSwitch 2.8.

<b>REGISTER</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name       Bytes   Mask   RW?   Prereqs   NXM/OXM Support
       ─────────  ──────  ─────  ────  ────────  ─────────────────────
       <b>metadata</b>   8       yes    yes   none      OF 1.2+ and OVS 1.8+
       <b>reg0</b>       4       yes    yes   none      OVS 1.1+
       <b>reg1</b>       4       yes    yes   none      OVS 1.1+
       <b>reg2</b>       4       yes    yes   none      OVS 1.1+
       <b>reg3</b>       4       yes    yes   none      OVS 1.1+
       <b>reg4</b>       4       yes    yes   none      OVS 1.3+
       <b>reg5</b>       4       yes    yes   none      OVS 1.7+
       <b>reg6</b>       4       yes    yes   none      OVS 1.7+
       <b>reg7</b>       4       yes    yes   none      OVS 1.7+
       <b>reg8</b>       4       yes    yes   none      OVS 2.6+
       <b>reg9</b>       4       yes    yes   none      OVS 2.6+
       <b>reg10</b>      4       yes    yes   none      OVS 2.6+
       <b>reg11</b>      4       yes    yes   none      OVS 2.6+
       <b>reg12</b>      4       yes    yes   none      OVS 2.6+
       <b>reg13</b>      4       yes    yes   none      OVS 2.6+
       <b>reg14</b>      4       yes    yes   none      OVS 2.6+
       <b>reg15</b>      4       yes    yes   none      OVS 2.6+
       <b>xreg0</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xreg1</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xreg2</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xreg3</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xreg4</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xreg5</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xreg6</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xreg7</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xxreg0</b>     16      yes    yes   none      OVS 2.6+
       <b>xxreg1</b>     16      yes    yes   none      OVS 2.6+
       <b>xxreg2</b>     16      yes    yes   none      OVS 2.6+
       <b>xxreg3</b>     16      yes    yes   none      OVS 2.6+

       These fields give an OpenFlow switch space for temporary storage  while
       the  pipeline is running. Whereas metadata fields can have a meaningful
       initial  value  and  can  persist  across  some  hops  across  OpenFlow
       switches,  registers are always initially 0 and their values never per‐
       sist across inter-switch hops (not even across patch ports).

       <b>OpenFlow</b> <b>Metadata</b> <b>Field</b>
       Name:            <b>metadata</b>
       Width:           64 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    yes
       OXM:             <b>OXM_OF_METADATA</b>  (2)  since  OpenFlow  1.2  and   Open
                        vSwitch 1.8
       NXM:             none

       This  field  is the oldest standardized OpenFlow register field, intro‐
       duced in OpenFlow 1.1. It was introduced to model the limited number of
       user-defined bits that some ASIC-based switches can carry through their
       pipelines. Because of hardware limitations, OpenFlow allows switches to
       support writing and masking only an  implementation-defined  subset  of
       bits, even no bits at all. The Open vSwitch software switch always sup‐
       ports  all 64 bits, but of course an Open vSwitch port to an ASIC would
       have the same restriction as the ASIC itself.

       This field has an OXM code point, but OpenFlow 1.4 and earlier allow it
       to be modified only with a specialized instruction, not with  a  ``set-
       field’’  action.  OpenFlow  1.5  removes this restriction. Open vSwitch
       does not enforce this restriction, regardless of OpenFlow version.

       <b>Register</b> <b>0</b> <b>Field</b>
       Name:            <b>reg0</b>
       Width:           32 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_REG0</b> (0) since Open vSwitch 1.1

       This is the first of several Open vSwitch registers, all of which  have
       the same properties. Open vSwitch 1.1 introduced registers 0, 1, 2, and
       3,  version 1.3 added register 4, version 1.7 added registers 5, 6, and
       7, and version 2.6 added registers 8 through 15.

       <b>Extended</b> <b>Register</b> <b>0</b> <b>Field</b>
       Name:            <b>xreg0</b>
       Width:           64 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_PKT_REG0</b>  (0)  since  OpenFlow  1.3  and   Open
                        vSwitch 2.4
       NXM:             none

       This is the first of the registers introduced in OpenFlow 1.5. OpenFlow
       1.5  calls these fields just the ``packet registers,’’ but Open vSwitch
       already had 32-bit registers by that name, so  Open  vSwitch  uses  the
       name  ``extended  registers’’  in  an  attempt to reduce confusion. The
       standard allows for up to 128 registers, each 64 bits  wide,  but  Open
       vSwitch  only  implements  4 (in versions 2.4 and 2.5) or 8 (in version
       2.6 and later).

       Each of the 64-bit extended registers overlays two of the 32-bit regis‐
       ters: <b>xreg0</b> overlays <b>reg0</b> and <b>reg1</b>, with <b>reg0</b> supplying  the  most-sig‐
       nificant bits of <b>xreg0</b> and <b>reg1</b> the least-significant. Similarly, <b>xreg1</b>
       overlays <b>reg2</b> and <b>reg3</b>, and so on.

       The  OpenFlow specification says, ``In most cases, the packet registers
       can not be matched in tables, i.e. they usually can not be used in  the
       flow  entry  match  structure’’  [OpenFlow  1.5, section 7.2.3.10], but
       there is no reason for a software switch to impose such a  restriction,
       and Open vSwitch does not.

       <b>Double-Extended</b> <b>Register</b> <b>0</b> <b>Field</b>
       Name:            <b>xxreg0</b>
       Width:           128 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_XXREG0</b> (111) since Open vSwitch 2.6

       This  is  the  first of the double-extended registers introduce in Open
       vSwitch 2.6. Each of the 128-bit extended registers  overlays  four  of
       the 32-bit registers: <b>xxreg0</b> overlays <b>reg0</b> through <b>reg3</b>, with <b>reg0</b> sup‐
       plying  the most-significant bits of <b>xxreg0</b> and <b>reg3</b> the least-signifi‐
       cant. <b>xxreg1</b> similarly overlays <b>reg4</b> through <b>reg7</b>, and so on.

<b>LAYER</b> <b>2</b> <b>(ETHERNET)</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name                   Bytes   Mask   RW?   Prereqs    NXM/OXM Support
       ─────────────────────  ──────  ─────  ────  ─────────  ─────────────────────
       <b>eth_src</b> aka <b>dl_src</b>     6       yes    yes   Ethernet   OF 1.2+ and OVS 1.1+
       <b>eth_dst</b> aka <b>dl_dst</b>     6       yes    yes   Ethernet   OF 1.2+ and OVS 1.1+
       <b>eth_type</b> aka <b>dl_type</b>   2       no     no    Ethernet   OF 1.2+ and OVS 1.1+

       Ethernet is the only layer-2 protocol that Open  vSwitch  supports.  As
       with  most software, Open vSwitch and OpenFlow regard an Ethernet frame
       to begin with the 14-byte header and end with the  final  byte  of  the
       payload;  that  is,  the frame check sequence is not considered part of
       the frame.

       <b>Ethernet</b> <b>Source</b> <b>Field</b>
       Name:            <b>eth_src</b> (aka <b>dl_src</b>)
       Width:           48 bits
       Format:          Ethernet
       Masking:         arbitrary bitwise masks
       Prerequisites:   Ethernet
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes
       OXM:             <b>OXM_OF_ETH_SRC</b> (4) since OpenFlow 1.2 and Open vSwitch
                        1.7
       NXM:             <b>NXM_OF_ETH_SRC</b> (2) since Open vSwitch 1.1

       The Ethernet source address:

          Ethernet
        &lt;----------&gt;
        48  48   16
       +---+---+----+
       |dst|src|type| ...
       +---+---+----+


       <b>Ethernet</b> <b>Destination</b> <b>Field</b>
       Name:            <b>eth_dst</b> (aka <b>dl_dst</b>)
       Width:           48 bits
       Format:          Ethernet
       Masking:         arbitrary bitwise masks
       Prerequisites:   Ethernet
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes
       OXM:             <b>OXM_OF_ETH_DST</b> (3) since OpenFlow 1.2 and Open vSwitch
                        1.7
       NXM:             <b>NXM_OF_ETH_DST</b> (1) since Open vSwitch 1.1

       The Ethernet destination address:

          Ethernet
        &lt;----------&gt;
        48  48   16
       +---+---+----+
       |dst|src|type| ...
       +---+---+----+


       Open vSwitch 1.8 and later support arbitrary masks  for  source  and/or
       destination. Earlier versions only support masking the destination with
       the following masks:

              <b>01:00:00:00:00:00</b>
                     Match      only      the     multicast     bit.     Thus,
                     <b>dl_dst=01:00:00:00:00:00/01:00:00:00:00:00</b>  matches   all
                     multicast  (including  broadcast)  Ethernet  packets, and
                     <b>dl_dst=00:00:00:00:00:00/01:00:00:00:00:00</b>  matches   all
                     unicast Ethernet packets.

              <b>fe:ff:ff:ff:ff:ff</b>
                     Match all bits except the multicast bit. This is probably
                     not useful.

              <b>ff:ff:ff:ff:ff:ff</b>
                     Exact match (equivalent to omitting the mask).

              <b>00:00:00:00:00:00</b>
                     Wildcard all bits (equivalent to <b>dl_dst=*</b>).

       <b>Ethernet</b> <b>Type</b> <b>Field</b>
       Name:            <b>eth_type</b> (aka <b>dl_type</b>)
       Width:           16 bits
       Format:          hexadecimal
       Masking:         not maskable
       Prerequisites:   Ethernet
       Access:          read-only
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_ETH_TYPE</b>   (5)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_ETH_TYPE</b> (3) since Open vSwitch 1.1

       The most commonly seen Ethernet frames today use a format called ``Eth‐
       ernet II,’’ in which the last two bytes of the Ethernet header  specify
       the  Ethertype. For such a frame, this field is copied from those bytes
       of the header, like so:

             Ethernet
        &lt;----------------&gt;
        48  48      16
       +---+---+----------+
       |dst|src|   type   | ...
       +---+---+----------+
                ≥0x600


       Every Ethernet type has a value 0x600 (1,536) or greater. When the last
       two bytes of the Ethernet header have a value too small to be an Ether‐
       net type, then the value found there is the total length of  the  frame
       in  bytes, excluding the Ethernet header. An 802.2 LLC header typically
       follows the Ethernet header. OpenFlow and Open vSwitch only support LLC
       headers with DSAP and SSAP <b>0xaa</b> and control byte <b>0x03</b>,  which  indicate
       that  a  SNAP header follows the LLC header. In turn, OpenFlow and Open
       vSwitch only support a SNAP header with organization <b>0x000000</b>. In  such
       a  case,  this  field is copied from the type field in the SNAP header,
       like this:

           Ethernet           LLC                SNAP
        &lt;------------&gt;   &lt;------------&gt;   &lt;-----------------&gt;
        48  48    16      8    8    8        24        16
       +---+---+------+ +----+----+----+ +--------+----------+
       |dst|src| type | |DSAP|SSAP|cntl| |  org   |   type   | ...
       +---+---+------+ +----+----+----+ +--------+----------+
                &lt;0x600   0xaa 0xaa 0x03   0x000000 ≥0x600


       When an 802.1Q header is inserted after the Ethernet source and  desti‐
       nation,  this  field  is populated with the encapsulated Ethertype, not
       the 802.1Q Ethertype. With an Ethernet II inner frame, the result looks
       like this:

        Ethernet     802.1Q     Ethertype
        &lt;------&gt;   &lt;--------&gt;   &lt;--------&gt;
         48  48      16   16        16
       +----+---+ +------+---+ +----------+
       |dst |src| | TPID |TCI| |   type   | ...
       +----+---+ +------+---+ +----------+
                   0x8100       ≥0x600


       LLC and SNAP encapsulation look like this with an 802.1Q header:

        Ethernet     802.1Q     Ethertype        LLC                SNAP
        &lt;------&gt;   &lt;--------&gt;   &lt;-------&gt;   &lt;------------&gt;   &lt;-----------------&gt;
         48  48      16   16       16        8    8    8        24        16
       +----+---+ +------+---+ +---------+ +----+----+----+ +--------+----------+
       |dst |src| | TPID |TCI| |  type   | |DSAP|SSAP|cntl| |  org   |   type   | ...
       +----+---+ +------+---+ +---------+ +----+----+----+ +--------+----------+
                   0x8100        &lt;0x600     0xaa 0xaa 0x03   0x000000 ≥0x600


       When a packet doesn’t match any of the header formats described  above,
       Open    vSwitch    and    OpenFlow    set    this    field   to   <b>0x5ff</b>
       (<b>OFP_DL_TYPE_NOT_ETH_TYPE</b>).

<b>VLAN</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name          Bytes             Mask   RW?   Prereqs    NXM/OXM Support
       ────────────  ────────────────  ─────  ────  ─────────  ─────────────────────
       <b>dl_vlan</b>       2 (low 12 bits)   no     yes   Ethernet
       <b>dl_vlan_pcp</b>   1 (low 3 bits)    no     yes   Ethernet
       <b>vlan_vid</b>      2 (low 12 bits)   yes    yes   Ethernet   OF 1.2+ and OVS 1.7+
       <b>vlan_pcp</b>      1 (low 3 bits)    no     yes   VLAN VID   OF 1.2+ and OVS 1.7+
       <b>vlan_tci</b>      2                 yes    yes   Ethernet   OVS 1.1+

       The 802.1Q VLAN header causes more trouble than any other  4  bytes  in
       networking.  OpenFlow  1.0,  1.1, and 1.2+ all treat VLANs differently.
       Open vSwitch extensions add another variant to the  mix.  Open  vSwitch
       reconciles all four treatments as best it can.

   <b>VLAN</b> <b>Header</b> <b>Format</b>
       An 802.1Q VLAN header consists of two 16-bit fields:

          TPID        TCI
        &lt;-------&gt; &lt;---------&gt;
           16      3   1  12
       +---------+---+---+---+
       |Ethertype|PCP|CFI|VID|
       +---------+---+---+---+
         0x8100        0


       The  first  16  bits of the VLAN header, the <u>TPID</u> (Tag Protocol IDenti‐
       fier), is an Ethertype. When the VLAN header is inserted just after the
       source and destination MAC addresses in a  Ethertype  frame,  the  TPID
       serves  to  identify  the  presence of the VLAN. The standard TPID, the
       only one that Open vSwitch supports, is <b>0x8100</b>. OpenFlow 1.0 explicitly
       supports only TPID <b>0x8100</b>. OpenFlow 1.1, but not earlier or later  ver‐
       sions,  also  requires  support  for TPID <b>0x88a8</b> (Open vSwitch does not
       support this). OpenFlow 1.2 through 1.5 do not require support for spe‐
       cific TPIDs (the ``push vlan header’’ action does say that only  <b>0x8100</b>
       and  <b>0x88a8</b> should be pushed). No version of OpenFlow provides a way to
       distinguish or match on the TPID.

       The remaining 16 bits of the VLAN header, the <u>TCI</u> (Tag Control Informa‐
       tion), is subdivided into three subfields:

              •      <u>PCP</u> (Priority Control Point), is a 3-bit 802.1p <u>priority</u>.
                     The lowest priority is  value  1,  the  second-lowest  is
                     value 0, and priority increases from 2 up to highest pri‐
                     ority 7.

              •      <u>CFI</u> (Canonical Format Indicator), is a 1-bit field. On an
                     Ethernet  network,  its value is always 0. This led to it
                     later being repurposed under the name <u>DEI</u> (Drop Eligibil‐
                     ity Indicator). By either name, OpenFlow and Open vSwitch
                     don’t provide any way to match or set this bit.

              •      <u>VID</u> (VLAN IDentifier), is a 12-bit VLAN. If the VID is 0,
                     then the frame is not part of a VLAN. In that  case,  the
                     VLAN  header  is called a <u>priority</u> <u>tag</u> because it is only
                     meaningful for assigning the frame a priority. VID  <b>0xfff</b>
                     (4,095) is reserved.

       See <b>eth_type</b> for illustrations of a complete Ethernet frame with 802.1Q
       tag included.

   <b>Multiple</b> <b>VLANs</b>
       Open vSwitch can match only a single VLAN header. If more than one VLAN
       header  is  present,  then  <b>eth_type</b>  holds  the TPID of the inner VLAN
       header. Open vSwitch stops parsing the packet after the inner TPID,  so
       matching  further  into the packet (e.g. on the inner TCI or L3 fields)
       is not possible.

       OpenFlow only directly supports matching a single VLAN header. In Open‐
       Flow 1.1 or later, one OpenFlow table can match on the  outermost  VLAN
       header and pop it off, and a later OpenFlow table can match on the next
       outermost header. Open vSwitch does not support this.

   <b>VLAN</b> <b>Field</b> <b>Details</b>
       The  four variants have three different levels of expressiveness: Open‐
       Flow 1.0 and 1.1 VLAN matching are less  powerful  than  OpenFlow  1.2+
       VLAN  matching, which is less powerful than Open vSwitch extension VLAN
       matching.

   <b>OpenFlow</b> <b>1.0</b> <b>VLAN</b> <b>Fields</b>
       OpenFlow 1.0 uses two fields, called <b>dl_vlan</b> and <b>dl_vlan_pcp</b>,  each  of
       which  can  be  either  exact-matched  or  wildcarded,  to specify VLAN
       matches:

              •      When both <b>dl_vlan</b> and  <b>dl_vlan_pcp</b>  are  wildcarded,  the
                     flow matches packets without an 802.1Q header or with any
                     802.1Q header.

              •      The  match  <b>dl_vlan=0xffff</b>  causes  a  flow to match only
                     packets without an 802.1Q header. Such a flow should also
                     wildcard <b>dl_vlan_pcp</b>, since a packet  without  an  802.1Q
                     header  does  not  have  a PCP. OpenFlow does not specify
                     what to do if a match on PCP  is  actually  present,  but
                     Open vSwitch ignores it.

              •      Otherwise,  the  flow matches only packets with an 802.1Q
                     header. If <b>dl_vlan</b> is not wildcarded, then the flow  only
                     matches  packets  with the VLAN ID specified in <b>dl_vlan</b>’s
                     low 12 bits. If <b>dl_vlan_pcp</b> is not wildcarded,  then  the
                     flow  only matches packets with the priority specified in
                     <b>dl_vlan_pcp</b>’s low 3 bits.

                     OpenFlow does not specify how to  interpret  the  high  4
                     bits  of  <b>dl_vlan</b> or the high 5 bits of <b>dl_vlan_pcp</b>. Open
                     vSwitch ignores them.

   <b>OpenFlow</b> <b>1.1</b> <b>VLAN</b> <b>Fields</b>
       VLAN matching in OpenFlow 1.1 is similar to OpenFlow 1.0. The  one  re‐
       finement  is that when <b>dl_vlan</b> matches on <b>0xfffe</b> (<b>OFVPID_ANY</b>), the flow
       matches only packets with an  802.1Q  header,  with  any  VLAN  ID.  If
       <b>dl_vlan_pcp</b>  is  wildcarded, the flow matches any packet with an 802.1Q
       header, regardless of VLAN ID or priority. If <b>dl_vlan_pcp</b> is not  wild‐
       carded,  then the flow only matches packets with the priority specified
       in <b>dl_vlan_pcp</b>’s low 3 bits.

       OpenFlow 1.1 uses the name <b>OFPVID_NONE</b>, instead of <b>OFP_VLAN_NONE</b>, for a
       <b>dl_vlan</b> of <b>0xffff</b>, but it has the same meaning.

       In OpenFlow 1.1, Open vSwitch reports error <b>OFPBMC_BAD_VALUE</b> for an at‐
       tempt to match on <b>dl_vlan</b>  between  4,096  and  <b>0xfffd</b>,  inclusive,  or
       <b>dl_vlan_pcp</b> greater than 7.

   <b>OpenFlow</b> <b>1.2</b> <b>VLAN</b> <b>Fields</b>
       <b>OpenFlow</b> <b>1.2+</b> <b>VLAN</b> <b>ID</b> <b>Field</b>
       Name:            <b>vlan_vid</b>
       Width:           16 bits (only the least-significant 12 bits may be nonzero)
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   Ethernet
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_VLAN_VID</b> (6) since OpenFlow 1.2 and Open vSwitch 1.7
       NXM:             none

       The  OpenFlow  standard  describes this field as consisting of ``12+1’’
       bits. On ingress, its value is 0 if no 802.1Q header  is  present,  and
       otherwise  it holds the VLAN VID in its least significant 12 bits, with
       bit 12 (<b>0x1000</b> aka <b>OFPVID_PRESENT</b>) also set to 1. The three  most  sig‐
       nificant bits are always zero:

        OXM_OF_VLAN_VID
        &lt;-------------&gt;
         3  1     12
       +---+--+--------+
       |   |P |VLAN ID |
       +---+--+--------+
         0


       As  a  consequence  of this field’s format, one may use it to match the
       VLAN ID in all of the ways available with the OpenFlow 1.0 and 1.1 for‐
       mats, and a few new ways:

              Fully wildcarded
                     Matches any packet, that is, one without an 802.1Q header
                     or with an 802.1Q header with any TCI value.

              Value <b>0x0000</b> (<b>OFPVID_NONE</b>), mask <b>0xffff</b> (or no mask)
                     Matches only packets without an 802.1Q header.

              Value <b>0x1000</b>, mask <b>0x1000</b>
                     Matches any packet with an 802.1Q header,  regardless  of
                     VLAN ID.

              Value <b>0x1009</b>, mask <b>0xffff</b> (or no mask)
                     Match only packets with an 802.1Q header with VLAN ID 9.

              Value <b>0x1001</b>, mask <b>0x1001</b>
                     Matches  only  packets that have an 802.1Q header with an
                     odd-numbered VLAN ID. (This is just an example;  one  can
                     match on any desired VLAN ID bit pattern.)

       <b>OpenFlow</b> <b>1.2+</b> <b>VLAN</b> <b>Priority</b> <b>Field</b>
       Name:            <b>vlan_pcp</b>
       Width:           8 bits (only the least-significant 3 bits may be nonzero)
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   VLAN VID
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_VLAN_PCP</b>  (7)  since OpenFlow 1.2 and Open vSwitch
                        1.7
       NXM:             none

       The 3 least significant bits may be used to match the PCP  bits  in  an
       802.1Q header. Other bits are always zero:

        OXM_OF_VLAN_VID
        &lt;-------------&gt;
           5       3
       +--------+------+
       |  zero  | PCP  |
       +--------+------+
           0


       This  field  may  only be used when <b>vlan_vid</b> is not wildcarded and does
       not exact match on 0 (which  only  matches  when  there  is  no  802.1Q
       header).

       See <u>VLAN</u> <u>Comparison</u> <u>Chart</u>, below, for some examples.

   <b>Open</b> <b>vSwitch</b> <b>Extension</b> <b>VLAN</b> <b>Field</b>
       The <b>vlan_tci</b> extension can describe more kinds of VLAN matches than the
       other variants. It is also simpler than the other variants.

       <b>VLAN</b> <b>TCI</b> <b>Field</b>
       Name:            <b>vlan_tci</b>
       Width:           16 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   Ethernet
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             none
       NXM:             <b>NXM_OF_VLAN_TCI</b> (4) since Open vSwitch 1.1

       For a packet without an 802.1Q header, this field is zero. For a packet
       with  an 802.1Q header, this field is the TCI with the bit in CFI’s po‐
       sition (marked <b>P</b> for ``present’’ below) forced to 1. Thus, for a packet
       in VLAN 9 with priority 7, it has the value <b>0xf009</b>:

        NXM_VLAN_TCI
        &lt;----------&gt;
         3   1   12
       +----+--+----+
       |PCP |P |VID |
       +----+--+----+
         7   1   9


       Usage examples:

              <b>vlan_tci=0</b>
                     Match packets without an 802.1Q header.

              <b>vlan_tci=0x1000/0x1000</b>
                     Match packets with an 802.1Q header, regardless  of  VLAN
                     and priority values.

              <b>vlan_tci=0xf123</b>
                     Match packets tagged with priority 7 in VLAN 0x123.

              <b>vlan_tci=0x1123/0x1fff</b>
                     Match packets tagged with VLAN 0x123 (and any priority).

              <b>vlan_tci=0x5000/0xf000</b>
                     Match packets tagged with priority 2 (in any VLAN).

              <b>vlan_tci=0/0xfff</b>
                     Match packets with no 802.1Q header or tagged with VLAN 0
                     (and any priority).

              <b>vlan_tci=0x5000/0xe000</b>
                     Match packets with no 802.1Q header or tagged with prior‐
                     ity 2 (in any VLAN).

              <b>vlan_tci=0/0xefff</b>
                     Match packets with no 802.1Q header or tagged with VLAN 0
                     and priority 0.

       See <u>VLAN</u> <u>Comparison</u> <u>Chart</u>, below, for more examples.

   <b>VLAN</b> <b>Comparison</b> <b>Chart</b>
       The  following table describes each of several possible matching crite‐
       ria on 802.1Q header may be expressed with each variation of  the  VLAN
       matching fields:

       Criteria   OpenFlow 1.0   OpenFlow 1.1   OpenFlow 1.2+         NXM
       ─────────  ─────────────  ─────────────  ──────────────  ──────────
            [1]    ????/1,??/?    ????/1,??/?    0000/0000,--   0000/0000
            [2]    ffff/0,??/?    ffff/0,??/?    0000/ffff,--   0000/ffff
            [3]    0xxx/0,??/1    0xxx/0,??/1    1xxx/ffff,--   1xxx/1fff
            [4]    ????/1,0y/0    fffe/0,0y/0    1000/1000,0y   z000/f000
            [5]    0xxx/0,0y/0    0xxx/0,0y/0    1xxx/ffff,0y   zxxx/ffff
            [6]      (none)         (none)       1001/1001,--   1001/1001
            [7]      (none)         (none)         (none)       3000/3000
            [8]      (none)         (none)         (none)       0000/0fff
            [9]      (none)         (none)         (none)       0000/f000
           [10]      (none)         (none)         (none)       0000/efff

       All  numbers  in the table are expressed in hexadecimal. The columns in
       the table are interpreted as follows:

              Criteria
                     See the list below.

              OpenFlow 1.0
              OpenFlow 1.1
                   wwww/x,yy/z means VLAN ID match value  wwww  with  wildcard
                   bit  x  and  VLAN PCP match value yy with wildcard bit z. ?
                   means that the given bits are ignored (and conventionally 0
                   for wwww or yy, conventionally 1 for x  or  z).  ``(none)’’
                   means  that  OpenFlow  1.0 (or 1.1) cannot match with these
                   criteria.

              OpenFlow 1.2+
                   xxxx/yyyy,zz means <b>vlan_vid</b> with value xxxx and mask  yyyy,
                   and  <b>vlan_pcp</b>  (which  is  not  maskable) with value zz. --
                   means that <b>vlan_pcp</b> is omitted. ``(none)’’ means that Open‐
                   Flow 1.2 cannot match with these criteria.

              NXM  xxxx/yyyy means <b>vlan_tci</b> with value xxxx and mask yyyy.

       The matching criteria described by the table are:

              [1]    Matches any packet, that is, one without an 802.1Q header
                     or with an 802.1Q header with any TCI value.

              [2]    Matches only packets without an 802.1Q header.

                     OpenFlow 1.0 doesn’t define the behavior  if  <b>dl_vlan</b>  is
                     set  to  <b>0xffff</b>  and <b>dl_vlan_pcp</b> is not wildcarded. (Open
                     vSwitch always ignores <b>dl_vlan_pcp</b> when <b>dl_vlan</b> is set to
                     <b>0xffff</b>.)

                     OpenFlow 1.1 says explicitly to ignore  <b>dl_vlan_pcp</b>  when
                     <b>dl_vlan</b> is set to <b>0xffff</b>.

                     OpenFlow  1.2  doesn’t  say how to interpret a match with
                     <b>vlan_vid</b> value 0 and a mask with <b>OFPVID_PRESENT</b>  (<b>0x1000</b>)
                     set  to  1 and some other bits in the mask set to 1 also.
                     Open vSwitch interprets it the same  way  as  a  mask  of
                     <b>0x1000</b>.

                     Any  NXM  match with <b>vlan_tci</b> value 0 and the CFI bit set
                     to 1 in the mask is equivalent to the one listed  in  the
                     table.

              [3]    Matches  only packets that have an 802.1Q header with VID
                     xxx (and any PCP).

              [4]    Matches only packets that have an 802.1Q header with  PCP
                     y (and any VID).

                     OpenFlow 1.0 doesn’t clearly define the behavior for this
                     case. Open vSwitch implements it this way.

                     In the NXM value, z equals (y &lt;&lt; 1) | 1.

              [5]    Matches  only packets that have an 802.1Q header with VID
                     xxx and PCP y.

                     In the NXM value, z equals (y &lt;&lt; 1) | 1.

              [6]    Matches only packets that have an 802.1Q header  with  an
                     odd-numbered  VID (and any PCP). Only possible with Open‐
                     Flow 1.2 and NXM. (This is just an example; one can match
                     on any desired VID bit pattern.)

              [7]    Matches only packets that have an 802.1Q header  with  an
                     odd-numbered  PCP  (and any VID). Only possible with NXM.
                     (This is just an example; one can match  on  any  desired
                     VID bit pattern.)

              [8]    Matches  packets  with no 802.1Q header or with an 802.1Q
                     header with a VID of 0. Only possible with NXM.

              [9]    Matches packets with no 802.1Q header or with  an  802.1Q
                     header with a PCP of 0. Only possible with NXM.

              [10]   Matches  packets  with no 802.1Q header or with an 802.1Q
                     header with both VID and PCP of  0.  Only  possible  with
                     NXM.
<b>LAYER</b> <b>2.5:</b> <b>MPLS</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name         Bytes             Mask   RW?   Prereqs   NXM/OXM Support
       ───────────  ────────────────  ─────  ────  ────────  ──────────────────────
       <b>mpls_label</b>   4 (low 20 bits)   no     yes   MPLS      OF 1.2+ and OVS 1.11+
       <b>mpls_tc</b>      1 (low 3 bits)    no     yes   MPLS      OF 1.2+ and OVS 1.11+
       <b>mpls_bos</b>     1 (low 1 bits)    no     no    MPLS      OF 1.3+ and OVS 1.11+
       <b>mpls_ttl</b>     1                 no     yes   MPLS      OVS 2.6+

       One  or  more MPLS headers (more commonly called <u>MPLS</u> <u>labels</u>) follow an
       Ethernet type field that specifies an MPLS Ethernet  type  [RFC  3032].
       Ethertype  <b>0x8847</b>  is  used  for all unicast. Multicast MPLS is divided
       into two specific classes, one of which uses Ethertype <b>0x8847</b>  and  the
       other <b>0x8848</b> [RFC 5332].

       The most common overall packet format is Ethernet II, shown below (SNAP
       encapsulation  may  be used but is not ordinarily seen in Ethernet net‐
       works):

           Ethernet           MPLS
        &lt;------------&gt;   &lt;------------&gt;
        48  48    16      20   3  1  8
       +---+---+------+ +-----+--+-+---+
       |dst|src| type | |label|TC|S|TTL| ...
       +---+---+------+ +-----+--+-+---+
                0x8847


       MPLS can be encapsulated inside an 802.1Q header,  in  which  case  the
       combination looks like this:

        Ethernet     802.1Q     Ethertype        MPLS
        &lt;------&gt;   &lt;--------&gt;   &lt;-------&gt;   &lt;------------&gt;
         48  48      16   16       16        20   3  1  8
       +----+---+ +------+---+ +---------+ +-----+--+-+---+
       |dst |src| | TPID |TCI| |  type   | |label|TC|S|TTL| ...
       +----+---+ +------+---+ +---------+ +-----+--+-+---+
                   0x8100        0x8847


       The fields within an MPLS label are:

              Label, 20 bits.
                     An identifier.

              Traffic control (TC), 3 bits.
                     Used for quality of service.

              Bottom of stack (BOS), 1 bit (labeled just ``S’’ above).
                     0 indicates that another MPLS label follows this one.

                     1  indicates  that this MPLS label is the last one in the
                     stack, so that some other protocol follows this one.

              Time to live (TTL), 8 bits.
                     Each hop across an MPLS network decrements the TTL by  1.
                     If it reaches 0, the packet is discarded.

                     OpenFlow  does not make the MPLS TTL available as a match
                     field, but actions are available to set and decrement the
                     TTL. Open vSwitch 2.6 and later makes the MPLS TTL avail‐
                     able as an extension.

   <b>MPLS</b> <b>Label</b> <b>Stacks</b>
       Unlike the other encapsulations supported by OpenFlow and Open vSwitch,
       MPLS labels are routinely used in ``stacks’’  two  or  three  deep  and
       sometimes  even deeper. Open vSwitch currently supports up to three la‐
       bels.

       The OpenFlow specification only supports matching on the outermost MPLS
       label at any given time. To match on the second label, one  must  first
       ``pop’’  the  outer  label and advance to another OpenFlow table, where
       the inner label may be matched. To match on the third label,  one  must
       pop the two outer labels, and so on.

   <b>MPLS</b> <b>Inner</b> <b>Protocol</b>
       Unlike  all other forms of encapsulation that Open vSwitch and OpenFlow
       support, an MPLS label does not indicate what inner protocol it  encap‐
       sulates.  Different deployments determine the inner protocol in differ‐
       ent ways [RFC 3032]:

              •      A few reserved label values do indicate an  inner  proto‐
                     col. Label 0, the ``IPv4 Explicit NULL Label,’’ indicates
                     inner  IPv4.  Label  2, the ``IPv6 Explicit NULL Label,’’
                     indicates inner IPv6.

              •      Some deployments use  a  single  inner  protocol  consis‐
                     tently.

              •      In  some deployments, the inner protocol must be inferred
                     from the innermost label.

              •      In some deployments, the inner protocol must be  inferred
                     from  the innermost label and the encapsulated data, e.g.
                     to distinguish between  inner  IPv4  and  IPv6  based  on
                     whether the first nibble of the inner protocol data are <b>4</b>
                     or  <b>6</b>. OpenFlow and Open vSwitch do not currently support
                     these cases.

       Open vSwitch and OpenFlow do not infer the inner protocol, even if  re‐
       served  label  values  are in use. Instead, the flow table must specify
       the inner protocol at the time it pops the bottommost MPLS label, using
       the Ethertype argument to the <b>pop_mpls</b> action.

   <b>Field</b> <b>Details</b>
       <b>MPLS</b> <b>Label</b> <b>Field</b>
       Name:            <b>mpls_label</b>
       Width:           32 bits (only the least-significant 20 bits may be nonzero)
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   MPLS
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_MPLS_LABEL</b> (34) since OpenFlow 1.2 and Open  vSwitch
                        1.11
       NXM:             none

       The  least  significant  20 bits hold the ``label’’ field from the MPLS
       label. Other bits are zero:

        OXM_OF_MPLS_LABEL
        &lt;---------------&gt;
           12       20
       +--------+--------+
       |  zero  | label  |
       +--------+--------+
           0


       Most label values are available for any use by deployments. Values  un‐
       der 16 are reserved.

       <b>MPLS</b> <b>Traffic</b> <b>Class</b> <b>Field</b>
       Name:            <b>mpls_tc</b>
       Width:           8 bits (only the least-significant 3 bits may be nonzero)
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   MPLS
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_MPLS_TC</b>  (35)  since OpenFlow 1.2 and Open vSwitch
                        1.11
       NXM:             none

       The least significant 3 bits hold the TC field  from  the  MPLS  label.
       Other bits are zero:

        OXM_OF_MPLS_TC
        &lt;------------&gt;
           5       3
       +--------+-----+
       |  zero  | TC  |
       +--------+-----+
           0


       This  field  is  intended  for use for Quality of Service (QoS) and Ex‐
       plicit Congestion Notification purposes, but its particular interpreta‐
       tion is deployment specific.

       Before 2009, this field was named EXP and reserved for experimental use
       [RFC 5462].

       <b>MPLS</b> <b>Bottom</b> <b>of</b> <b>Stack</b> <b>Field</b>
       Name:            <b>mpls_bos</b>
       Width:           8 bits (only the least-significant 1 bits may be nonzero)
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   MPLS
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_MPLS_BOS</b> (36) since OpenFlow 1.3 and Open  vSwitch
                        1.11
       NXM:             none

       The  least  significant  bit  holds  the BOS field from the MPLS label.
       Other bits are zero:

        OXM_OF_MPLS_BOS
        &lt;-------------&gt;
           7       1
       +--------+------+
       |  zero  | BOS  |
       +--------+------+
           0


       This field is useful as part of processing a series  of  incoming  MPLS
       labels.  A  flow that includes a <b>pop_mpls</b> action should generally match
       on <b>mpls_bos</b>:

              •      When <b>mpls_bos</b> is 0, there is another MPLS label following
                     this one, so the Ethertype passed to <b>pop_mpls</b>  should  be
                     an  MPLS Ethertype. For example: <b>table=0,</b> <b>dl_type=0x8847,</b>
                     <b>mpls_bos=0,</b> <b>actions=pop_mpls:0x8847,</b> <b>goto_table:1</b>

              •      When <b>mpls_bos</b> is 1, this MPLS label is the last  one,  so
                     the  Ethertype  passed  to  <b>pop_mpls</b> should be a non-MPLS
                     Ethertype   such   as   IPv4.   For   example:   <b>table=1,</b>
                     <b>dl_type=0x8847,</b>    <b>mpls_bos=1,</b>   <b>actions=pop_mpls:0x0800,</b>
                     <b>goto_table:2</b>

       <b>MPLS</b> <b>Time-to-Live</b> <b>Field</b>
       Name:            <b>mpls_ttl</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   MPLS
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_MPLS_TTL</b> (30) since Open vSwitch 2.6

       Holds the 8-bit time-to-live field from the MPLS label:

        NXM_NX_MPLS_TTL
        &lt;-------------&gt;
               8
       +---------------+
       |      TTL      |
       +---------------+

<b>LAYER</b> <b>3:</b> <b>IPV4</b> <b>AND</b> <b>IPV6</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name                    Bytes             Mask   RW?   Prereqs     NXM/OXM Support
       ──────────────────────  ────────────────  ─────  ────  ──────────  ─────────────────────
       <b>ip_src</b> aka <b>nw_src</b>       4                 yes    yes   IPv4        OF 1.2+ and OVS 1.1+
       <b>ip_dst</b> aka <b>nw_dst</b>       4                 yes    yes   IPv4        OF 1.2+ and OVS 1.1+
       <b>ipv6_src</b>                16                yes    yes   IPv6        OF 1.2+ and OVS 1.1+
       <b>ipv6_dst</b>                16                yes    yes   IPv6        OF 1.2+ and OVS 1.1+
       <b>ipv6_label</b>              4 (low 20 bits)   yes    yes   IPv6        OF 1.2+ and OVS 1.4+
       <b>nw_proto</b> aka <b>ip_proto</b>   1                 no     no    IPv4/IPv6   OF 1.2+ and OVS 1.1+
       <b>nw_ttl</b>                  1                 no     yes   IPv4/IPv6   OVS 1.4+
       <b>ip_frag</b> aka <b>nw_frag</b>     1 (low 2 bits)    yes    no    IPv4/IPv6   OVS 1.3+
       <b>nw_tos</b>                  1                 no     yes   IPv4/IPv6   OVS 1.1+
       <b>ip_dscp</b>                 1 (low 6 bits)    no     yes   IPv4/IPv6   OF 1.2+ and OVS 1.7+
       <b>nw_ecn</b> aka <b>ip_ecn</b>       1 (low 2 bits)    no     yes   IPv4/IPv6   OF 1.2+ and OVS 1.4+

   <b>IPv4</b> <b>Specific</b> <b>Fields</b>
       These fields are applicable only to IPv4 flows,  that  is,  flows  that
       match on the IPv4 Ethertype <b>0x0800</b>.

       <b>IPv4</b> <b>Source</b> <b>Address</b> <b>Field</b>
       Name:            <b>ip_src</b> (aka <b>nw_src</b>)
       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks
       Prerequisites:   IPv4
       Access:          read/write
       OpenFlow 1.0:    yes (CIDR match only)
       OpenFlow 1.1:    yes
       OXM:             <b>OXM_OF_IPV4_SRC</b>  (11)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_IP_SRC</b> (7) since Open vSwitch 1.1

       The source address from the IPv4 header:

          Ethernet            IPv4
        &lt;-----------&gt;   &lt;---------------&gt;
        48  48   16           8   32  32
       +---+---+-----+ +---+-----+---+---+
       |dst|src|type | |...|proto|src|dst| ...
       +---+---+-----+ +---+-----+---+---+
                0x800


       For historical reasons, in an ARP or RARP flow, Open vSwitch interprets
       matches on <b>nw_src</b> as actually referring to the ARP SPA.

       <b>IPv4</b> <b>Destination</b> <b>Address</b> <b>Field</b>
       Name:            <b>ip_dst</b> (aka <b>nw_dst</b>)
       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks
       Prerequisites:   IPv4
       Access:          read/write
       OpenFlow 1.0:    yes (CIDR match only)
       OpenFlow 1.1:    yes
       OXM:             <b>OXM_OF_IPV4_DST</b>  (12)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_IP_DST</b> (8) since Open vSwitch 1.1

       The destination address from the IPv4 header:

          Ethernet            IPv4
        &lt;-----------&gt;   &lt;---------------&gt;
        48  48   16           8   32  32
       +---+---+-----+ +---+-----+---+---+
       |dst|src|type | |...|proto|src|dst| ...
       +---+---+-----+ +---+-----+---+---+
                0x800


       For historical reasons, in an ARP or RARP flow, Open vSwitch interprets
       matches on <b>nw_dst</b> as actually referring to the ARP TPA.

   <b>IPv6</b> <b>Specific</b> <b>Fields</b>
       These fields apply only to IPv6 flows, that is, flows that match on the
       IPv6 Ethertype <b>0x86dd</b>.

       <b>IPv6</b> <b>Source</b> <b>Address</b> <b>Field</b>
       Name:            <b>ipv6_src</b>
       Width:           128 bits
       Format:          IPv6
       Masking:         arbitrary bitwise masks
       Prerequisites:   IPv6
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_IPV6_SRC</b>  (26)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.1
       NXM:             <b>NXM_NX_IPV6_SRC</b> (19) since Open vSwitch 1.1

       The source address from the IPv6 header:

           Ethernet            IPv6
        &lt;------------&gt;   &lt;--------------&gt;
        48  48    16          8   128 128
       +---+---+------+ +---+----+---+---+
       |dst|src| type | |...|next|src|dst| ...
       +---+---+------+ +---+----+---+---+
                0x86dd


       Open vSwitch 1.8 added support for bitwise matching;  earlier  versions
       supported only CIDR masks.

       <b>IPv6</b> <b>Destination</b> <b>Address</b> <b>Field</b>
       Name:            <b>ipv6_dst</b>
       Width:           128 bits
       Format:          IPv6
       Masking:         arbitrary bitwise masks
       Prerequisites:   IPv6
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_IPV6_DST</b>  (27)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.1
       NXM:             <b>NXM_NX_IPV6_DST</b> (20) since Open vSwitch 1.1

       The destination address from the IPv6 header:

           Ethernet            IPv6
        &lt;------------&gt;   &lt;--------------&gt;
        48  48    16          8   128 128
       +---+---+------+ +---+----+---+---+
       |dst|src| type | |...|next|src|dst| ...
       +---+---+------+ +---+----+---+---+
                0x86dd


       Open vSwitch 1.8 added support for bitwise matching;  earlier  versions
       supported only CIDR masks.

       <b>IPv6</b> <b>Flow</b> <b>Label</b> <b>Field</b>
       Name:            <b>ipv6_label</b>
       Width:           32 bits (only the least-significant 20 bits may be nonzero)
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   IPv6
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_IPV6_FLABEL</b> (28) since OpenFlow 1.2 and Open vSwitch
                        1.7
       NXM:             <b>NXM_NX_IPV6_LABEL</b> (27) since Open vSwitch 1.4

       The  least  significant 20 bits hold the flow label field from the IPv6
       header. Other bits are zero:

        OXM_OF_IPV6_FLABEL
        &lt;----------------&gt;
           12       20
       +--------+---------+
       |  zero  |  label  |
       +--------+---------+
           0


   <b>IPv4/IPv6</b> <b>Fields</b>
       These fields exist with at least approximately the same meaning in both
       IPv4 and IPv6, so they are treated as a single field for matching  pur‐
       poses.  Any  flow that matches on the IPv4 Ethertype <b>0x0800</b> or the IPv6
       Ethertype <b>0x86dd</b> may match on these fields.

       <b>IPv4/v6</b> <b>Protocol</b> <b>Field</b>
       Name:            <b>nw_proto</b> (aka <b>ip_proto</b>)
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   IPv4/IPv6
       Access:          read-only
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_IP_PROTO</b>  (10)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_IP_PROTO</b> (6) since Open vSwitch 1.1

       Matches the IPv4 or IPv6 protocol type.

       For historical reasons, in an ARP or RARP flow, Open vSwitch interprets
       matches  on  <b>nw_proto</b>  as actually referring to the ARP opcode. The ARP
       opcode is a 16-bit field, so for matching purposes ARP opcodes  greater
       than  255  are  treated as 0; this works adequately because in practice
       ARP and RARP only use opcodes 1 through 4.

       In the case of fragmented traffic, a difference exists in the  way  the
       field  acts  for IPv4 and IPv6 later fragments. For IPv6 fragments with
       nonzero offset, <b>nw_proto</b> is set to the IPv6 protocol type for fragments
       (44). Conversely, for IPv4 later fragments, the field is set  based  on
       the protocol type present in the header.

       <b>IPv4/v6</b> <b>TTL/Hop</b> <b>Limit</b> <b>Field</b>
       Name:            <b>nw_ttl</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   IPv4/IPv6
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_IP_TTL</b> (29) since Open vSwitch 1.4

       The  main  reason  to  match on the TTL or hop limit field is to detect
       whether a <b>dec_ttl</b> action will fail due to a TTL exceeded error. Another
       way that a controller can detect TTL exceeded is to listen for <b>OFPR_IN‐</b>
       <b>VALID_TTL</b> ``packet-in’’ messages via OpenFlow.

       <b>IPv4/v6</b> <b>Fragment</b> <b>Bitmask</b> <b>Field</b>
       Name:            <b>ip_frag</b> (aka <b>nw_frag</b>)
       Width:           8 bits (only the least-significant 2 bits may be nonzero)
       Format:          frag
       Masking:         arbitrary bitwise masks
       Prerequisites:   IPv4/IPv6
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_IP_FRAG</b> (26) since Open vSwitch 1.3

       Specifies what kinds of IP fragments or  non-fragments  to  match.  The
       value  for this field is most conveniently specified as one of the fol‐
       lowing:

              <b>no</b>     Match only non-fragmented packets.

              <b>yes</b>    Matches all fragments.

              <b>first</b>  Matches only fragments with offset 0.

              <b>later</b>  Matches only fragments with nonzero offset.

              <b>not_later</b>
                     Matches non-fragmented packets and  fragments  with  zero
                     offset.

       The field is internally formatted as 2 bits: bit 0 is 1 for an IP frag‐
       ment  with any offset (and otherwise 0), and bit 1 is 1 for an IP frag‐
       ment with nonzero offset (and otherwise 0), like so:

        NXM_NX_IP_FRAG
        &lt;------------&gt;
         6     1    1
       +----+-----+---+
       |zero|later|any|
       +----+-----+---+
         0


       Even though 2 bits have 4 possible values, this field only  uses  3  of
       them:

              •      A packet that is not an IP fragment has value 0.

              •      A  packet that is an IP fragment with offset 0 (the first
                     fragment) has bit 0 set and thus value 1.

              •      A packet that is an IP fragment with nonzero  offset  has
                     bits 0 and 1 set and thus value 3.

       The switch may reject matches against values that can never appear.

       It  is  important to understand how this field interacts with the Open‐
       Flow fragment handling mode:

              •      In <b>OFPC_FRAG_DROP</b> mode, the OpenFlow switch drops all  IP
                     fragments  before  they  reach  the  flow table, so every
                     packet that is available for matching will have  value  0
                     in this field.

              •      Open vSwitch does not implement <b>OFPC_FRAG_REASM</b> mode, but
                     if  it  did then IP fragments would be reassembled before
                     they reached the flow table and again every packet avail‐
                     able for matching would always have value 0.

              •      In <b>OFPC_FRAG_NORMAL</b> mode, all three values are  possible,
                     but OpenFlow 1.0 says that fragments’ transport ports are
                     always  0,  even for the first fragment, so this does not
                     provide much extra information.

              •      In <b>OFPC_FRAG_NX_MATCH</b> mode, all three values  are  possi‐
                     ble.  For  fragments with offset 0, Open vSwitch makes L4
                     header information available.

       Thus, this field is likely to be most useful for an Open vSwitch switch
       configured in <b>OFPC_FRAG_NX_MATCH</b>  mode.  See  the  description  of  the
       <b>set-frags</b> command in <b>ovs-ofctl</b>(8), for more details.

     <u>IPv4/IPv6</u> <u>TOS</u> <u>Fields</u>

       IPv4  and IPv6 contain a one-byte ``type of service’’ or TOS field that
       has the following format:

        type of service
        &lt;-------------&gt;
           6       2
       +--------+------+
       |  DSCP  | ECN  |
       +--------+------+


       <b>IPv4/v6</b> <b>DSCP</b> <b>(Bits</b> <b>2-7)</b> <b>Field</b>
       Name:            <b>nw_tos</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   IPv4/IPv6
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             none
       NXM:             <b>NXM_OF_IP_TOS</b> (5) since Open vSwitch 1.1

       This field is the TOS byte with the two ECN bits cleared to 0:

        NXM_OF_IP_TOS
        &lt;-----------&gt;
          6      2
       +------+------+
       | DSCP | zero |
       +------+------+
                 0


       <b>IPv4/v6</b> <b>DSCP</b> <b>(Bits</b> <b>0-5)</b> <b>Field</b>
       Name:            <b>ip_dscp</b>
       Width:           8 bits (only the least-significant 6 bits may be nonzero)
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   IPv4/IPv6
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_IP_DSCP</b> (8) since OpenFlow 1.2  and  Open  vSwitch
                        1.7
       NXM:             none

       This  field is the TOS byte shifted right to put the DSCP bits in the 6
       least-significant bits:

        OXM_OF_IP_DSCP
        &lt;------------&gt;
           2      6
       +-------+------+
       | zero  | DSCP |
       +-------+------+
           0


       <b>IPv4/v6</b> <b>ECN</b> <b>Field</b>
       Name:            <b>nw_ecn</b> (aka <b>ip_ecn</b>)
       Width:           8 bits (only the least-significant 2 bits may be nonzero)
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   IPv4/IPv6
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_IP_ECN</b> (9) since OpenFlow 1.2 and Open vSwitch 1.7
       NXM:             <b>NXM_NX_IP_ECN</b> (28) since Open vSwitch 1.4

       This field is the TOS byte with the DSCP bits cleared to 0:

        OXM_OF_IP_ECN
        &lt;-----------&gt;
           6      2
       +-------+-----+
       | zero  | ECN |
       +-------+-----+
           0

<b>LAYER</b> <b>3:</b> <b>ARP</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name      Bytes   Mask   RW?   Prereqs   NXM/OXM Support
       ────────  ──────  ─────  ────  ────────  ─────────────────────
       <b>arp_op</b>    2       no     yes   ARP       OF 1.2+ and OVS 1.1+
       <b>arp_spa</b>   4       yes    yes   ARP       OF 1.2+ and OVS 1.1+
       <b>arp_tpa</b>   4       yes    yes   ARP       OF 1.2+ and OVS 1.1+
       <b>arp_sha</b>   6       yes    yes   ARP       OF 1.2+ and OVS 1.1+
       <b>arp_tha</b>   6       yes    yes   ARP       OF 1.2+ and OVS 1.1+

       In theory, Address Resolution Protocol, or ARP, is a  generic  protocol
       generic  protocol  that can be used to obtain the hardware address that
       corresponds to any higher-level protocol address. In  contemporary  us‐
       age,  ARP  is used only in Ethernet networks to obtain the Ethernet ad‐
       dress for a given IPv4 address. OpenFlow and Open vSwitch only  support
       this  usage  of ARP. For this use case, an ARP packet has the following
       format, with the ARP fields exposed as Open vSwitch fields highlighted:

          Ethernet                      ARP
        &lt;-----------&gt;   &lt;----------------------------------&gt;
        48  48   16     16   16    8   8  16 48  32  48  32
       +---+---+-----+ +---+-----+---+---+--+---+---+---+---+
       |dst|src|type | |hrd| pro |hln|pln|op|sha|spa|tha|tpa|
       +---+---+-----+ +---+-----+---+---+--+---+---+---+---+
                0x806    1  0x800  6   4


       The ARP fields are also used for RARP, the Reverse  Address  Resolution
       Protocol, which shares ARP’s wire format.

       <b>ARP</b> <b>Opcode</b> <b>Field</b>
       Name:            <b>arp_op</b>
       Width:           16 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   ARP
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_ARP_OP</b> (21) since OpenFlow 1.2 and Open vSwitch
                        1.7
       NXM:             <b>NXM_OF_ARP_OP</b> (15) since Open vSwitch 1.1

       Even  though  this is a 16-bit field, Open vSwitch does not support ARP
       opcodes greater than 255; it treats them to zero. This works adequately
       because in practice ARP and RARP only use opcodes 1 through 4.

       <b>ARP</b> <b>Source</b> <b>IPv4</b> <b>Address</b> <b>Field</b>
       Name:            <b>arp_spa</b>
       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks
       Prerequisites:   ARP
       Access:          read/write
       OpenFlow 1.0:    yes (CIDR match only)
       OpenFlow 1.1:    yes
       OXM:             <b>OXM_OF_ARP_SPA</b>  (22)  since  OpenFlow  1.2  and   Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_ARP_SPA</b> (16) since Open vSwitch 1.1

       <b>ARP</b> <b>Target</b> <b>IPv4</b> <b>Address</b> <b>Field</b>
       Name:            <b>arp_tpa</b>
       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks
       Prerequisites:   ARP
       Access:          read/write
       OpenFlow 1.0:    yes (CIDR match only)
       OpenFlow 1.1:    yes
       OXM:             <b>OXM_OF_ARP_TPA</b>   (23)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_ARP_TPA</b> (17) since Open vSwitch 1.1

       <b>ARP</b> <b>Source</b> <b>Ethernet</b> <b>Address</b> <b>Field</b>
       Name:            <b>arp_sha</b>
       Width:           48 bits
       Format:          Ethernet
       Masking:         arbitrary bitwise masks
       Prerequisites:   ARP
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_ARP_SHA</b>  (24)  since  OpenFlow  1.2  and   Open
                        vSwitch 1.7
       NXM:             <b>NXM_NX_ARP_SHA</b> (17) since Open vSwitch 1.1

       <b>ARP</b> <b>Target</b> <b>Ethernet</b> <b>Address</b> <b>Field</b>
       Name:            <b>arp_tha</b>
       Width:           48 bits
       Format:          Ethernet
       Masking:         arbitrary bitwise masks
       Prerequisites:   ARP
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_ARP_THA</b>   (25)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_NX_ARP_THA</b> (18) since Open vSwitch 1.1
<b>LAYER</b> <b>3:</b> <b>NSH</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name               Bytes             Mask   RW?   Prereqs   NXM/OXM Support
       ─────────────────  ────────────────  ─────  ────  ────────  ────────────────
       <b>nsh_flags</b>          1                 yes    yes   NSH       OVS 2.8+
       <b>nsh_ttl</b>            1                 no     yes   NSH       OVS 2.9+
       <b>nsh_mdtype</b>         1                 no     no    NSH       OVS 2.8+
       <b>nsh_np</b>             1                 no     no    NSH       OVS 2.8+
       <b>nsh_spi</b> aka <b>nsp</b>    4 (low 24 bits)   no     yes   NSH       OVS 2.8+
       <b>nsh_si</b> aka <b>nsi</b>     1                 no     yes   NSH       OVS 2.8+
       <b>nsh_c1</b> aka <b>nshc1</b>   4                 yes    yes   NSH       OVS 2.8+
       <b>nsh_c2</b> aka <b>nshc2</b>   4                 yes    yes   NSH       OVS 2.8+
       <b>nsh_c3</b> aka <b>nshc3</b>   4                 yes    yes   NSH       OVS 2.8+
       <b>nsh_c4</b> aka <b>nshc4</b>   4                 yes    yes   NSH       OVS 2.8+

       Service functions are widely deployed and essential in  many  networks.
       These  service  functions provide a range of features such as security,
       WAN acceleration, and server load balancing. Service functions  may  be
       instantiated  at different points in the network infrastructure such as
       the wide area network, data center, and so forth.

       Prior to development of the SFC architecture [RFC 7665] and the  proto‐
       col  specified  in  this  document, current service function deployment
       models have been relatively static and bound to topology for  insertion
       and  policy  selection.  Furthermore, they do not adapt well to elastic
       service environments enabled by virtualization.

       New data center network and cloud architectures require  more  flexible
       service  function  deployment  models.  Additionally, the transition to
       virtual platforms demands an agile service insertion  model  that  sup‐
       ports dynamic and elastic service delivery. Specifically, the following
       functions are necessary:

              1.  The  movement of service functions and application workloads
                  in the network.

              2.  The ability to easily bind service policy to granular infor‐
                  mation, such as per-subscriber state.

              3.  The capability to steer traffic  to  the  requisite  service
                  function(s).

       The Network Service Header (NSH) specification defines a new data plane
       protocol,  which  is  an encapsulation for service function chains. The
       NSH is designed to encapsulate an original packet or frame, and in turn
       be encapsulated by an outer transport encapsulation (which is  used  to
       deliver the NSH to NSH-aware network elements), as shown below:

       +-----------------------+----------------------------+---------------------+
       |Transport Encapsulation|Network Service Header (NSH)|Original Packet/Frame|
       +-----------------------+----------------------------+---------------------+


       The NSH is composed of the following elements:

              1.  Service Function Path identification.

              2.  Indication of location within a Service Function Path.

              3.  Optional, per packet metadata (fixed length or variable).

       [RFC 7665] provides an overview of a service chaining architecture that
       clearly  defines  the  roles of the various elements and the scope of a
       service function chaining encapsulation. Figure 3 of [RFC 7665] depicts
       the SFC architectural components after classification. The NSH  is  the
       SFC encapsulation referenced in [RFC 7665].

       <b>flags</b> <b>field</b> <b>(2</b> <b>bits)</b> <b>Field</b>
       Name:            <b>nsh_flags</b>
       Width:           8 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   NSH
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_FLAGS</b> (1) since Open vSwitch 2.8

       <b>TTL</b> <b>field</b> <b>(6</b> <b>bits)</b> <b>Field</b>
       Name:            <b>nsh_ttl</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   NSH
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_TTL</b> (10) since Open vSwitch 2.9

       <b>mdtype</b> <b>field</b> <b>(8</b> <b>bits)</b> <b>Field</b>
       Name:            <b>nsh_mdtype</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   NSH
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_MDTYPE</b> (2) since Open vSwitch 2.8

       <b>np</b> <b>(next</b> <b>protocol)</b> <b>field</b> <b>(8</b> <b>bits)</b> <b>Field</b>
       Name:            <b>nsh_np</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   NSH
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_NP</b> (3) since Open vSwitch 2.8

       <b>spi</b> <b>(service</b> <b>path</b> <b>identifier)</b> <b>field</b> <b>(24</b> <b>bits)</b> <b>Field</b>
       Name:            <b>nsh_spi</b> (aka <b>nsp</b>)
       Width:           32 bits (only the least-significant 24 bits may be nonzero)
       Format:          hexadecimal
       Masking:         not maskable
       Prerequisites:   NSH
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_SPI</b> (4) since Open vSwitch 2.8

       <b>si</b> <b>(service</b> <b>index)</b> <b>field</b> <b>(8</b> <b>bits)</b> <b>Field</b>
       Name:            <b>nsh_si</b> (aka <b>nsi</b>)
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   NSH
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_SI</b> (5) since Open vSwitch 2.8

       <b>c1</b> <b>(Network</b> <b>Platform</b> <b>Context)</b> <b>field</b> <b>(32</b> <b>bits)</b> <b>Field</b>
       Name:            <b>nsh_c1</b> (aka <b>nshc1</b>)
       Width:           32 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   NSH
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_C1</b> (6) since Open vSwitch 2.8

       <b>c2</b> <b>(Network</b> <b>Shared</b> <b>Context)</b> <b>field</b> <b>(32</b> <b>bits)</b> <b>Field</b>
       Name:            <b>nsh_c2</b> (aka <b>nshc2</b>)
       Width:           32 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   NSH
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_C2</b> (7) since Open vSwitch 2.8

       <b>c3</b> <b>(Service</b> <b>Platform</b> <b>Context)</b> <b>field</b> <b>(32</b> <b>bits)</b> <b>Field</b>
       Name:            <b>nsh_c3</b> (aka <b>nshc3</b>)
       Width:           32 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   NSH
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_C3</b> (8) since Open vSwitch 2.8

       <b>c4</b> <b>(Service</b> <b>Shared</b> <b>Context)</b> <b>field</b> <b>(32</b> <b>bits)</b> <b>Field</b>
       Name:            <b>nsh_c4</b> (aka <b>nshc4</b>)
       Width:           32 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   NSH
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_C4</b> (9) since Open vSwitch 2.8
<b>LAYER</b> <b>4:</b> <b>TCP,</b> <b>UDP,</b> <b>AND</b> <b>SCTP</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name                 Bytes             Mask   RW?   Prereqs   NXM/OXM Support
       ───────────────────  ────────────────  ─────  ────  ────────  ─────────────────────
       <b>tcp_src</b> aka <b>tp_src</b>   2                 yes    yes   TCP       OF 1.2+ and OVS 1.1+
       <b>tcp_dst</b> aka <b>tp_dst</b>   2                 yes    yes   TCP       OF 1.2+ and OVS 1.1+
       <b>tcp_flags</b>            2 (low 12 bits)   yes    no    TCP       OF 1.3+ and OVS 2.1+
       <b>udp_src</b>              2                 yes    yes   UDP       OF 1.2+ and OVS 1.1+
       <b>udp_dst</b>              2                 yes    yes   UDP       OF 1.2+ and OVS 1.1+
       <b>sctp_src</b>             2                 yes    yes   SCTP      OF 1.2+ and OVS 2.0+
       <b>sctp_dst</b>             2                 yes    yes   SCTP      OF 1.2+ and OVS 2.0+

       For  matching  purposes, no distinction is made whether these protocols
       are encapsulated within IPv4 or IPv6.

   <b>TCP</b>
       The following diagram shows TCP within IPv4. Open vSwitch also supports
       TCP in IPv6. Only TCP fields implemented as  Open  vSwitch  fields  are
       shown:

          Ethernet            IPv4                   TCP
        &lt;-----------&gt;   &lt;---------------&gt;   &lt;-------------------&gt;
        48  48   16           8   32  32    16  16       12
       +---+---+-----+ +---+-----+---+---+ +---+---+---+-----+---+
       |dst|src|type | |...|proto|src|dst| |src|dst|...|flags|...| ...
       +---+---+-----+ +---+-----+---+---+ +---+---+---+-----+---+
                0x800         6


       <b>TCP</b> <b>Source</b> <b>Port</b> <b>Field</b>
       Name:            <b>tcp_src</b> (aka <b>tp_src</b>)
       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   TCP
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_TCP_SRC</b>   (13)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_TCP_SRC</b> (9) since Open vSwitch 1.1

       Open vSwitch 1.6 added support for bitwise matching.

       <b>TCP</b> <b>Destination</b> <b>Port</b> <b>Field</b>
       Name:            <b>tcp_dst</b> (aka <b>tp_dst</b>)
       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   TCP
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_TCP_DST</b>  (14)  since  OpenFlow  1.2  and   Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_TCP_DST</b> (10) since Open vSwitch 1.1

       Open vSwitch 1.6 added support for bitwise matching.

       <b>TCP</b> <b>Flags</b> <b>Field</b>
       Name:            <b>tcp_flags</b>
       Width:           16 bits (only the least-significant 12 bits may be nonzero)
       Format:          TCP flags
       Masking:         arbitrary bitwise masks
       Prerequisites:   TCP
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>ONFOXM_ET_TCP_FLAGS</b>   (42)  since  OpenFlow  1.3  and  Open
                        vSwitch 2.4; <b>OXM_OF_TCP_FLAGS</b> (42) since OpenFlow  1.5  and
                        Open vSwitch 2.3
       NXM:             <b>NXM_NX_TCP_FLAGS</b> (34) since Open vSwitch 2.1

       This  field  holds the TCP flags. TCP currently defines 9 flag bits. An
       additional 3 bits are reserved. For more information,  see  [RFC  793],
       [RFC 3168], and [RFC 3540].

       Matches  on  this  field are most conveniently written in terms of sym‐
       bolic names (given in the diagram below), each preceded by either <b>+</b> for
       a flag that must be set, or <b>-</b> for a flag that must  be  unset,  without
       any  other  delimiters between the flags. Flags not mentioned are wild‐
       carded. For example, <b>tcp,tcp_flags=+syn-ack</b> matches TCP SYNs  that  are
       not  ACKs,  and  <b>tcp,tcp_flags=+[200]</b>  matches TCP packets with the re‐
       served [200] flag set. Matches can also be written as <u>flags</u><b>/</b><u>mask</u>, where
       <u>flags</u> and <u>mask</u> are 16-bit numbers in decimal or in hexadecimal prefixed
       by <b>0x</b>.

       The flag bits are:

                 reserved      later RFCs         RFC 793
             &lt;---------------&gt; &lt;--------&gt; &lt;---------------------&gt;
         4     1     1     1   1   1   1   1   1   1   1   1   1
       +----+-----+-----+-----+--+---+---+---+---+---+---+---+---+
       |zero|[800]|[400]|[200]|NS|CWR|ECE|URG|ACK|PSH|RST|SYN|FIN|
       +----+-----+-----+-----+--+---+---+---+---+---+---+---+---+
         0


   <b>UDP</b>
       The following diagram shows UDP within IPv4. Open vSwitch also supports
       UDP in IPv6. Only UDP fields that Open vSwitch exposes  as  fields  are
       shown:

          Ethernet            IPv4              UDP
        &lt;-----------&gt;   &lt;---------------&gt;   &lt;---------&gt;
        48  48   16           8   32  32    16  16
       +---+---+-----+ +---+-----+---+---+ +---+---+---+
       |dst|src|type | |...|proto|src|dst| |src|dst|...| ...
       +---+---+-----+ +---+-----+---+---+ +---+---+---+
                0x800        17


       <b>UDP</b> <b>Source</b> <b>Port</b> <b>Field</b>
       Name:            <b>udp_src</b>
       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   UDP
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_UDP_SRC</b>   (15)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_UDP_SRC</b> (11) since Open vSwitch 1.1

       <b>UDP</b> <b>Destination</b> <b>Port</b> <b>Field</b>
       Name:            <b>udp_dst</b>
       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   UDP
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_UDP_DST</b>  (16)  since  OpenFlow  1.2  and   Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_UDP_DST</b> (12) since Open vSwitch 1.1

   <b>SCTP</b>
       The  following  diagram  shows SCTP within IPv4. Open vSwitch also sup‐
       ports SCTP in IPv6. Only SCTP  fields  that  Open  vSwitch  exposes  as
       fields are shown:

          Ethernet            IPv4             SCTP
        &lt;-----------&gt;   &lt;---------------&gt;   &lt;---------&gt;
        48  48   16           8   32  32    16  16
       +---+---+-----+ +---+-----+---+---+ +---+---+---+
       |dst|src|type | |...|proto|src|dst| |src|dst|...| ...
       +---+---+-----+ +---+-----+---+---+ +---+---+---+
                0x800        132


       <b>SCTP</b> <b>Source</b> <b>Port</b> <b>Field</b>
       Name:            <b>sctp_src</b>
       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   SCTP
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_SCTP_SRC</b>  (17)  since  OpenFlow  1.2  and  Open
                        vSwitch 2.0
       NXM:             none

       <b>SCTP</b> <b>Destination</b> <b>Port</b> <b>Field</b>
       Name:            <b>sctp_dst</b>
       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   SCTP
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_SCTP_DST</b>  (18)  since  OpenFlow  1.2  and  Open
                        vSwitch 2.0
       NXM:             none
<b>LAYER</b> <b>4:</b> <b>ICMPV4</b> <b>AND</b> <b>ICMPV6</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name              Bytes   Mask   RW?   Prereqs      NXM/OXM Support
       ────────────────  ──────  ─────  ────  ───────────  ─────────────────────
       <b>icmp_type</b>         1       no     yes   ICMPv4       OF 1.2+ and OVS 1.1+
       <b>icmp_code</b>         1       no     yes   ICMPv4       OF 1.2+ and OVS 1.1+
       <b>icmpv6_type</b>       1       no     yes   ICMPv6       OF 1.2+ and OVS 1.1+
       <b>icmpv6_code</b>       1       no     yes   ICMPv6       OF 1.2+ and OVS 1.1+
       <b>nd_target</b>         16      yes    yes   ND           OF 1.2+ and OVS 1.1+
       <b>nd_sll</b>            6       yes    yes   ND solicit   OF 1.2+ and OVS 1.1+
       <b>nd_tll</b>            6       yes    yes   ND advert    OF 1.2+ and OVS 1.1+
       <b>nd_reserved</b>       4       no     yes   ND           OVS 2.11+
       <b>nd_options_type</b>   1       no     yes   ND           OVS 2.11+

   <b>ICMPv4</b>
          Ethernet            IPv4             ICMPv4
        &lt;-----------&gt;   &lt;---------------&gt;   &lt;-----------&gt;
        48  48   16           8   32  32     8    8
       +---+---+-----+ +---+-----+---+---+ +----+----+---+
       |dst|src|type | |...|proto|src|dst| |type|code|...| ...
       +---+---+-----+ +---+-----+---+---+ +----+----+---+
                0x800         1


       <b>ICMPv4</b> <b>Type</b> <b>Field</b>
       Name:            <b>icmp_type</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   ICMPv4
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_ICMPV4_TYPE</b>  (19)  since  OpenFlow 1.2 and Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_ICMP_TYPE</b> (13) since Open vSwitch 1.1

       For historical reasons, in an  ICMPv4  flow,  Open  vSwitch  interprets
       matches on <b>tp_src</b> as actually referring to the ICMP type.

       <b>ICMPv4</b> <b>Code</b> <b>Field</b>
       Name:            <b>icmp_code</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   ICMPv4
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_ICMPV4_CODE</b>  (20)  since  OpenFlow 1.2 and Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_ICMP_CODE</b> (14) since Open vSwitch 1.1

       For historical reasons, in an  ICMPv4  flow,  Open  vSwitch  interprets
       matches on <b>tp_dst</b> as actually referring to the ICMP code.

   <b>ICMPv6</b>
           Ethernet            IPv6            ICMPv6
        &lt;------------&gt;   &lt;--------------&gt;   &lt;-----------&gt;
        48  48    16          8   128 128    8    8
       +---+---+------+ +---+----+---+---+ +----+----+---+
       |dst|src| type | |...|next|src|dst| |type|code|...| ...
       +---+---+------+ +---+----+---+---+ +----+----+---+
                0x86dd        58


       <b>ICMPv6</b> <b>Type</b> <b>Field</b>
       Name:            <b>icmpv6_type</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   ICMPv6
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_ICMPV6_TYPE</b>  (29)  since  OpenFlow 1.2 and Open
                        vSwitch 1.7
       NXM:             <b>NXM_NX_ICMPV6_TYPE</b> (21) since Open vSwitch 1.1

       <b>ICMPv6</b> <b>Code</b> <b>Field</b>
       Name:            <b>icmpv6_code</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   ICMPv6
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_ICMPV6_CODE</b> (30) since OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_NX_ICMPV6_CODE</b> (22) since Open vSwitch 1.1

   <b>ICMPv6</b> <b>Neighbor</b> <b>Discovery</b>
           Ethernet            IPv6              ICMPv6            ICMPv6 ND
        &lt;------------&gt;   &lt;--------------&gt;   &lt;--------------&gt;   &lt;---------------&gt;
        48  48    16          8   128 128      8     8          128
       +---+---+------+ +---+----+---+---+ +-------+----+---+ +------+----------+
       |dst|src| type | |...|next|src|dst| | type  |code|...| |target|option ...|
       +---+---+------+ +---+----+---+---+ +-------+----+---+ +------+----------+
                0x86dd        58            135/136  0


       <b>ICMPv6</b> <b>Neighbor</b> <b>Discovery</b> <b>Target</b> <b>IPv6</b> <b>Field</b>
       Name:            <b>nd_target</b>
       Width:           128 bits
       Format:          IPv6
       Masking:         arbitrary bitwise masks
       Prerequisites:   ND
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_IPV6_ND_TARGET</b> (31) since OpenFlow 1.2 and Open
                        vSwitch 1.7
       NXM:             <b>NXM_NX_ND_TARGET</b> (23) since Open vSwitch 1.1

       <b>ICMPv6</b> <b>Neighbor</b> <b>Discovery</b> <b>Source</b> <b>Ethernet</b> <b>Address</b> <b>Field</b>
       Name:            <b>nd_sll</b>
       Width:           48 bits
       Format:          Ethernet
       Masking:         arbitrary bitwise masks
       Prerequisites:   ND solicit
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_IPV6_ND_SLL</b>  (32)  since  OpenFlow 1.2 and Open
                        vSwitch 1.7
       NXM:             <b>NXM_NX_ND_SLL</b> (24) since Open vSwitch 1.1

       <b>ICMPv6</b> <b>Neighbor</b> <b>Discovery</b> <b>Target</b> <b>Ethernet</b> <b>Address</b> <b>Field</b>
       Name:            <b>nd_tll</b>
       Width:           48 bits
       Format:          Ethernet
       Masking:         arbitrary bitwise masks
       Prerequisites:   ND advert
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_IPV6_ND_TLL</b> (33) since OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_NX_ND_TLL</b> (25) since Open vSwitch 1.1

       <b>ICMPv6</b> <b>Neighbor</b> <b>Discovery</b> <b>Reserved</b> <b>Field</b> <b>Field</b>
       Name:            <b>nd_reserved</b>
       Width:           32 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   ND
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>ERICOXM_OF_ICMPV6_ND_RESERVED</b>  (1)  since Open vSwitch
                        2.11

       This is used to set the R,S,O bits in Neighbor Advertisement Messages

       <b>ICMPv6</b> <b>Neighbor</b> <b>Discovery</b> <b>Options</b> <b>Type</b> <b>Field</b> <b>Field</b>
       Name:            <b>nd_options_type</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   ND
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>ERICOXM_OF_ICMPV6_ND_OPTIONS_TYPE</b>   (2)   since   Open
                        vSwitch 2.11

       A value of 1 indicates that the option is Source Link Layer. A value of
       2  indicates  that  the  options is Target Link Layer. See RFC 4861 for
       further details.

<b>REFERENCES</b>
              Casado M. Casado, M. J. Freedman, J. Pettit, J. Luo, N. McKeown,
                     and S. Shenker, ``Ethane: Taking Control  of  the  Enter‐
                     prise,’’ Computer Communications Review, October 2007.

              ERSPAN M. Foschiano, K. Ghosh, M. Mehta, ``Cisco Systems’ Encap‐
                     sulated Remote Switch Port Analyzer (ERSPAN),’’ ⟨https://
                     tools.ietf.org/html/draft-foschiano-erspan-03⟩ .

              EXT-56 J. Tonsing, ``Permit one of a set of prerequisites to ap‐
                     ply, e.g. don’t preclude non-Ethernet media,’’ ⟨https://
                     rs.opennetworking.org/bugs/browse/EXT-56⟩   (ONF  members
                     only).

              EXT-112
                     J. Tourrilhes, ``Support non-Ethernet packets  throughout
                     the pipeline,’’ ⟨https://rs.opennetworking.org/bugs/
                     browse/EXT-112⟩ (ONF members only).

              EXT-134
                     J.  Tourrilhes,  ``Match  first  nibble  of the MPLS pay‐
                     load,’’ ⟨https://rs.opennetworking.org/bugs/browse/
                     EXT-134⟩ (ONF members only).

              Geneve J. Gross, I. Ganga, and T.  Sridhar,  editors,  ``Geneve:
                     Generic Network Virtualization Encapsulation,’’ ⟨https://
                     datatracker.ietf.org/doc/draft-ietf-nvo3-geneve/⟩ .

              IEEE OUI
                     IEEE  Standards  Association,  ``MAC  Address Block Large
                     (MA-L),’’ ⟨https://standards.ieee.org/develop/regauth/
                     oui/index.html⟩ .

              NSH    P.  Quinn  and  U.  Elzur,  editors,  ``Network   Service
                     Header,’’ ⟨https://datatracker.ietf.org/doc/
                     draft-ietf-sfc-nsh/⟩ .

              OpenFlow 1.0.1
                     Open  Networking  Foundation,  ``OpenFlow  Switch Errata,
                     Version 1.0.1,’’ June 2012.

              OpenFlow 1.1
                     OpenFlow Consortium, ``OpenFlow Switch Specification Ver‐
                     sion 1.1.0 Implemented (Wire Protocol  0x02),’’  February
                     2011.

              OpenFlow 1.5
                     Open  Networking Foundation, ``OpenFlow Switch Specifica‐
                     tion Version 1.5.0 (Protocol  version  0x06),’’  December
                     2014.

              OpenFlow Extensions 1.3.x Package 2
                     Open  Networking  Foundation, ``OpenFlow Extensions 1.3.x
                     Package 2,’’ December 2013.

              TCP Flags Match Field Extension
                     Open Networking Foundation, ``TCP flags match  field  Ex‐
                     tension,’’  December  2014. In [OpenFlow Extensions 1.3.x
                     Package 2].

              Pepelnjak
                     I. Pepelnjak, ``OpenFlow and Fermi Estimates,’’ ⟨http://
                     blog.ipspace.net/2013/09/openflow-and-fermi-esti‐
                     mates.html⟩ .

              RFC 793
                     ``Transmission Control Protocol,’’ ⟨http://www.ietf.org/
                     rfc/rfc793.txt⟩ .

              RFC 3032
                     E. Rosen, D. Tappan, G. Fedorkow, Y.  Rekhter,  D.  Fari‐
                     nacci,  T.  Li,  and  A. Conta, ``MPLS Label Stack Encod‐
                     ing,’’ ⟨http://www.ietf.org/rfc/rfc3032.txt⟩ .

              RFC 3168
                     K. Ramakrishnan, S. Floyd, and D. Black,  ``The  Addition
                     of Explicit Congestion Notification (ECN) to IP,’’
                     ⟨https://tools.ietf.org/html/rfc3168⟩ .

              RFC 3540
                     N.  Spring,  D.  Wetherall, and D. Ely, ``Robust Explicit
                     Congestion Notification (ECN) Signaling with Nonces,’’
                     ⟨https://tools.ietf.org/html/rfc3540⟩ .

              RFC 4632
                     V. Fuller and T.  Li,  ``Classless  Inter-domain  Routing
                     (CIDR):  The  Internet Address Assignment and Aggregation
                     Plan,’’ ⟨https://tools.ietf.org/html/rfc4632⟩ .

              RFC 5462
                     L. Andersson and R. Asati, ``Multiprotocol Label  Switch‐
                     ing  (MPLS)  Label  Stack Entry: ``EXP’’ Field Renamed to
                     ``Traffic Class’’ Field,’’ ⟨http://www.ietf.org/rfc/
                     rfc5462.txt⟩ .

              RFC 6830
                     D. Farinacci, V. Fuller, D. Meyer, and  D.  Lewis,  ``The
                     Locator/ID Separation Protocol (LISP),’’ ⟨http://
                     www.ietf.org/rfc/rfc6830.txt⟩ .

              RFC 7348
                     M.  Mahalingam, D. Dutt, K. Duda, P. Agarwal, L. Kreeger,
                     T. Sridhar, M. Bursell, and C. Wright, ``Virtual eXtensi‐
                     ble Local Area Network (VXLAN): A Framework for  Overlay‐
                     ing  Virtualized  Layer 2 Networks over Layer 3 Networks,
                     ’’ ⟨https://tools.ietf.org/html/rfc7348⟩ .

              RFC 7665
                     J. Halpern, Ed. and C. Pignataro, Ed., ``Service Function
                     Chaining (SFC) Architecture,’’ ⟨https://tools.ietf.org/
                     html/rfc7665⟩ .

              Srinivasan
                     V. Srinivasan, S. Suriy, and G. Varghese, ``Packet  Clas‐
                     sification using Tuple Space Search,’’ SIGCOMM 1999.

              Pagiamtzis
                     K.  Pagiamtzis  and A. Sheikholeslami, ``Content-address‐
                     able memory (CAM) circuits and architectures: A  tutorial
                     and  survey,’’ IEEE Journal of Solid-State Circuits, vol.
                     41, no. 3, pp. 712-727, March 2006.

              VXLAN Group Policy Option
                     M. Smith and L. Kreeger, `` VXLAN Group Policy  Option.’’
                     Internet-Draft.  ⟨https://tools.ietf.org/html/
                     draft-smith-vxlan-group-policy⟩ .

<b>AUTHORS</b>
       Ben Pfaff, with advice from Justin Pettit and Jean Tourrilhes.

Open vSwitch                         3.5.0                       <u>ovs-fields</u>(7)
</pre></body></html>
