<html><head><meta charset="UTF-8"></head><body><pre>
ovs-fields(7)                 Open vSwitch Manual                ovs-fields(7)



<b>NAME</b>
       ovs-fields - protocol header fields in OpenFlow and Open vSwitch

<b>INTRODUCTION</b>
       This  document aims to comprehensively document all of the fields, both
       standard and non-standard, supported by OpenFlow or Open  vSwitch,  re‐
       gardless of origin.

   <b>Fields</b>
       A  <u>field</u>  is  a  property of a packet. Most familiarly, <u>data</u> <u>fields</u> are
       fields that can be extracted from a packet. Most data fields are copied
       directly  from  protocol  headers, e.g. at layer 2, the Ethernet source
       and destination addresses, or the VLAN ID; at layer 3, the IPv4 or IPv6
       source  and  destination;  and  at layer 4, the TCP or UDP ports. Other
       data fields are computed, e.g. <b>ip_frag</b> describes whether a packet is  a
       fragment but it is not copied directly from the IP header.

       Data  fields that are always present as a consequence of the basic net‐
       working technology in use are called called <u>root</u> <u>fields</u>.  Open  vSwitch
       2.7  and earlier considered Ethernet fields to be root fields, and this
       remains the default mode of operation for Open vSwitch bridges. When  a
       packet  is  received  from a non-Ethernet interfaces, such as a layer-3
       LISP tunnel, Open vSwitch 2.7 and earlier force-fit the packet to  this
       Ethernet-centric point of view by pretending that an Ethernet header is
       present whose Ethernet type that indicates  the  packet’s  actual  type
       (and whose source and destination addresses are all-zero).

       Open vSwitch 2.8 and later implement the ``packet type-aware pipeline’’
       concept introduced in OpenFlow 1.5. Such a pipeline does not  have  any
       root  fields. Instead, a new metadata field, <b>packet_type</b>, indicates the
       basic type of the packet, which can be Ethernet, IPv4, IPv6, or another
       type.  For backward compatibility, by default Open vSwitch 2.8 imitates
       the behavior of Open vSwitch 2.7 and earlier. Later  versions  of  Open
       vSwitch  may  change  the  default, and in the meantime controllers can
       turn off this legacy behavior, on a port-by-port basis, by setting  <b>op‐</b>
       <b>tions:packet_type</b>  to  <b>ptap</b> in the <b>Interface</b> table. This is significant
       only for ports that can handle non-Ethernet packets, which is currently
       just  LISP, VXLAN-GPE, and GRE tunnel ports. See <b>ovs-vwitchd.conf.db</b>(5)
       for more information.

       Non-root data fields are not always  present.  A  packet  contains  ARP
       fields,  for example, only when its packet type is ARP or when it is an
       Ethernet packet whose Ethernet header indicates the Ethertype for  ARP,
       0x0806.  In  this documentation, we say that a field is <u>applicable</u> when
       it is present in a packet, and <u>inapplicable</u> when it is not. (These  are
       not  standard terms.) We refer to the conditions that determine whether
       a field is applicable as <u>prerequisites</u>. Some VLAN-related fields are  a
       special  case: these fields are always applicable for Ethernet packets,
       but have a designated value or bit that indicates whether a VLAN header
       is  present,  with  the  remaining  values  or bits indicating the VLAN
       header’s content (if it is present).

       An inapplicable field does  not  have  a  value,  not  even  a  nominal
       ``value’’  such  as  all-zero-bits. In many circumstances, OpenFlow and
       Open vSwitch allow references only to applicable fields.  For  example,
       one may match (see <u>Matching</u>, below) a given field only if the match in‐
       cludes the field’s prerequisite, e.g. matching an ARP field is only al‐
       lowed  if  one  also matches on Ethertype 0x0806 or the <b>packet_type</b> for
       ARP in a packet type-aware bridge.

       Sometimes a packet may contain multiple instances of a header. For  ex‐
       ample,  a packet may contain multiple VLAN or MPLS headers, and tunnels
       can cause any data field to recur. OpenFlow and Open vSwitch do not ad‐
       dress these cases uniformly. For VLAN and MPLS headers, only the outer‐
       most header is accessible, so that inner headers may be  accessed  only
       by ``popping’’ (removing) the outer header. (Open vSwitch supports only
       a single VLAN header in any case.) For tunnels, e.g. GRE or VXLAN,  the
       outer header and inner headers are treated as different data fields.

       Many  network  protocols are built in layers as a stack of concatenated
       headers. Each header typically contains a ``next type’’ field that  in‐
       dicates  the  type  of  the protocol header that follows, e.g. Ethernet
       contains an Ethertype and IPv4 contains a IP protocol type. The  excep‐
       tional  cases,  where protocols are layered but an outer layer does not
       indicate the protocol type for the inner layer, or gives  only  an  am‐
       biguous  indication, are troublesome. An MPLS header, for example, only
       indicates whether another MPLS header or some other  protocol  follows,
       and  in  the latter case the inner protocol must be known from the con‐
       text. In these exceptional cases, OpenFlow and Open vSwitch cannot pro‐
       vide  insight  into  the  inner protocol data fields without additional
       context, and thus they treat all later data fields as inapplicable  un‐
       til  an  OpenFlow action explicitly specifies what protocol follows. In
       the case of MPLS, the OpenFlow ``pop MPLS’’  action  that  removes  the
       last  MPLS header from a packet provides this context, as the Ethertype
       of the payload. See <u>Layer</u> <u>2.5:</u> <u>MPLS</u> for more information.

       OpenFlow and Open vSwitch support some fields other than  data  fields.
       <u>Metadata</u> <u>fields</u> relate to the origin or treatment of a packet, but they
       are not extracted from the packet data itself. One example is the phys‐
       ical  port on which a packet arrived at the switch. <u>Register</u> <u>fields</u> act
       like variables: they give an OpenFlow switch space for temporary  stor‐
       age  while  processing  a packet. Existing metadata and register fields
       have no prerequisites.

       A field’s value consists of an  integral  number  of  bytes.  For  data
       fields, sometimes those bytes are taken directly from the packet. Other
       data fields are copied from a packet with padding (usually  with  zeros
       and  in  the most significant positions). The remaining data fields are
       transformed in other ways as they are copied from the packets, to  make
       them more useful for matching.

   <b>Matching</b>
       The  most important use of fields in OpenFlow is <u>matching</u>, to determine
       whether particular field values agree with a set of constraints  called
       a  <u>match</u>.  A  match  consists of zero or more constraints on individual
       fields, all of which must be met to satisfy the match.  (A  match  that
       contains no constraints is always satisfied.) OpenFlow and Open vSwitch
       support a number of forms of matching on individual fields:

              <u>Exact</u> <u>match</u>, e.g. <b>nw_src=10.1.2.3</b>
                     Only a particular value of the field is matched; for  ex‐
                     ample,  only  one  particular  source  IP  address. Exact
                     matches are written as <u>field</u><b>=</b><u>value</u>.  The  forms  accepted
                     for <u>value</u> depend on the field.

                     All fields support exact matches.

              <u>Bitwise</u> <u>match</u>, e.g. <b>nw_src=10.1.0.0/255.255.0.0</b>
                     Specific  bits  in  the field must have specified values;
                     for example, only source IP  addresses  in  a  particular
                     subnet.  Bitwise matches are written as <u>field</u><b>=</b><u>value</u><b>/</b><u>mask</u>,
                     where <u>value</u> and <u>mask</u> take one of the forms  accepted  for
                     an  exact  match on <u>field</u>. Some fields accept other forms
                     for       bitwise       matches;       for       example,
                     <b>nw_src=10.1.0.0/255.255.0.0</b>    may    also   be   written
                     <b>nw_src=10.1.0.0/16</b>.

                     Most OpenFlow switches do not allow every bitwise  match‐
                     ing on every field (and before OpenFlow 1.2, the protocol
                     did  not  even  provide  for  the  possibility  for  most
                     fields).  Even switches that do allow bitwise matching on
                     a given field may restrict the masks  that  are  allowed,
                     e.g.  by allowing matches only on contiguous sets of bits
                     starting from the most significant bit, that is, ``CIDR’’
                     masks  [RFC  4632].  Open vSwitch does not allows bitwise
                     matching on every field, but it allows arbitrary  bitwise
                     masks  on  any  field that does support bitwise matching.
                     (Older versions had some restrictions, as  documented  in
                     the descriptions of individual fields.)

              <u>Wildcard</u>, e.g. ``any <b>nw_src</b>’’
                     The  value  of  the  field is not constrained. Wildcarded
                     fields may be written as <u>field</u><b>=*</b>, although it is  unusual
                     to  mention  them at all. (When specifying a wildcard ex‐
                     plicitly in a command invocation, be sure to using  quot‐
                     ing to protect against shell expansion.)

                     There  is  a  tiny difference between wildcarding a field
                     and not specifying any match on a  field:  wildcarding  a
                     field requires satisfying the field’s prerequisites.

       Some types of matches on individual fields cannot be expressed directly
       with OpenFlow and Open vSwitch. These can be expressed indirectly:

              <u>Set</u> <u>match</u>, e.g. ``<b>tcp_dst</b> ∈ {80, 443, 8080}’’
                     The value of a field is one of a specified set of values;
                     for  example,  the  TCP  destination  port is 80, 443, or
                     8080.

                     For matches used in flows (see  <u>Flows</u>,  below),  multiple
                     flows can simulate set matches.

              <u>Range</u> <u>match</u>, e.g. ``1000 ≤ <b>tcp_dst</b> ≤ 1999’’
                     The value of the field must lie within a numerical range,
                     for example, TCP destination ports between 1000 and 1999.

                     Range matches can be expressed as a collection of bitwise
                     matches.  For  example, suppose that the goal is to match
                     TCP source ports 1000 to 1999, inclusive. The binary rep‐
                     resentations of 1000 and 1999 are:

                     01111101000
                     11111001111


                     The  following  series of bitwise matches will match 1000
                     and 1999 and all the values in between:

                     01111101xxx
                     0111111xxxx
                     10xxxxxxxxx
                     110xxxxxxxx
                     1110xxxxxxx
                     11110xxxxxx
                     1111100xxxx


                     which can be written as the following matches:

                     <b>tcp,tp_src=0x03e8/0xfff8</b>
                     <b>tcp,tp_src=0x03f0/0xfff0</b>
                     <b>tcp,tp_src=0x0400/0xfe00</b>
                     <b>tcp,tp_src=0x0600/0xff00</b>
                     <b>tcp,tp_src=0x0700/0xff80</b>
                     <b>tcp,tp_src=0x0780/0xffc0</b>
                     <b>tcp,tp_src=0x07c0/0xfff0</b>


              <u>Inequality</u> <u>match</u>, e.g. ``<b>tcp_dst</b> ≠ 80’’
                     The value of the field differs from  a  specified  value,
                     for example, all TCP destination ports except 80.

                     An inequality match on an <u>n</u>-bit field can be expressed as
                     a disjunction of <u>n</u> 1-bit matches. For  example,  the  in‐
                     equality  match  ``<b>vlan_pcp</b>  ≠  5’’  can  be expressed as
                     ``<b>vlan_pcp</b> = 0/4 or <b>vlan_pcp</b> = 2/2 or <b>vlan_pcp</b>  =  0/1.’’
                     For  matches  used in flows (see <u>Flows</u>, below), sometimes
                     one can more compactly express inequality  as  a  higher-
                     priority  flow  that  matches the exceptional case paired
                     with a lower-priority flow that matches the general case.

                     Alternatively, an inequality match may be converted to  a
                     pair of range matches, e.g. <b>tcp_src</b> <b>≠</b> <b>80</b> may be expressed
                     as ``0 ≤ <b>tcp_src</b> &lt; 80 or 80 &lt; <b>tcp_src</b> ≤ 65535’’, and then
                     each  range  match  may in turn be converted to a bitwise
                     match.

              <u>Conjunctive</u> <u>match</u>, e.g. ``<b>tcp_src</b> ∈ {80, 443, 8080} and  <b>tcp_dst</b>
              ∈ {80, 443, 8080}’’
                     As  an OpenFlow extension, Open vSwitch supports matching
                     on conditions on conjunctions of the previously mentioned
                     forms  of matching. See the documentation for <b>conj_id</b> for
                     more information.

       All of these supported forms of matching are special cases  of  bitwise
       matching.  In  some  cases  this influences the design of field values.
       <b>ip_frag</b> is the most prominent example: it is designed to  make  all  of
       the practically useful checks for IP fragmentation possible as a single
       bitwise match.

     <u>Shorthands</u>

       Some matches are very commonly used, so Open vSwitch accepts  shorthand
       notations.  In  some  cases, Open vSwitch also uses shorthand notations
       when it displays matches. The following shorthands  are  defined,  with
       their long forms shown on the right side:

              <b>eth</b>    <b>packet_type=(0,0)</b> (Open vSwitch 2.8 and later)

              <b>ip</b>     <b>eth_type=0x0800</b>

              <b>ipv6</b>   <b>eth_type=0x86dd</b>

              <b>icmp</b>   <b>eth_type=0x0800,ip_proto=1</b>

              <b>icmp6</b>  <b>eth_type=0x86dd,ip_proto=58</b>

              <b>tcp</b>    <b>eth_type=0x0800,ip_proto=6</b>

              <b>tcp6</b>   <b>eth_type=0x86dd,ip_proto=6</b>

              <b>udp</b>    <b>eth_type=0x0800,ip_proto=17</b>

              <b>udp6</b>   <b>eth_type=0x86dd,ip_proto=17</b>

              <b>sctp</b>   <b>eth_type=0x0800,ip_proto=132</b>

              <b>sctp6</b>  <b>eth_type=0x86dd,ip_proto=132</b>

              <b>arp</b>    <b>eth_type=0x0806</b>

              <b>rarp</b>   <b>eth_type=0x8035</b>

              <b>mpls</b>   <b>eth_type=0x8847</b>

              <b>mplsm</b>  <b>eth_type=0x8848</b>

   <b>Evolution</b> <b>of</b> <b>OpenFlow</b> <b>Fields</b>
       The  discussion  so  far  applies to all OpenFlow and Open vSwitch ver‐
       sions. This section starts to draw in specific information by  explain‐
       ing,  in broad terms, the treatment of fields and matches in each Open‐
       Flow version.

     <u>OpenFlow</u> <u>1.0</u>

       OpenFlow 1.0 defined the OpenFlow protocol  format  of  a  match  as  a
       fixed-length data structure that could match on the following fields:

              •      Ingress port.

              •      Ethernet source and destination MAC.

              •      Ethertype (with a special value to match frames that lack
                     an Ethertype).

              •      VLAN ID and priority.

              •      IPv4 source, destination, protocol, and DSCP.

              •      TCP source and destination port.

              •      UDP source and destination port.

              •      ICMPv4 type and code.

              •      ARP IPv4 addresses (SPA and TPA) and opcode.

       Each supported field corresponded to some member of the data structure.
       Some  members represented multiple fields, in the case of the TCP, UDP,
       ICMPv4, and ARP fields whose presence is mutually exclusive. This  also
       meant that some members were poor fits for their fields: only the low 8
       bits of the 16-bit ARP opcode could be represented, and the ICMPv4 type
       and  code were padded with 8 bits of zeros to fit in the 16-bit members
       primarily meant for TCP and UDP ports. An additional bitmap member  in‐
       dicated,  for  each member, whether its field should be an ``exact’’ or
       ``wildcarded’’ match (see <u>Matching</u>), with additional support  for  CIDR
       prefix matching on the IPv4 source and destination fields.

       Simplicity was recognized early on as the main virtue of this approach.
       Obviously, any fixed-length data structure cannot support matching  new
       protocols that do not fit. There was no room, for example, for matching
       IPv6 fields, which was not a priority at the time. Lack of room to sup‐
       port matching the Ethernet addresses inside ARP packets actually caused
       more of a design problem later, leading to an  Open  vSwitch  extension
       action  specialized  for  dropping ``spoofed’’ ARP packets in which the
       frame and ARP Ethernet source addressed differed. (This  extension  was
       never  standardized. Open vSwitch dropped support for it a few releases
       after it added support for full ARP matching.)

       The design of the OpenFlow fixed-length matches also  illustrates  com‐
       promises,  in  both directions, between the strengths and weaknesses of
       software and hardware that have always influenced the design  of  Open‐
       Flow. Support for matching ARP fields that do fit in the data structure
       was only added late in the design process  (and  remained  optional  in
       OpenFlow 1.0), for example, because common switch ASICs did not support
       matching these fields.

       The compromises in favor of software occurred for more complicated rea‐
       sons.  The OpenFlow designers did not know how to implement matching in
       software that was fast, dynamic, and general. (A way  was  later  found
       [Srinivasan].)  Thus,  the designers sought to support dynamic, general
       matching that would be fast in realistic special cases,  in  particular
       when  all of the matches were <u>microflows</u>, that is, matches that specify
       every field present in a packet, because such  matches  can  be  imple‐
       mented  as  a single hash table lookup. Contemporary research supported
       the feasibility of this approach: the number of microflows in a  campus
       network  had  been  measured  to  peak at about 10,000 [Casado, section
       3.2]. (Calculations show that this can only be true in a lightly loaded
       network [Pepelnjak].)

       As  a result, OpenFlow 1.0 required switches to treat microflow matches
       as the highest possible priority. This let  software  switches  perform
       the  microflow  hash table lookup first. Only on failure to match a mi‐
       croflow did the switch need to fall back to checking the  more  general
       and presumed slower matches. Also, the OpenFlow 1.0 flow match was min‐
       imally flexible, with no support for general bitwise  matching,  partly
       on  the basis that this seemed more likely amenable to relatively effi‐
       cient software implementation. (CIDR masking  for  IPv4  addresses  was
       added relatively late in the OpenFlow 1.0 design process.)

       Microflow  matching was later discovered to aid some hardware implemen‐
       tations. The TCAM chips used for matching in hardware  do  not  support
       priority in the same way as OpenFlow but instead tie priority to order‐
       ing [Pagiamtzis]. Thus, adding a new match with a priority between  the
       priorities of existing matches can require reordering an arbitrary num‐
       ber of TCAM entries. On the other hand,  when  microflows  are  highest
       priority,  they  can  be managed as a set-aside portion of the TCAM en‐
       tries.

       The emphasis on matching microflows also  led  designers  to  carefully
       consider  the  bandwidth requirements between switch and controller: to
       maximize the number of microflow setups per second, one  must  minimize
       the size of each flow’s description. This favored the fixed-length for‐
       mat in use, because it expressed common TCP and UDP microflows in fewer
       bytes  than  more  flexible ``type-length-value’’ (TLV) formats. (Early
       versions of OpenFlow also avoided TLVs in general to head off  protocol
       fragmentation.)

       <u>Inapplicable</u> <u>Fields</u>

       OpenFlow 1.0 does not clearly specify how to treat inapplicable fields.
       The members for inapplicable fields are always  present  in  the  match
       data  structure,  as  are the bits that indicate whether the fields are
       matched, and the ``correct’’ member and  bit  values  for  inapplicable
       fields  is unclear. OpenFlow 1.0 implementations changed their behavior
       over time as priorities shifted. The early OpenFlow reference implemen‐
       tation,  motivated  to  make  every flow a microflow to enable hashing,
       treated inapplicable fields as exact matches on  a  value  of  0.  Ini‐
       tially, this behavior was implemented in the reference controller only.

       Later,  the  reference  switch  was  also changed to actually force any
       wildcarded inapplicable fields into exact matches on 0. The latter  be‐
       havior sometimes caused problems, because the modified flow was the one
       reported back to the controller later when it queried the  flow  table,
       and  the  modifications  sometimes  meant that the controller could not
       properly recognize the flow that it had added. In  retrospect,  perhaps
       this  problem  should have alerted the designers to a design error, but
       the ability to use a single hash table was held to  be  more  important
       than almost every other consideration at the time.

       When  more flexible match formats were introduced much later, they dis‐
       allowed any mention of inapplicable fields as part  of  a  match.  This
       raised the question of how to translate between this new format and the
       OpenFlow 1.0 fixed format. It seemed somewhat inconsistent and backward
       to  treat  fields as exact-match in one format and forbid matching them
       in the other, so instead the treatment of inapplicable  fields  in  the
       fixed-length  format  was changed from exact match on 0 to wildcarding.
       (A better classifier had by now eliminated software  performance  prob‐
       lems with wildcards.)

       The OpenFlow 1.0.1 errata (released only in 2012) added some additional
       explanation [OpenFlow 1.0.1, section 3.4], but it did not mandate  spe‐
       cific behavior because of variation among implementations.

     <u>OpenFlow</u> <u>1.1</u>

       The   OpenFlow   1.1   protocol   match   format   was  designed  as  a
       type/length/value (TLV) format to allow  for  future  flexibility.  The
       specification standardized only a single type <b>OFPMT_STANDARD</b> (0) with a
       fixed-size payload, described here. The additional fields  and  bitwise
       masks  in  OpenFlow  1.1 cause this match structure to be over twice as
       large as in OpenFlow 1.0, 88 bytes versus 40.

       OpenFlow 1.1 added support for the following fields:

              •      SCTP source and destination port.

              •      MPLS label and traffic control (TC) fields.

              •      One 64-bit register (named ``metadata’’).

       OpenFlow 1.1 increased the width of the ingress port number field  (and
       all other port numbers in the protocol) from 16 bits to 32 bits.

       OpenFlow  1.1  increased  matching flexibility by introducing arbitrary
       bitwise matching on Ethernet and IPv4 address fields  and  on  the  new
       ``metadata’’  register field. Switches were not required to support all
       possible masks [OpenFlow 1.1, section 4.3].

       By a strict reading of the specification, OpenFlow 1.1 removed  support
       for  matching  ICMPv4  type and code [OpenFlow 1.1, section A.2.3], but
       this is likely an editing error  because  ICMP  matching  is  described
       elsewhere [OpenFlow 1.1, Table 3, Table 4, Figure 4]. Open vSwitch does
       support ICMPv4 type and code matching with OpenFlow 1.1.

       OpenFlow 1.1 avoided the pitfalls of inapplicable fields that  OpenFlow
       1.0  encountered, by requiring the switch to ignore the specified field
       values [OpenFlow 1.1, section A.2.3]. It also implied that  the  switch
       should  ignore  the  bits  that  indicate whether to match inapplicable
       fields.

       <u>Physical</u> <u>Ingress</u> <u>Port</u>

       OpenFlow 1.1 introduced a new pseudo-field, the physical ingress  port.
       The  physical  ingress port is only a pseudo-field because it cannot be
       used for matching. It appears only one place in the  protocol,  in  the
       ``packet-in’’ message that passes a packet received at the switch to an
       OpenFlow controller.

       A packet’s ingress port and physical ingress port are identical  except
       for  packets processed by a switch feature such as bonding or tunneling
       that makes a packet appear to arrive on a ``virtual’’  port  associated
       with  the bond or the tunnel. For such packets, the ingress port is the
       virtual port and the physical ingress port is, naturally, the  physical
       port. Open vSwitch implements both bonding and tunneling, but its bond‐
       ing implementation does not use virtual ports and its tunnels are typi‐
       cally  not  on the same OpenFlow switch as their physical ingress ports
       (which need not be part of any switch), so the ingress port and  physi‐
       cal ingress port are always the same in Open vSwitch.

     <u>OpenFlow</u> <u>1.2</u>

       OpenFlow  1.2 abandoned the fixed-length approach to matching. One rea‐
       son was size, since adding support for IPv6 address matching (now  seen
       as  important),  with  bitwise  masks, would have added 64 bytes to the
       match length, increasing it from 88 bytes in OpenFlow 1.1 to  over  150
       bytes.  Extensibility  had  also become important as controller writers
       increasingly wanted support for new fields  without  having  to  change
       messages  throughout the OpenFlow protocol. The challenges of carefully
       defining fixed-length  matches  to  avoid  problems  with  inapplicable
       fields had also become clear over time.

       Therefore,  OpenFlow  1.2  adopted a flow format using a flexible type-
       length-value (TLV) representation, in which each TLV expresses a  match
       on one field. These TLVs were in turn encapsulated inside the outer TLV
       wrapper introduced in OpenFlow 1.1 with the  new  identifier  <b>OFPMT_OXM</b>
       (1).  (This  wrapper  fulfilled  its  intended  purpose of reducing the
       amount of churn in the protocol when changing match formats; some  mes‐
       sages that included matches remained unchanged from OpenFlow 1.1 to 1.2
       and later versions.)

       OpenFlow 1.2 added support for the following fields:

              •      ARP hardware addresses (SHA and THA).

              •      IPv4 ECN.

              •      IPv6 source and destination addresses, flow label,  DSCP,
                     ECN, and protocol.

              •      TCP,  UDP, and SCTP port numbers when encapsulated inside
                     IPv6.

              •      ICMPv6 type and code.

              •      ICMPv6 Neighbor Discovery target address and  source  and
                     target Ethernet addresses.

       The  OpenFlow  1.2  format, called <u>OXM</u> (<u>OpenFlow</u> <u>Extensible</u> <u>Match</u>), was
       modeled closely on an extension to  OpenFlow  1.0  introduced  in  Open
       vSwitch 1.1 called <u>NXM</u> (<u>Nicira</u> <u>Extended</u> <u>Match</u>). Each OXM or NXM TLV has
       the following format:

               type
        &lt;----------------&gt;
             16        7   1    8      length bytes
       +------------+-----+--+------+ +------------+
       |vendor/class|field|HM|length| |    body    |
       +------------+-----+--+------+ +------------+


       The most significant 16 bits of the NXM or OXM header, called <b>vendor</b> by
       NXM  and  <b>class</b>  by OXM, identify an organization permitted to allocate
       identifiers for fields. NXM allocates  only  two  vendors,  0x0000  for
       fields  supported  by OpenFlow 1.0 and 0x0001 for fields implemented as
       an Open vSwitch extension. OXM assigns classes as follows:

              0x0000 (<b>OFPXMC_NXM_0</b>).
              0x0001 (<b>OFPXMC_NXM_1</b>).
                   Reserved for NXM compatibility.

              0x0002 to 0x7fff
                   Reserved for allocation to ONF members, but  none  yet  as‐
                   signed.

              0x8000 (<b>OFPXMC_OPENFLOW_BASIC</b>)
                   Used for most standard OpenFlow fields.

              0x8001 (<b>OFPXMC_PACKET_REGS</b>)
                   Used for packet register fields in OpenFlow 1.5 and later.

              0x8002 to 0xfffe
                   Reserved for the OpenFlow specification.

              0xffff (<b>OFPXMC_EXPERIMENTER</b>)
                   Experimental use.

       When  <b>class</b>  is  0xffff, the OXM header is extended to 64 bits by using
       the first 32 bits of the body as an <b>experimenter</b> field whose most  sig‐
       nificant byte is zero and whose remaining bytes are an Organizationally
       Unique Identifier (OUI) assigned by the IEEE [IEEE OUI], as  shown  be‐
       low.

            type                 experimenter
        &lt;----------&gt;             &lt;----------&gt;
          16     7   1    8        8     24     (length - 4) bytes
       +------+-----+--+------+ +------+-----+ +------------------+
       |class |field|HM|length| | zero | OUI | |       body       |
       +------+-----+--+------+ +------+-----+ +------------------+
        0xffff                    0x00


       OpenFlow  says  that  support for experimenter fields is optional. Open
       vSwitch 2.4 and later does support them, so that  it  can  support  the
       following experimenter classes:

              0x4f4e4600 (<b>ONFOXM_ET</b>)
                     Used by official Open Networking Foundation extensions in
                     OpenFlow 1.3 and later. e.g. [TCP Flags Match  Field  Ex‐
                     tension].

              0x005ad650 (<b>NXOXM_NSH</b>)
                     Used  by  Open vSwitch for NSH extensions, in the absence
                     of an official ONF-assigned class. (This OUI is  randomly
                     generated.)

       Taken  as  a  unit,  <b>class</b>  (or  <b>vendor</b>), <b>field</b>, and <b>experimenter</b> (when
       present) uniquely identify a particular field.

       When <b>hasmask</b> (abbreviated <b>HM</b> above) is 0, the OXM is an exact match  on
       an  entire  field.  In  this case, the body (excluding the experimenter
       field, if present) is a single value to be matched.

       When <b>hasmask</b> is 1, the OXM is a bitwise match. The body (excluding  the
       experimenter  field) consists of a value to match, followed by the bit‐
       wise mask to apply. A 1-bit in the mask indicates that the  correspond‐
       ing  bit  in  the value should be matched and a 0-bit that it should be
       ignored. For example, for an IP address field, a value  of  192.168.0.0
       followed  by  a  mask  of  255.255.0.0  would  match  addresses  in the
       196.168.0.0/16 subnet.

              •      Some fields might not support masking at  all,  and  some
                     fields  that do support masking might restrict it to cer‐
                     tain patterns. For example, fields that have  IP  address
                     values  might  be  restricted to CIDR masks. The descrip‐
                     tions of individual fields note these restrictions.

              •      An OXM TLV with a mask that is all zeros  is  not  useful
                     (although  it  is  not  forbidden), because it is has the
                     same effect as omitting the TLV entirely.

              •      It is not meaningful to pair a 0-bit in an OXM mask  with
                     a  1-bit  in  its value, and Open vSwitch rejects such an
                     OXM with the error <b>OFPBMC_BAD_WILDCARDS</b>, as  required  by
                     OpenFlow 1.3 and later.

       The  <b>length</b>  identifies  the number of bytes in the body, including the
       4-byte <b>experimenter</b> header, if it is present. Each OXM TLV has a  fixed
       length;  that  is,  given  <b>class</b>, <b>field</b>, <b>experimenter</b> (if present), and
       <b>hasmask</b>, <b>length</b> is a constant. The <b>length</b> is included explicitly to al‐
       low software to minimally parse OXM TLVs of unknown types.

       OXM  TLVs must be ordered so that a field’s prerequisites are satisfied
       before it is parsed. For example, an OXM TLV that matches on  the  IPv4
       source  address field is only allowed following an OXM TLV that matches
       on the Ethertype for IPv4. Similarly, an OXM TLV that  matches  on  the
       TCP  source port must follow a TLV that matches an Ethertype of IPv4 or
       IPv6 and one that matches an IP protocol of TCP (in  that  order).  The
       order of OXM TLVs is not otherwise restricted; no canonical ordering is
       defined.

       A given field may be matched only once in a series of OXM TLVs.

     <u>OpenFlow</u> <u>1.3</u>

       OpenFlow 1.3 showed OXM to be largely successful, by adding new  fields
       without  making  any  changes  to how flow matches otherwise worked. It
       added OXMs for the following fields supported by Open vSwitch:

              •      Tunnel ID for ports associated with e.g. VXLAN  or  keyed
                     GRE.

              •      MPLS ``bottom of stack’’ (BOS) bit.

       OpenFlow  1.3  also  added OXMs for the following fields not documented
       here and not yet implemented by Open vSwitch:

              •      IPv6 extension header handling.

              •      PBB I-SID.

     <u>OpenFlow</u> <u>1.4</u>

       OpenFlow 1.4 added OXMs for the following fields  not  documented  here
       and not yet implemented by Open vSwitch:

              •      PBB UCA.

     <u>OpenFlow</u> <u>1.5</u>

       OpenFlow  1.5  added  OXMs  for  the following fields supported by Open
       vSwitch:

              •      Packet type.

              •      TCP flags.

              •      Packet registers.

              •      The output port in the OpenFlow action set.

<b>FIELDS</b> <b>REFERENCE</b>
       The following sections document the fields that Open vSwitch  supports.
       Each  section  provides  introductory  material  on  a group of related
       fields, followed by information on each individual field.  In  addition
       to  field-specific information, each field begins with a table with en‐
       tries for the following important properties:

              Name   The field’s name, used for  parsing  and  formatting  the
                     field,  e.g.  in  <b>ovs-ofctl</b> commands. For historical rea‐
                     sons, some fields have an additional  name  that  is  ac‐
                     cepted  as  an  alternative  in  parsing. This name, when
                     there is one, is listed as well,  e.g.  ``<b>tun</b>  (aka  <b>tun‐</b>
                     <b>nel_id</b>).’’

              Width  The  field’s  width,  always  a  multiple of 8 bits. Some
                     fields don’t use all of the bits, so this may be accompa‐
                     nied  by an explanation. For example, OpenFlow embeds the
                     2-bit IP ECN field as as the low bits in an  8-bit  byte,
                     and  so  its  width  is  expressed  as ``8 bits (only the
                     least-significant 2 bits may be nonzero).’’

              Format How a value for the field  is  formatted  or  parsed  by,
                     e.g., <b>ovs-ofctl</b>. Some possibilities are generic:

                     decimal
                            Formats  as  a  decimal  number. On input, accepts
                            decimal numbers or hexadecimal numbers prefixed by
                            <b>0x</b>.

                     hexadecimal
                            Formats as a hexadecimal number prefixed by <b>0x</b>. On
                            input, accepts decimal numbers or hexadecimal num‐
                            bers  prefixed  by <b>0x</b>. (The default for parsing is
                            <b>not</b> hexadecimal: only a <b>0x</b> prefix causes input  to
                            be treated as hexadecimal.)

                     Ethernet
                            Formats  and  accepts  the common Ethernet address
                            format <u>xx</u><b>:</b><u>xx</u><b>:</b><u>xx</u><b>:</b><u>xx</u><b>:</b><u>xx</u><b>:</b><u>xx</u>.

                     IPv4   Formats  and  accepts   the   dotted-quad   format
                            <u>a</u><b>.</b><u>b</u><b>.</b><u>c</u><b>.</b><u>d</u>.  For bitwise matches, formats and accepts
                            <u>address</u><b>/</b><u>length</u> CIDR notation in  addition  to  <u>ad‐</u>
                            <u>dress</u><b>/</b><u>mask</u>.

                     IPv6   Formats  and  accepts the common IPv6 address for‐
                            mats, plus CIDR notation for bitwise matches.

                     OpenFlow 1.0 port
                            Accepts 16-bit port numbers in decimal, plus Open‐
                            Flow  well-known  port names (e.g. <b>IN_PORT</b>) in up‐
                            percase or lowercase.

                     OpenFlow 1.1+ port
                            Same syntax as OpenFlow 1.0 ports but  for  32-bit
                            OpenFlow 1.1+ port number fields.

                     Other,  field-specific  formats  are explained along with
                     their fields.

              Masking
                     For most fields, this says ``arbitrary  bitwise  masks,’’
                     meaning  that a flow may match any combination of bits in
                     the field. Some fields instead say ``exact match  only,’’
                     which  means  that a flow that matches on this field must
                     match on the whole field instead of  just  certain  bits.
                     Either  way,  this reports masking support for the latest
                     version of Open vSwitch using OXM or NXM (that is, either
                     OpenFlow  1.2+  or OpenFlow 1.0 plus Open vSwitch NXM ex‐
                     tensions). In particular, OpenFlow 1.0 (without NXM)  and
                     1.1 don’t always support masking even if Open vSwitch it‐
                     self does; refer to the <b>OpenFlow</b>  <b>1.0</b>  and  <b>OpenFlow</b>  <b>1.1</b>
                     rows to learn about masking with these protocol versions.

              Prerequisites
                     Requirements that must be met to match on this field. For
                     example, <b>ip_src</b> has IPv4 as a prerequisite, meaning  that
                     a match must include <b>eth_type=0x0800</b> to match on the IPv4
                     source address. The following prerequisites,  with  their
                     requirements, are currently in use:

                     none   (no requirements)

                     VLAN VID
                            <b>vlan_tci=0x1000/0x1000</b>  (i.e.  a  VLAN  header  is
                            present)

                     ARP    <b>eth_type=0x0806</b> (ARP) or <b>eth_type=0x8035</b> (RARP)

                     IPv4   <b>eth_type=0x0800</b>

                     IPv6   <b>eth_type=0x86dd</b>

                     IPv4/IPv6
                            IPv4 or IPv6

                     MPLS   <b>eth_type=0x8847</b> or <b>eth_type=0x8848</b>

                     TCP    IPv4/IPv6 and <b>ip_proto=6</b>

                     UDP    IPv4/IPv6 and <b>ip_proto=17</b>

                     SCTP   IPv4/IPv6 and <b>ip_proto=132</b>

                     ICMPv4 IPv4 and <b>ip_proto=1</b>

                     ICMPv6 IPv6 and <b>ip_proto=58</b>

                     ND solicit
                            ICMPv6 and <b>icmp_type=135</b> and <b>icmp_code=0</b>

                     ND advert
                            ICMPv6 and <b>icmp_type=136</b> and <b>icmp_code=0</b>

                     ND     ND solicit or ND advert

                     The TCP, UDP, and SCTP prerequisites also have  the  spe‐
                     cial requirement that <b>nw_frag</b> is not being used to select
                     ``later fragments.’’ This is because only the first frag‐
                     ment  of  a fragmented IPv4 or IPv6 datagram contains the
                     TCP or UDP header.

              Access Most fields are ``read/write,’’ which means  that  common
                     OpenFlow  actions  like <b>set_field</b> can modify them. Fields
                     that are ``read-only’’ cannot be modified in  these  gen‐
                     eral-purpose  ways, although there may be other ways that
                     actions can modify them.

              OpenFlow 1.0
              OpenFlow 1.1
                   These rows report the level of support that OpenFlow 1.0 or
                   OpenFlow  1.1,  respectively, has for a field. For OpenFlow
                   1.0, supported fields are reported as either  ``yes  (exact
                   match  only)’’  for  fields that do not support any bitwise
                   masking or ``yes (CIDR match only)’’ for fields  that  sup‐
                   port CIDR masking. OpenFlow 1.1 supported fields report ei‐
                   ther ``yes (exact  match  only)’’  or  simply  ``yes’’  for
                   fields that do support arbitrary masks. These OpenFlow ver‐
                   sions supported a fixed collection of fields that cannot be
                   extended,  so  many  more fields are reported as ``not sup‐
                   ported.’’

              OXM
              NXM  These rows report the OXM and NXM code points  that  corre‐
                   spond to a given field. Either or both may be ``none.’’

                   A field that has only an OXM code point is usually one that
                   was standardized before it was added  to  Open  vSwitch.  A
                   field  that  has only an NXM code point is usually one that
                   is not yet standardized. When a field has both OXM and  NXM
                   code points, it usually indicates that it was introduced as
                   an Open vSwitch extension under the NXM  code  point,  then
                   later  standardized  under  the OXM code point. A field can
                   have more than one OXM code point if it was standardized in
                   OpenFlow 1.4 or later and additionally introduced as an of‐
                   ficial ONF extension for OpenFlow 1.3. (A  field  that  has
                   neither  OXM  nor  NXM  code point is typically an obsolete
                   field that is supported in some other  form  using  OXM  or
                   NXM.)

                   Each  code  point  in  these  rows is described in the form
                   ``<b>NAME</b> (<u>number</u>) since OpenFlow <u>spec</u> and Open  vSwitch  <u>ver‐</u>
                   <u>sion</u>,’’  e.g.  ``<b>OXM_OF_ETH_TYPE</b> (5) since OpenFlow 1.2 and
                   Open vSwitch 1.7.’’ First, <b>NAME</b>, which specifies a name for
                   the  code  point,  starts  with  a prefix that designates a
                   class and, in some cases, a vendor, as listed in  the  fol‐
                   lowing table:

                   Prefix           Vendor       Class
                   ───────────────  ───────────  ───────
                   <b>NXM_OF</b>           (none)       0x0000
                   <b>NXM_NX</b>           (none)       0x0001
                   <b>ERICOXM_OF</b>       (none)       0x1000
                   <b>OXM_OF</b>           (none)       0x8000
                   <b>OXM_OF_PKT_REG</b>   (none)       0x8001
                   <b>NXOXM_ET</b>         0x00002320   0xffff
                   <b>NXOXM_NSH</b>        0x005ad650   0xffff
                   <b>ONFOXM_ET</b>        0x4f4e4600   0xffff

                   For  more information on OXM/NXM classes and vendors, refer
                   back to <b>OpenFlow</b> <b>1.2</b> under <b>Evolution</b>  <b>of</b>  <b>OpenFlow</b>  <b>Fields</b>.
                   The <u>number</u> is the field number within the class and vendor.
                   The OpenFlow <u>spec</u> is the version of OpenFlow that standard‐
                   ized  the code point. It is omitted for NXM code points be‐
                   cause they are nonstandard. The <u>version</u> is the  version  of
                   Open vSwitch that first supported the code point.

<b>CONJUNCTIVE</b> <b>MATCH</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name      Bytes   Mask   RW?   Prereqs   NXM/OXM Support
       ────────  ──────  ─────  ────  ────────  ────────────────
       <b>conj_id</b>   4       no     no    none      OVS 2.4+

       An  individual  OpenFlow  flow  can  match only a single value for each
       field. However, situations often arise where one wants to match one  of
       a  set  of values within a field or fields. For matching a single field
       against a set, it is straightforward  and  efficient  to  add  multiple
       flows  to  the  flow table, one for each value in the set. For example,
       one might use the following flows to send packets with  IP  source  ad‐
       dress <u>a</u>, <u>b</u>, <u>c</u>, or <u>d</u> to the OpenFlow controller:

             <b>ip,ip_src=</b><u>a</u> actions=controller
             <b>ip,ip_src=</b><u>b</u> actions=controller
             <b>ip,ip_src=</b><u>c</u> actions=controller
             <b>ip,ip_src=</b><u>d</u> actions=controller


       Similarly,  these  flows send packets with IP destination address <u>e</u>, <u>f</u>,
       <u>g</u>, or <u>h</u> to the OpenFlow controller:

             <b>ip,ip_dst=</b><u>e</u> actions=controller
             <b>ip,ip_dst=</b><u>f</u> actions=controller
             <b>ip,ip_dst=</b><u>g</u> actions=controller
             <b>ip,ip_dst=</b><u>h</u> actions=controller


       Installing all of the above flows in a single flow table yields a  dis‐
       junctive  effect:  a  packet  is  sent  to  the  controller if <b>ip_src</b> ∈
       {<u>a</u>,<u>b</u>,<u>c</u>,<u>d</u>} or <b>ip_dst</b> ∈ {<u>e</u>,<u>f</u>,<u>g</u>,<u>h</u>} (or both). (Pedantically,  if  both  of
       the above sets of flows are present in the flow table, they should have
       different priorities, because OpenFlow says that the results are  unde‐
       fined  when  two  flows  with  same  priority  can  both match a single
       packet.)

       Suppose, on the other hand, one wishes to match conjunctively, that is,
       to  send a packet to the controller only if both <b>ip_src</b> ∈ {<u>a</u>,<u>b</u>,<u>c</u>,<u>d</u>} and
       <b>ip_dst</b> ∈ {<u>e</u>,<u>f</u>,<u>g</u>,<u>h</u>}. This requires 4 × 4 = 16 flows, one for each possi‐
       ble  pairing of <b>ip_src</b> and <b>ip_dst</b>. That is acceptable for our small ex‐
       ample, but it does not gracefully extend to larger sets or greater num‐
       bers of dimensions.

       The  <b>conjunction</b>  action  is a solution for conjunctive matches that is
       built into Open vSwitch. A <b>conjunction</b> action ties groups of individual
       OpenFlow flows into higher-level ``conjunctive flows’’. Each group cor‐
       responds to one dimension, and each flow within the group  matches  one
       possible  value  for the dimension. A packet that matches one flow from
       each group matches the conjunctive flow.

       To implement a conjunctive flow with <b>conjunction</b>, assign  the  conjunc‐
       tive  flow  a 32-bit <u>id</u>, which must be unique within an OpenFlow table.
       Assign each of the <u>n</u> ≥ 2 dimensions a unique number from 1  to  <u>n</u>;  the
       ordering  is  unimportant.  Add one flow to the OpenFlow flow table for
       each possible value of each dimension with <b>conjunction(</b><u>id</u><b>,</b> <u>k</u><b>/</b><u>n</u><b>)</b> as  the
       flow’s actions, where <u>k</u> is the number assigned to the flow’s dimension.
       Together, these flows specify the conjunctive flow’s  match  condition.
       When  the conjunctive match condition is met, Open vSwitch looks up one
       more flow that specifies the conjunctive flow’s  actions  and  receives
       its  statistics. This flow is found by setting <b>conj_id</b> to the specified
       <u>id</u> and then again searching the flow table.

       The following flows provide an example. Whenever the IP source  is  one
       of  the values in the flows that match on the IP source (dimension 1 of
       2), <b>and</b> the IP destination is one of the values in the flows that match
       on  IP destination (dimension 2 of 2), Open vSwitch searches for a flow
       that matches <b>conj_id</b> against the conjunction  ID  (1234),  finding  the
       first flow listed below.

             <b>conj_id=1234</b> <b>actions=controller</b>
             <b>ip,ip_src=10.0.0.1</b> <b>actions=conjunction(1234,</b> <b>1/2)</b>
             <b>ip,ip_src=10.0.0.4</b> <b>actions=conjunction(1234,</b> <b>1/2)</b>
             <b>ip,ip_src=10.0.0.6</b> <b>actions=conjunction(1234,</b> <b>1/2)</b>
             <b>ip,ip_src=10.0.0.7</b> <b>actions=conjunction(1234,</b> <b>1/2)</b>
             <b>ip,ip_dst=10.0.0.2</b> <b>actions=conjunction(1234,</b> <b>2/2)</b>
             <b>ip,ip_dst=10.0.0.5</b> <b>actions=conjunction(1234,</b> <b>2/2)</b>
             <b>ip,ip_dst=10.0.0.7</b> <b>actions=conjunction(1234,</b> <b>2/2)</b>
             <b>ip,ip_dst=10.0.0.8</b> <b>actions=conjunction(1234,</b> <b>2/2)</b>


       Many subtleties exist:

              •      In  the  example  above, every flow in a single dimension
                     has the same form, that is, dimension 1 matches on <b>ip_src</b>
                     and dimension 2 on <b>ip_dst</b>, but this is not a requirement.
                     Different flows within a dimension may match on different
                     bits  within a field (e.g. IP network prefixes of differ‐
                     ent lengths, or TCP/UDP port ranges as bitwise  matches),
                     or even on entirely different fields (e.g. to match pack‐
                     ets for TCP source port 80 or TCP destination port 80).

              •      The flows within  a  dimension  can  vary  their  matches
                     across  more  than one field, e.g. to match only specific
                     pairs of IP source and destination addresses or  L4  port
                     numbers.

              •      A  flow  may have multiple <b>conjunction</b> actions, with dif‐
                     ferent <b>id</b> values. This is useful for multiple conjunctive
                     flows  with  overlapping  sets.  If  one conjunctive flow
                     matches packets with both <b>ip_src</b> ∈  {<u>a</u>,<u>b</u>}  and  <b>ip_dst</b>  ∈
                     {<u>d</u>,<u>e</u>}  and  a  second  conjunctive  flow matches <b>ip_src</b> ∈
                     {<u>b</u>,<u>c</u>} and <b>ip_dst</b> ∈ {<u>f</u>,<u>g</u>}, for example, then the flow that
                     matches  <b>ip_src=</b><u>b</u> would have two <b>conjunction</b> actions, one
                     for each conjunctive flow. The order of  <b>conjunction</b>  ac‐
                     tions within a list of actions is not significant.

              •      A flow with <b>conjunction</b> actions may also include <b>note</b> ac‐
                     tions for annotations, but not any other kind of actions.
                     (They would not be useful because they would never be ex‐
                     ecuted.)

              •      All of the flows that constitute a conjunctive flow  with
                     a  given  <u>id</u> must have the same priority. (Flows with the
                     same <u>id</u> but different priorities are currently treated as
                     different conjunctive flows, that is, currently <u>id</u> values
                     need only be unique within an OpenFlow table at  a  given
                     priority. This behavior isn’t guaranteed to stay the same
                     in later releases, so please use <u>id</u> values unique  within
                     an OpenFlow table.)

              •      Conjunctive  flows must not overlap with each other, at a
                     given priority, that is, any given packet must be able to
                     match  at  most one conjunctive flow at a given priority.
                     Overlapping conjunctive  flows  yield  unpredictable  re‐
                     sults.  (The flows that constitute a conjunctive flow may
                     overlap with those that constitute the  same  or  another
                     conjunctive flow.)

              •      Following  a  conjunctive  flow match, the search for the
                     flow with <b>conj_id=</b><u>id</u> is done in the same  general-purpose
                     way  as  other  flow table searches, so one can use flows
                     with <b>conj_id=</b><u>id</u> to act differently depending  on  circum‐
                     stances.  (One  exception  is  that  the  search  for the
                     <b>conj_id=</b><u>id</u> flow  itself  ignores  conjunctive  flows,  to
                     avoid  recursion.)  If  the search with <b>conj_id=</b><u>id</u> fails,
                     Open vSwitch acts as if  the  conjunctive  flow  had  not
                     matched  at  all,  and continues searching the flow table
                     for other matching flows.

              •      OpenFlow prerequisite checking occurs for the  flow  with
                     <b>conj_id=</b><u>id</u>  in the same way as any other flow, e.g. in an
                     OpenFlow 1.1+ context, putting a <b>mod_nw_src</b>  action  into
                     the  example above would require adding an <b>ip</b> match, like
                     this:

                               <b>conj_id=1234,ip</b> <b>actions=mod_nw_src:1.2.3.4,controller</b>


              •      OpenFlow prerequisite checking also occurs for the  indi‐
                     vidual  flows  that  comprise  a conjunctive match in the
                     same way as any other flow.

              •      The flows that constitute a conjunctive flow do not  have
                     useful  statistics.  They  are never updated with byte or
                     packet counts, and so on. (For such  a  flow,  therefore,
                     the idle and hard timeouts work much the same way.)

              •      Sometimes there is a choice of which flows include a par‐
                     ticular match. For example, suppose that we added an  ex‐
                     tra  constraint  to  our  example,  to  match on <b>ip_src</b> ∈
                     {<u>a</u>,<u>b</u>,<u>c</u>,<u>d</u>} and <b>ip_dst</b> ∈ {<u>e</u>,<u>f</u>,<u>g</u>,<u>h</u>} and <b>tcp_dst</b> = <u>i</u>. One way
                     to  implement  this  is  to add the new constraint to the
                     <b>conj_id</b> flow, like this:

                               <b>conj_id=1234,tcp,tcp_dst=</b><u>i</u> actions=mod_nw_src:1.2.3.4,controller


                     but <b>this</b> <b>is</b> <b>not</b> <b>recommended</b> because of the  cost  of  the
                     extra  flow  table lookup. Instead, add the constraint to
                     the individual flows, either in one of the dimensions  or
                     (slightly better) all of them.

              •      A conjunctive match must have <u>n</u> ≥ 2 dimensions (otherwise
                     a conjunctive match is not necessary). Open  vSwitch  en‐
                     forces this.

              •      Each dimension within a conjunctive match should ordinar‐
                     ily have more than one flow. Open vSwitch  does  not  en‐
                     force this.

       <b>Conjunction</b> <b>ID</b> <b>Field</b>

       Name:            <b>conj_id</b>
       Width:           32 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   none
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             none
       NXM:             <b>NXM_NX_CONJ_ID</b> (37) since Open vSwitch 2.4

       Used for conjunctive matching. See above for more information.

<b>TUNNEL</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name                   Bytes             Mask   RW?   Prereqs   NXM/OXM Support

       ─────────────────────  ────────────────  ─────  ────  ────────  ─────────────────────
       <b>tun_id</b> aka <b>tunnel_id</b>   8                 yes    yes   none      OF 1.3+ and OVS 1.1+
       <b>tun_src</b>                4                 yes    yes   none      OVS 2.0+
       <b>tun_dst</b>                4                 yes    yes   none      OVS 2.0+

       <b>tun_ipv6_src</b>           16                yes    yes   none      OVS 2.5+
       <b>tun_ipv6_dst</b>           16                yes    yes   none      OVS 2.5+
       <b>tun_gbp_id</b>             2                 yes    yes   none      OVS 2.4+
       <b>tun_gbp_flags</b>          1                 yes    yes   none      OVS 2.4+

       <b>tun_erspan_ver</b>         1 (low 4 bits)    yes    yes   none      OVS 2.10+
       <b>tun_erspan_idx</b>         4 (low 20 bits)   yes    yes   none      OVS 2.10+
       <b>tun_erspan_dir</b>         1 (low 1 bits)    yes    yes   none      OVS 2.10+
       <b>tun_erspan_hwid</b>        1 (low 6 bits)    yes    yes   none      OVS 2.10+

       <b>tun_gtpu_flags</b>         1                 yes    no    none      OVS 2.13+
       <b>tun_gtpu_msgtype</b>       1                 yes    no    none      OVS 2.13+
       <b>tun_metadata0</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata1</b>          124               yes    yes   none      OVS 2.5+

       <b>tun_metadata2</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata3</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata4</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata5</b>          124               yes    yes   none      OVS 2.5+

       <b>tun_metadata6</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata7</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata8</b>          124               yes    yes   none      OVS 2.5+
       <b>tun_metadata9</b>          124               yes    yes   none      OVS 2.5+

       <b>tun_metadata10</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata11</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata12</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata13</b>         124               yes    yes   none      OVS 2.5+

       <b>tun_metadata14</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata15</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata16</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata17</b>         124               yes    yes   none      OVS 2.5+

       <b>tun_metadata18</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata19</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata20</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata21</b>         124               yes    yes   none      OVS 2.5+

       <b>tun_metadata22</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata23</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata24</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata25</b>         124               yes    yes   none      OVS 2.5+

       <b>tun_metadata26</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata27</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata28</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata29</b>         124               yes    yes   none      OVS 2.5+

       <b>tun_metadata30</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata31</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata32</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata33</b>         124               yes    yes   none      OVS 2.5+

       <b>tun_metadata34</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata35</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata36</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata37</b>         124               yes    yes   none      OVS 2.5+

       <b>tun_metadata38</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata39</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata40</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata41</b>         124               yes    yes   none      OVS 2.5+

       <b>tun_metadata42</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata43</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata44</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata45</b>         124               yes    yes   none      OVS 2.5+

       <b>tun_metadata46</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata47</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata48</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata49</b>         124               yes    yes   none      OVS 2.5+

       <b>tun_metadata50</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata51</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata52</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata53</b>         124               yes    yes   none      OVS 2.5+

       <b>tun_metadata54</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata55</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata56</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata57</b>         124               yes    yes   none      OVS 2.5+

       <b>tun_metadata58</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata59</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata60</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata61</b>         124               yes    yes   none      OVS 2.5+

       <b>tun_metadata62</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_metadata63</b>         124               yes    yes   none      OVS 2.5+
       <b>tun_flags</b>              2 (low 1 bits)    yes    yes   none      OVS 2.5+

       The fields in this group relate to tunnels, which Open vSwitch supports
       in several forms (GRE, VXLAN, and so on). Most of these fields  do  ap‐
       pear  in the wire format of a packet, so they are data fields from that
       point of view, but they are metadata from an OpenFlow flow table  point
       of view because they do not appear in packets that are forwarded to the
       controller or to ordinary (non-tunnel) output ports.

       Open vSwitch supports a spectrum of usage models for mapping tunnels to
       OpenFlow ports:

              ``Port-based’’ tunnels
                     In this model, an OpenFlow port represents one tunnel: it
                     matches a particular type of tunnel traffic  between  two
                     IP  endpoints,  with a particular tunnel key (if keys are
                     in use). In this situation, <b>in_port</b> suffices  to  distin‐
                     guish  one  tunnel  from  another,  so  the tunnel header
                     fields have little importance  for  OpenFlow  processing.
                     (They are still populated and may be used if it is conve‐
                     nient.) The tunnel header fields play no role in  sending
                     packets  out  such  an OpenFlow port, either, because the
                     OpenFlow port itself fully specifies the tunnel headers.

                     The following  Open  vSwitch  commands  create  a  bridge
                     <b>br-int</b>,  add  port <b>tap0</b> to the bridge as OpenFlow port 1,
                     establish a port-based GRE tunnel between the local  host
                     and  remote IP 192.168.1.1 using GRE key 5001 as OpenFlow
                     port 2, and arranges to forward all traffic from <b>tap0</b>  to
                     the tunnel and vice versa:

                     <b>ovs-vsctl</b> <b>add-br</b> <b>br-int</b>
                     <b>ovs-vsctl</b> <b>add-port</b> <b>br-int</b> <b>tap0</b> <b>--</b> <b>set</b> <b>interface</b> <b>tap0</b> <b>ofport_request=1</b>
                     <b>ovs-vsctl</b> <b>add-port</b> <b>br-int</b> <b>gre0</b> <b>--</b> <b>\</b>
                         <b>set</b> <b>interface</b> <b>gre0</b> <b>ofport_request=2</b> <b>type=gre</b> <b>\</b>
                                            <b>options:remote_ip=192.168.1.1</b> <b>options:key=5001</b>
                     <b>ovs-ofctl</b> <b>add-flow</b> <b>br-int</b> <b>in_port=1,actions=2</b>
                     <b>ovs-ofctl</b> <b>add-flow</b> <b>br-int</b> <b>in_port=2,actions=1</b>


              ``Flow-based’’ tunnels
                     In  this model, one OpenFlow port represents all possible
                     tunnels of a given type with an endpoint on  the  current
                     host,  for  example,  all GRE tunnels. In this situation,
                     <b>in_port</b> only indicates that traffic was received  on  the
                     particular  kind  of  tunnel.  This  is  where the tunnel
                     header fields are most important: they allow the OpenFlow
                     tables  to  discriminate  among tunnels based on their IP
                     endpoints or keys. Tunnel header  fields  also  determine
                     the IP endpoints and keys of packets sent out such a tun‐
                     nel port.

                     The following  Open  vSwitch  commands  create  a  bridge
                     <b>br-int</b>,  add  port <b>tap0</b> to the bridge as OpenFlow port 1,
                     establish a flow-based GRE tunnel port 3, and arranges to
                     forward  all  traffic  from <b>tap0</b> to remote IP 192.168.1.1
                     over a GRE tunnel with key 5001 and vice versa:

                     <b>ovs-vsctl</b> <b>add-br</b> <b>br-int</b>
                     <b>ovs-vsctl</b> <b>add-port</b> <b>br-int</b> <b>tap0</b> <b>--</b> <b>set</b> <b>interface</b> <b>tap0</b> <b>ofport_request=1</b>
                     <b>ovs-vsctl</b> <b>add-port</b> <b>br-int</b> <b>allgre</b> <b>--</b> <b>\</b>
                         <b>set</b> <b>interface</b> <b>allgre</b> <b>ofport_request=3</b> <b>type=gre</b> <b>\</b>
                                              <b>options:remote_ip=flow</b> <b>options:key=flow</b>
                     <b>ovs-ofctl</b> <b>add-flow</b> <b>br-int</b> <b>\</b>
                         <b>’in_port=1</b> <b>actions=set_tunnel:5001,set_field:192.168.1.1-&gt;tun_dst,3’</b>
                     <b>ovs-ofctl</b> <b>add-flow</b> <b>br-int</b> <b>’in_port=3,tun_src=192.168.1.1,tun_id=5001</b> <b>actions=1’</b>


              Mixed models.
                     One may define both flow-based and port-based tunnels  at
                     the same time. For example, it is valid and possibly use‐
                     ful to create and configure both <b>gre0</b> and  <b>allgre</b>  tunnel
                     ports described above.

                     Traffic  is  attributed  on  ingress to the most specific
                     matching tunnel. For example, <b>gre0</b> is more specific  than
                     <b>allgre</b>.  Therefore,  if both exist, then <b>gre0</b> will be the
                     ingress  port  for  any   GRE   traffic   received   from
                     192.168.1.1 with key 5001.

                     On  egress,  traffic  may  be directed to any appropriate
                     tunnel port. If both <b>gre0</b> and <b>allgre</b>  are  configured  as
                     already  described,  then  the  actions  <b>2</b>  and  <b>set_tun‐</b>
                     <b>nel:5001,set_field:192.168.1.1-&gt;tun_dst,3</b> send  the  same
                     tunnel traffic.

              Intermediate models.
                     Ports  may be configured as partially flow-based. For ex‐
                     ample, one may define an OpenFlow  port  that  represents
                     tunnels  between  a pair of endpoints but leaves the flow
                     table to discriminate on the flow key.

       <b>ovs-vswitchd.conf.db</b>(5) describes all the details of tunnel  configura‐
       tion.

       These fields do not have any prerequisites, which means that a flow may
       match on any or all of them, in any combination.

       These fields are zeros for packets that did not arrive on a tunnel.

       <b>Tunnel</b> <b>ID</b> <b>Field</b>

       Name:            <b>tun_id</b> (aka <b>tunnel_id</b>)
       Width:           64 bits
       Format:          hexadecimal

       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported


       OXM:             <b>OXM_OF_TUNNEL_ID</b> (38)  since  OpenFlow  1.3  and  Open
                        vSwitch 1.10
       NXM:             <b>NXM_NX_TUN_ID</b> (16) since Open vSwitch 1.1

       Many kinds of tunnels support a tunnel ID:

              •      VXLAN and Geneve have a 24-bit virtual network identifier
                     (VNI).

              •      LISP has a 24-bit instance ID.

              •      GRE has an optional 32-bit key.

              •      STT has a 64-bit key.

              •      ERSPAN has a 10-bit key (Session ID).

              •      GTPU has a 32-bit key (Tunnel Endpoint ID).

       When a packet is received from a tunnel, this field holds the tunnel ID
       in its least significant bits, zero-extended to fit. This field is zero
       if the tunnel does not support an ID, or if no ID is in use for a  tun‐
       nel  type  that has an optional ID, or if an ID of zero received, or if
       the packet was not received over a tunnel.

       When a packet is output to a tunnel port, the tunnel configuration  de‐
       termines  whether  the tunnel ID is taken from this field or bound to a
       fixed value. See the earlier description of ``port-based’’ and  ``flow-
       based’’ tunnels for more information.

       The following diagram shows the origin of this field in a typical keyed
       GRE tunnel:

          Ethernet            IPv4               GRE           Ethernet
        &lt;-----------&gt;   &lt;---------------&gt;   &lt;------------&gt;   &lt;----------&gt;
        48  48   16           8   32  32    16    16   32    48  48   16
       +---+---+-----+ +---+-----+---+---+ +---+------+---+ +---+---+----+
       |dst|src|type | |...|proto|src|dst| |...| type |key| |dst|src|type| ...
       +---+---+-----+ +---+-----+---+---+ +---+------+---+ +---+---+----+
                0x800        47                 0x6558


       <b>Tunnel</b> <b>IPv4</b> <b>Source</b> <b>Field</b>

       Name:            <b>tun_src</b>
       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             none
       NXM:             <b>NXM_NX_TUN_IPV4_SRC</b> (31) since Open vSwitch 2.0

       When a packet is received from a tunnel, this field is the  source  ad‐
       dress in the outer IP header of the tunneled packet. This field is zero
       if the packet was not received over a tunnel.

       When a packet is output to a flow-based tunnel port, this field  influ‐
       ences  the  IPv4 source address used to send the packet. If it is zero,
       then the kernel chooses an appropriate IP address based using the rout‐
       ing table.

       The following diagram shows the origin of this field in a typical keyed
       GRE tunnel:

          Ethernet            IPv4               GRE           Ethernet
        &lt;-----------&gt;   &lt;---------------&gt;   &lt;------------&gt;   &lt;----------&gt;
        48  48   16           8   32  32    16    16   32    48  48   16
       +---+---+-----+ +---+-----+---+---+ +---+------+---+ +---+---+----+
       |dst|src|type | |...|proto|src|dst| |...| type |key| |dst|src|type| ...
       +---+---+-----+ +---+-----+---+---+ +---+------+---+ +---+---+----+
                0x800        47                 0x6558


       <b>Tunnel</b> <b>IPv4</b> <b>Destination</b> <b>Field</b>


       Name:            <b>tun_dst</b>
       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             none
       NXM:             <b>NXM_NX_TUN_IPV4_DST</b> (32) since Open vSwitch 2.0

       When a packet is received from a tunnel, this field is the  destination
       address  in  the  outer IP header of the tunneled packet. This field is
       zero if the packet was not received over a tunnel.

       When a packet is output to a flow-based tunnel port, this field  speci‐
       fies the destination to which the tunnel packet is sent.

       The following diagram shows the origin of this field in a typical keyed
       GRE tunnel:

          Ethernet            IPv4               GRE           Ethernet
        &lt;-----------&gt;   &lt;---------------&gt;   &lt;------------&gt;   &lt;----------&gt;
        48  48   16           8   32  32    16    16   32    48  48   16
       +---+---+-----+ +---+-----+---+---+ +---+------+---+ +---+---+----+
       |dst|src|type | |...|proto|src|dst| |...| type |key| |dst|src|type| ...
       +---+---+-----+ +---+-----+---+---+ +---+------+---+ +---+---+----+
                0x800        47                 0x6558


       <b>Tunnel</b> <b>IPv6</b> <b>Source</b> <b>Field</b>

       Name:            <b>tun_ipv6_src</b>
       Width:           128 bits

       Format:          IPv6
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_TUN_IPV6_SRC</b> (109) since Open vSwitch 2.5

       Similar to <b>tun_src</b>, but for tunnels over IPv6.

       <b>Tunnel</b> <b>IPv6</b> <b>Destination</b> <b>Field</b>

       Name:            <b>tun_ipv6_dst</b>
       Width:           128 bits
       Format:          IPv6
       Masking:         arbitrary bitwise masks

       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_TUN_IPV6_DST</b> (110) since Open vSwitch 2.5

       Similar to <b>tun_dst</b>, but for tunnels over IPv6.

   <b>VXLAN</b> <b>Group-Based</b> <b>Policy</b> <b>Fields</b>
       The VXLAN header is defined as follows [RFC 7348], where the <b>I</b> bit must
       be set to 1, unlabeled bits or those labeled <b>reserved</b> must be set to 0,
       and Open vSwitch makes the VNI available via <b>tun_id</b>:

          VXLAN flags
        &lt;-------------&gt;
        1 1 1 1 1 1 1 1    24    24     8
       +-+-+-+-+-+-+-+-+--------+---+--------+
       | | | | |I| | | |reserved|VNI|reserved|
       +-+-+-+-+-+-+-+-+--------+---+--------+


       VXLAN Group-Based Policy [VXLAN Group Policy Option] adds new interpre‐
       tations to existing bits in the VXLAN header, reinterpreting it as fol‐
       lows, with changes highlighted:

           GBP flags
        &lt;-------------&gt;
        1 1 1 1 1 1 1 1       24        24     8
       +-+-+-+-+-+-+-+-+---------------+---+--------+
       | |D| | |A| | | |group policy ID|VNI|reserved|
       +-+-+-+-+-+-+-+-+---------------+---+--------+


       Open vSwitch makes GBP fields and flags available through the following
       fields.  Only  packets that arrive over a VXLAN tunnel with the GBP ex‐
       tension enabled have these fields set. In other packets they  are  zero
       on receive and ignored on transmit.

       <b>VXLAN</b> <b>Group-Based</b> <b>Policy</b> <b>ID</b> <b>Field</b>

       Name:            <b>tun_gbp_id</b>
       Width:           16 bits
       Format:          decimal

       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_TUN_GBP_ID</b> (38) since Open vSwitch 2.4

       For  a packet tunneled over VXLAN with the Group-Based Policy (GBP) ex‐
       tension, this field represents the GBP policy ID, as shown above.

       <b>VXLAN</b> <b>Group-Based</b> <b>Policy</b> <b>Flags</b> <b>Field</b>

       Name:            <b>tun_gbp_flags</b>
       Width:           8 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks

       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_TUN_GBP_FLAGS</b> (39) since Open vSwitch 2.4

       For a packet tunneled over VXLAN with the Group-Based Policy (GBP)  ex‐
       tension, this field represents the GBP policy flags, as shown above.

       The field has the format shown below:

           GBP Flags
        &lt;-------------&gt;
        1 1 1 1 1 1 1 1
       +-+-+-+-+-+-+-+-+
       | |D| | |A| | | |
       +-+-+-+-+-+-+-+-+


       Unlabeled bits are reserved and must be transmitted as 0. The VXLAN GBP
       draft defines the other bits’ meanings as:

              <b>D</b> (Don’t Learn)
                     When set, this bit indicates that the egress tunnel  end‐
                     point  must  not learn the source address of the encapsu‐
                     lated frame.

              <b>A</b> (Applied)
                     When set, indicates that the  group  policy  has  already
                     been applied to this packet. Devices must not apply poli‐
                     cies when the A bit is set.

   <b>ERSPAN</b> <b>Metadata</b> <b>Fields</b>
       These fields provide access to features in the ERSPAN tunneling  proto‐
       col [ERSPAN], which has two major versions: version 1 (aka type II) and
       version 2 (aka type III).

       Regardless of version, ERSPAN is encapsulated within a fixed 8-byte GRE
       header  that consists of a 4-byte GRE base header and a 4-byte sequence
       number. The ERSPAN version 1 header format is:

             GRE                ERSPAN v1            Ethernet
        &lt;------------&gt;   &lt;---------------------&gt;   &lt;----------&gt;
        16    16   32     4  18    10    12  20    48  48   16
       +---+------+---+ +---+---+-------+---+---+ +---+---+----+
       |...| type |seq| |ver|...|session|...|idx| |dst|src|type| ...
       +---+------+---+ +---+---+-------+---+---+ +---+---+----+
            0x88be        1      tun_id


       The ERSPAN version 2 header format is:

             GRE                         ERSPAN v2                      Ethernet
        &lt;------------&gt;   &lt;----------------------------------------&gt;   &lt;----------&gt;
        16    16   32     4  18    10       32     22   6    1   3    48  48   16
       +---+------+---+ +---+---+-------+---------+---+----+---+---+ +---+---+----+
       |...| type |seq| |ver|...|session|timestamp|...|hwid|dir|...| |dst|src|type| ...
       +---+------+---+ +---+---+-------+---------+---+----+---+---+ +---+---+----+
            0x22eb        2      tun_id                     0/1


       <b>ERSPAN</b> <b>Version</b> <b>Field</b>

       Name:            <b>tun_erspan_ver</b>
       Width:           8 bits (only the least-significant 4 bits may be nonzero)
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported

       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_ET_ERSPAN_VER</b> (12) since Open vSwitch 2.10

       ERSPAN version number: 1 for version 1, or 2 for version 2.

       <b>ERSPAN</b> <b>Index</b> <b>Field</b>


       Name:            <b>tun_erspan_idx</b>
       Width:           32 bits (only the least-significant 20 bits may be nonzero)
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             none
       NXM:             <b>NXOXM_ET_ERSPAN_IDX</b> (11) since Open vSwitch 2.10

       This field is a 20-bit index/port number  associated  with  the  ERSPAN
       traffic’s  source  port  and  direction (ingress/egress). This field is
       platform dependent.

       <b>ERSPAN</b> <b>Direction</b> <b>Field</b>

       Name:            <b>tun_erspan_dir</b>
       Width:           8 bits (only the least-significant 1 bits may be nonzero)
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             none
       NXM:             <b>NXOXM_ET_ERSPAN_DIR</b> (13) since Open vSwitch 2.10

       For ERSPAN v2, the mirrored traffic’s direction: 0 for ingress traffic,
       1 for egress traffic.

       <b>ERSPAN</b> <b>Hardware</b> <b>ID</b> <b>Field</b>


       Name:            <b>tun_erspan_hwid</b>
       Width:           8 bits (only the least-significant 6 bits may be nonzero)
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             none
       NXM:             <b>NXOXM_ET_ERSPAN_HWID</b> (14) since Open vSwitch 2.10

       A 6-bit unique identifier of an ERSPAN v2 engine within a system.

   <b>GTP-U</b> <b>Metadata</b> <b>Fields</b>
       These fields provide access to set-up GPRS Tunnelling Protocol for User
       Plane (GTPv1-U), based on 3GPP TS 29.281. A GTP-U header has  the  fol‐
       lowing format:

          8      8       16    32
       +-----+--------+------+----+
       |flags|msg type|length|TEID| ...
       +-----+--------+------+----+


       The  flags and message type have the Open vSwitch GTP-U specific fields
       described below. Open vSwitch makes the TEID (Tunnel  Endpoint  Identi‐
       fier), which identifies a tunnel endpoint in the receiving GTP-U proto‐
       col entity, available via <b>tun_id</b>.

       <b>GTP-U</b> <b>Flags</b> <b>Field</b>

       Name:            <b>tun_gtpu_flags</b>
       Width:           8 bits
       Format:          hexadecimal

       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_ET_GTPU_FLAGS</b> (15) since Open vSwitch 2.13

       This field holds the 8-bit GTP-U flags, encoded as:

         GTP-U Tunnel Flags
        &lt;-------------------&gt;
           3    1   1  1 1 1
       +-------+--+---+-+-+--+
       |version|PT|rsv|E|S|PN|
       +-------+--+---+-+-+--+
           1        0


       The flags are:

              version
                     Used to determine the  version  of  the  GTP-U  protocol,
                     which should be set to 1.

              PT     Protocol  type,  used as a protocol discriminator between
                     GTP (1) and GTP’ (0).

              rsv    Reserved. Must be zero.

              E      If 1, indicates the presence of a meaningful value of the
                     Next Extension Header field.

              S      If 1, indicates the presence of a meaningful value of the
                     Sequence Number field.

              PN     If 1, indicates the presence of a meaningful value of the
                     N-PDU Number field.

       <b>GTP-U</b> <b>Message</b> <b>Type</b> <b>Field</b>

       Name:            <b>tun_gtpu_msgtype</b>
       Width:           8 bits
       Format:          decimal

       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_ET_GTPU_MSGTYPE</b> (16) since Open vSwitch 2.13

       This  field  indicates  whether it’s a signalling message used for path
       management, or a user plane message which carries the original  packet.
       The  complete  range  of  message  types  can  be  referred to [3GPP TS
       29.281].

   <b>Geneve</b> <b>Fields</b>
       These fields provide access to additional features in the  Geneve  tun‐
       neling  protocol [Geneve]. Their names are somewhat generic in the hope
       that the same fields could be reused for other protocols in the future;
       for  example, the NSH protocol [NSH] supports TLV options whose form is
       identical to that for Geneve options.

       <b>Generic</b> <b>Tunnel</b> <b>Option</b> <b>0</b> <b>Field</b>

       Name:            <b>tun_metadata0</b>
       Width:           992 bits (124 bytes)
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks

       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_TUN_METADATA0</b> (40) since Open vSwitch 2.5

       The above information specifically covers generic tunnel option 0,  but
       Open  vSwitch  supports  64  options,  numbered 0 through 63, whose NXM
       field numbers are 40 through 103.

       These fields provide OpenFlow access to the  generic  type-length-value
       options  defined  by  the  Geneve tunneling protocol or other protocols
       with options in the same TLV format as Geneve options.  Each  of  these
       options has the following wire format:

               header                 body
        &lt;-------------------&gt; &lt;------------------&gt;
         16    8    3    5    4×(length - 1) bytes
       +-----+----+---+------+--------------------+
       |class|type|res|length|       value        |
       +-----+----+---+------+--------------------+
                    0


       Taken together, the <b>class</b> and <b>type</b> in the option format mean that there
       are about 16 million distinct kinds of TLV options, too  many  to  give
       individual OXM code points. Thus, Open vSwitch requires the user to de‐
       fine the TLV options of interest, by binding up to 64  TLV  options  to
       generic  tunnel  option NXM code points. Each option may have up to 124
       bytes in its body, the maximum allowed by the TLV format, but bound op‐
       tions may total at most 252 bytes of body.

       Open  vSwitch  extensions  to the OpenFlow protocol bind TLV options to
       NXM code points. The <b>ovs-ofctl</b>(8) program offers one way to  use  these
       extensions,  e.g.  to  configure a mapping from a TLV option with <b>class</b>
       <b>0xffff</b>, <b>type</b> <b>0</b>, and a body length of 4 bytes:

       <b>ovs-ofctl</b> <b>add-tlv-map</b> <b>br0</b> <b>"{class=0xffff,type=0,len=4}-&gt;tun_metadata0"</b>


       Once a TLV option is properly bound, it can be  accessed  and  modified
       like any other field, e.g. to send packets that have value 1234 for the
       option described above to the controller:

       <b>ovs-ofctl</b> <b>add-flow</b> <b>br0</b> <b>tun_metadata0=1234,actions=controller</b>


       An option not received or not bound is matched as all zeros.

       <b>Tunnel</b> <b>Flags</b> <b>Field</b>

       Name:            <b>tun_flags</b>

       Width:           16 bits (only the least-significant 1 bits may be nonzero)
       Format:          tunnel flags
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none

       NXM:             <b>NXM_NX_TUN_FLAGS</b> (104) since Open vSwitch 2.5

       Flags indicating various aspects of the tunnel encapsulation.

       Matches on this field are most conveniently written in  terms  of  sym‐
       bolic names (given in the diagram below), each preceded by either <b>+</b> for
       a flag that must be set, or <b>-</b> for a flag that must  be  unset,  without
       any  other  delimiters between the flags. Flags not mentioned are wild‐
       carded. For example, <b>tun_flags=+oam</b> matches only OAM  packets.  Matches
       can also be written as <u>flags</u><b>/</b><u>mask</u>, where <u>flags</u> and <u>mask</u> are 16-bit num‐
       bers in decimal or in hexadecimal prefixed by <b>0x</b>.

       Currently, only one flag is defined:

              <b>oam</b>    The tunnel protocol indicated that this is an OAM (Opera‐
                     tions and Management) control packet.

       The switch may reject matches against unknown flags.

       Newer  versions of Open vSwitch may introduce additional flags with new
       meanings. It is therefore not recommended to use an exact match on this
       field  since  the  behavior of these new flags is unknown and should be
       ignored.

       For non-tunneled packets, the value is 0.

<b>METADATA</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name            Bytes   Mask   RW?   Prereqs   NXM/OXM Support
       ──────────────  ──────  ─────  ────  ────────  ─────────────────────
       <b>in_port</b>         2       no     yes   none      OVS 1.1+

       <b>in_port_oxm</b>     4       no     yes   none      OF 1.2+ and OVS 1.7+
       <b>skb_priority</b>    4       no     no    none
       <b>pkt_mark</b>        4       yes    yes   none      OVS 2.0+
       <b>actset_output</b>   4       no     no    none      OF 1.3+ and OVS 2.4+
       <b>packet_type</b>     4       no     no    none      OF 1.5+ and OVS 2.8+

       These fields relate to the origin or treatment of a  packet,  but  they
       are not extracted from the packet data itself.

       <b>Ingress</b> <b>Port</b> <b>Field</b>

       Name:            <b>in_port</b>
       Width:           16 bits

       Format:          OpenFlow 1.0 port
       Masking:         not maskable
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)

       OXM:             none
       NXM:             <b>NXM_OF_IN_PORT</b> (0) since Open vSwitch 1.1

       The  OpenFlow port on which the packet being processed arrived. This is
       a 16-bit field that holds an OpenFlow 1.0 port number. For receiving  a
       packet, the only values that appear in this field are:

              1 through <b>0xfeff</b> (65,279), inclusive.
                     Conventional OpenFlow port numbers.

              <b>OFPP_LOCAL</b> (<b>0xfffe</b> or 65,534).
                     The ``local’’ port, which in Open vSwitch is always named
                     the same as the bridge itself. This represents a  connec‐
                     tion  between the switch and the local TCP/IP stack. This
                     port is where an IP address is most  commonly  configured
                     on an Open vSwitch switch.

                     OpenFlow  does not require a switch to have a local port,
                     but all existing versions of Open vSwitch have always in‐
                     cluded  a  local port. <b>Future</b> <b>Directions:</b> Future versions
                     of Open vSwitch might be able to optionally omit the  lo‐
                     cal  port,  if  someone  submits code to implement such a
                     feature.

              <b>OFPP_NONE</b> (OpenFlow 1.0) or <b>OFPP_ANY</b> (OpenFlow 1.1+) (<b>0xffff</b>  or
              65,535).
              <b>OFPP_CONTROLLER</b> (<b>0xfffd</b> or 65,533).
                   When  a controller injects a packet into an OpenFlow switch
                   with a ``packet-out’’ request, it can specify one of  these
                   ingress ports to indicate that the packet was generated in‐
                   ternally rather than having been received on some port.

                   OpenFlow 1.0 specified <b>OFPP_NONE</b> for this purpose.  Despite
                   that,  some  controllers  used  <b>OFPP_CONTROLLER</b>,  and  some
                   switches only accepted <b>OFPP_CONTROLLER</b>, so  OpenFlow  1.0.2
                   required  support  for  both  ports. OpenFlow 1.1 and later
                   were more clearly drafted to  allow  only  <b>OFPP_CONTROLLER</b>.
                   For  maximum  compatibility, Open vSwitch allows both ports
                   with all OpenFlow versions.

       Values not mentioned above will never appear when receiving  a  packet,
       including the following notable values:

              0      Zero is not a valid OpenFlow port number.

              <b>OFPP_MAX</b> (<b>0xff00</b> or 65,280).
                     This  value  has  only  been clearly specified as a valid
                     port number as of OpenFlow 1.3.3. Before that, its status
                     was  unclear,  and  so  Open  vSwitch  has  never allowed
                     <b>OFPP_MAX</b> to be used as a port  number,  so  packets  will
                     never be received on this port. (Other OpenFlow switches,
                     of course, might use it.)

              <b>OFPP_UNSET</b> (<b>0xfff7</b> or 65,527)
              <b>OFPP_IN_PORT</b> (<b>0xfff8</b> or 65,528)
              <b>OFPP_TABLE</b> (<b>0xfff9</b> or 65,529)
              <b>OFPP_NORMAL</b> (<b>0xfffa</b> or 65,530)
              <b>OFPP_FLOOD</b> (<b>0xfffb</b> or 65,531)
              <b>OFPP_ALL</b> (<b>0xfffc</b> or 65,532)
                   These port numbers are used  only  in  output  actions  and
                   never appear as ingress ports.

                   Most  of  these  port numbers were defined in OpenFlow 1.0,
                   but <b>OFPP_UNSET</b> was only introduced in OpenFlow 1.5.

       Values that will never appear when receiving  a  packet  may  still  be
       matched  against  in  the  flow table. There are still circumstances in
       which those flows can be matched:

              •      The <b>resubmit</b> Open vSwitch extension action allows a  flow
                     table lookup with an arbitrary ingress port.

              •      An  action  that modifies the ingress port field (see be‐
                     low), such as e.g. <b>load</b> or <b>set_field</b>, followed by an  ac‐
                     tion  or  instruction  that  performs  another flow table
                     lookup, such as <b>resubmit</b> or <b>goto_table</b>.

       This field is heavily used for matching in  OpenFlow  tables,  but  for
       packet egress, it has only very limited roles:

              •      OpenFlow  requires suppressing output actions to <b>in_port</b>.
                     That is, the following two flows both  drop  all  packets
                     that arrive on port 1:

                     <b>in_port=1,actions=1</b>
                     <b>in_port=1,actions=drop</b>


                     (This  behavior  is occasionally useful for flooding to a
                     subset of ports. Specifying <b>actions=1,2,3,4</b>, for example,
                     outputs  to  ports  1,  2, 3, and 4, omitting the ingress
                     port.)

              •      OpenFlow has a  special  port  <b>OFPP_IN_PORT</b>  (with  value
                     0xfff8) that outputs to the ingress port. For example, in
                     a switch that has four ports numbered 1  through  4,  <b>ac‐</b>
                     <b>tions=1,2,3,4,in_port</b>  outputs  to  ports 1, 2, 3, and 4,
                     including the ingress port.

       Because the ingress port field has so little influence on  packet  pro‐
       cessing,  it  does not ordinarily make sense to modify the ingress port
       field. The field is writable only to support the  occasional  use  case
       where  the  ingress port’s roles in packet egress, described above, be‐
       come troublesome.  For  example,  <b>actions=load:0-&gt;NXM_OF_IN_PORT[],out‐</b>
       <b>put:123</b>  will  output  to  port  123 regardless of whether it is in the
       ingress port. If the ingress port is important, then one may  save  and
       restore it on the stack:

       <b>actions=push:NXM_OF_IN_PORT[],load:0-&gt;NXM_OF_IN_PORT[],output:123,pop:NXM_OF_IN_PORT[]</b>


       or,  in Open vSwitch 2.7 or later, use the <b>clone</b> action to save and re‐
       store it:

       <b>actions=clone(load:0-&gt;NXM_OF_IN_PORT[],output:123)</b>


       The ability to modify the ingress port is an Open vSwitch extension  to
       OpenFlow.

       <b>OXM</b> <b>Ingress</b> <b>Port</b> <b>Field</b>

       Name:            <b>in_port_oxm</b>
       Width:           32 bits
       Format:          OpenFlow 1.1+ port
       Masking:         not maskable
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    yes (exact match only)

       OXM:             <b>OXM_OF_IN_PORT</b> (0) since OpenFlow 1.2 and Open vSwitch
                        1.7
       NXM:             none

       OpenFlow 1.1 and later use a 32-bit port number, so this field supplies
       a  32-bit  view  of  the ingress port. Current versions of Open vSwitch
       support only a 16-bit range of ports:

              •      OpenFlow 1.0 ports <b>0x0000</b> to <b>0xfeff</b>,  inclusive,  map  to
                     OpenFlow 1.1 port numbers with the same values.

              •      OpenFlow  1.0  ports  <b>0xff00</b> to <b>0xffff</b>, inclusive, map to
                     OpenFlow 1.1 port numbers <b>0xffffff00</b> to <b>0xffffffff</b>.

              •      OpenFlow 1.1  ports  <b>0x0000ff00</b>  to  <b>0xfffffeff</b>  are  not
                     mapped and not supported.

       <b>in_port</b>  and  <b>in_port_oxm</b> are two views of the same information, so all
       of the comments on <b>in_port</b> apply to <b>in_port_oxm</b> too. Modifying  <b>in_port</b>
       changes <b>in_port_oxm</b>, and vice versa.

       Setting  <b>in_port_oxm</b>  to an unsupported value yields unspecified behav‐
       ior.

       <b>Output</b> <b>Queue</b> <b>Field</b>

       Name:            <b>skb_priority</b>
       Width:           32 bits
       Format:          hexadecimal

       Masking:         not maskable
       Prerequisites:   none
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             none

       <b>Future</b> <b>Directions:</b> Open vSwitch implements the output queue as a field,
       but  does  not currently expose it through OXM or NXM for matching pur‐
       poses. If this turns out to be a useful feature,  it  could  be  imple‐
       mented  in  future versions. Only the <b>set_queue</b>, <b>enqueue</b>, and <b>pop_queue</b>
       actions currently influence the output queue.

       This field influences how packets in the flow will be queued, for qual‐
       ity  of  service (QoS) purposes, when they egress the switch. Its range
       of meaningful values, and their meanings, varies greatly from one Open‐
       Flow  implementation  to  another. Even within a single implementation,
       there is no guarantee that all OpenFlow ports have the same queues con‐
       figured  or that all OpenFlow ports in an implementation can be config‐
       ured the same way queue-wise.

       Configuring queues on OpenFlow is not well standardized. On Linux, Open
       vSwitch  supports  queue  configuration via OVSDB, specifically the <b>QoS</b>
       and <b>Queue</b> tables (see <b>ovs-vswitchd.conf.db(5)</b> for  details).  Ports  of
       Open  vSwitch  to  other  platforms  might  require queue configuration
       through some separate protocol (such as a CLI).  Even  on  Linux,  Open
       vSwitch  exposes  only  a  fraction  of  the  kernel’s queuing features
       through OVSDB, so advanced or unusual uses might require use  of  sepa‐
       rate  utilities  (e.g.  <b>tc</b>).  OpenFlow switches other than Open vSwitch
       might use OF-CONFIG or  any  of  the  configuration  methods  mentioned
       above.  Finally,  some  OpenFlow switches have a fixed number of fixed-
       function queues (e.g. eight queues with  strictly  defined  priorities)
       and others do not support any control over queuing.

       The only output queue that all OpenFlow implementations must support is
       zero, to identify a default queue, whose properties are implementation-
       defined. Outputting a packet to a queue that does not exist on the out‐
       put port yields unpredictable behavior:  among  the  possibilities  are
       that  the  packet  might  be dropped or transmitted with a very high or
       very low priority.

       OpenFlow 1.0 only allowed output queues to be specified as part  of  an
       <b>enqueue</b> action that specified both a queue and an output port. That is,
       OpenFlow 1.0 treats the queue as an argument to an  action,  not  as  a
       field.

       To increase flexibility, OpenFlow 1.1 added an action to set the output
       queue. This model was carried forward, without change, through OpenFlow
       1.5.

       Open  vSwitch implements the native queuing model of each OpenFlow ver‐
       sion it supports. Open vSwitch also includes an extension  for  setting
       the output queue as an action in OpenFlow 1.0.

       When  a  packet  ingresses into an OpenFlow switch, the output queue is
       ordinarily set to  0,  indicating  the  default  queue.  However,  Open
       vSwitch  supports  various  ways  to forward a packet from one OpenFlow
       switch to another within a single host. In these  cases,  Open  vSwitch
       maintains the output queue across the forwarding step. For example:

              •      A  hop  across an Open vSwitch ``patch port’’ (which does
                     not actually involve queuing) preserves the output queue.

              •      When a flow sets the output  queue  then  outputs  to  an
                     OpenFlow  tunnel  port,  the  encapsulation preserves the
                     output queue. If the kernel TCP/IP stack routes  the  en‐
                     capsulated  packet directly to a physical interface, then
                     that output honors the output  queue.  Alternatively,  if
                     the kernel routes the encapsulated packet to another Open
                     vSwitch bridge, then the output queue set previously  be‐
                     comes  the  initial output queue on ingress to the second
                     bridge and will thus be used for further  output  actions
                     (unless overridden by a new ``set queue’’ action).

                     (This  description  reflects the current behavior of Open
                     vSwitch on Linux. This behavior relies on details of  the
                     Linux  TCP/IP  stack. It could be difficult to make ports
                     to other operating systems behave the same way.)

       <b>Packet</b> <b>Mark</b> <b>Field</b>

       Name:            <b>pkt_mark</b>
       Width:           32 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported

       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_PKT_MARK</b> (33) since Open vSwitch 2.0

       Packet mark comes to Open vSwitch from the Linux kernel, in  which  the
       <b>sk_buff</b>  data structure that represents a packet contains a 32-bit mem‐
       ber named <b>skb_mark</b>. The value of <b>skb_mark</b>  propagates  along  with  the
       packet it accompanies wherever the packet goes in the kernel. It has no
       predefined semantics but various kernel-user  interfaces  can  set  and
       match  on  it,  which  makes it suitable for ``marking’’ packets at one
       point in their handling and then acting on the mark later.  With  <b>ipta‐</b>
       <b>bles</b>,  for  example, one can mark some traffic specially at ingress and
       then handle that traffic differently at  egress  based  on  the  marked
       value.

       Packet  mark  is an attempt at a generalization of the <b>skb_mark</b> concept
       beyond Linux, at least through more generic naming. Like  <b>skb_priority</b>,
       packet  mark is preserved across forwarding steps within a machine. Un‐
       like <b>skb_priority</b>, packet mark has no direct effect on packet  forward‐
       ing:  the  value  set  in packet mark does not matter unless some later
       OpenFlow table or switch matches on packet mark, or unless  the  packet
       passes  through some other kernel subsystem that has been configured to
       interpret packet mark in specific ways, e.g. through <b>iptables</b>  configu‐
       ration mentioned above.

       Preserving packet mark across kernel forwarding steps relies heavily on
       kernel support, which ports to  non-Linux  operating  systems  may  not
       have.  Regardless  of  operating  system support, Open vSwitch supports
       packet mark within a single bridge and across patch ports.

       The value of packet mark when a packet ingresses into  the  first  Open
       vSwich  bridge  is typically zero, but it could be nonzero if its value
       was previously set by some kernel subsystem.

       <b>Action</b> <b>Set</b> <b>Output</b> <b>Port</b> <b>Field</b>

       Name:            <b>actset_output</b>
       Width:           32 bits
       Format:          OpenFlow 1.1+ port

       Masking:         not maskable
       Prerequisites:   none
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>ONFOXM_ET_ACTSET_OUTPUT</b> (43) since  OpenFlow  1.3  and
                        Open  vSwitch  2.4;  <b>OXM_OF_ACTSET_OUTPUT</b>  (43)  since
                        OpenFlow 1.5 and Open vSwitch 2.4
       NXM:             none

       Holds the output port currently in the OpenFlow action set  (i.e.  from
       an  <b>output</b>  action within a <b>write_actions</b> instruction). Its value is an
       OpenFlow port number. If there is no output port in the OpenFlow action
       set,  or  if  the output port will be ignored (e.g. because there is an
       output group in the OpenFlow  action  set),  then  the  value  will  be
       <b>OFPP_UNSET</b>.

       Open  vSwitch  allows any table to match this field. OpenFlow, however,
       only requires this field to be matchable from within an OpenFlow egress
       table (a feature that Open vSwitch does not yet implement).

       <b>Packet</b> <b>Type</b> <b>Field</b>

       Name:            <b>packet_type</b>
       Width:           32 bits
       Format:          packet type
       Masking:         not maskable
       Prerequisites:   none
       Access:          read-only

       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_PACKET_TYPE</b>  (44)  since  OpenFlow 1.5 and Open
                        vSwitch 2.8
       NXM:             none

       The type of the packet in the format specified in OpenFlow 1.5:

        Packet type
        &lt;---------&gt;
        16    16
       +---+-------+
       |ns |ns_type| ...
       +---+-------+


       The upper 16 bits, <u>ns</u>, are a namespace. The meaning of <u>ns</u><b>_</b><u>type</u>  depends
       on  the  namespace. The packet type field is specified and displayed in
       the format <b>(</b><u>ns</u><b>,</b><u>ns</u><b>_</b><u>type</u><b>)</b>.

       Open vSwitch currently supports the following classes of  packet  types
       for matching:

              <b>(0,0)</b>  Ethernet.

              <b>(1,</b><u>ethertype</u><b>)</b>
                     The specified <u>ethertype</u>. Open vSwitch can forward packets
                     with any <u>ethertype</u>, but it can only match on and  process
                     data fields for the following supported packet types:

                     <b>(1,0x800)</b>
                            IPv4

                     <b>(1,0x806)</b>
                            ARP

                     <b>(1,0x86dd)</b>
                            IPv6

                     <b>(1,0x8847)</b>
                            MPLS

                     <b>(1,0x8848)</b>
                            MPLS multicast

                     <b>(1,0x8035)</b>
                            RARP

                     <b>(1,0x894f)</b>
                            NSH

       Consider  the  distinction  between  a  packet  with <b>packet_type=(0,0),</b>
       <b>dl_type=0x800</b> and one with <b>packet_type=(1,0x800)</b>. The former is an Eth‐
       ernet frame that contains an IPv4 packet, like this:

          Ethernet            IPv4
        &lt;-----------&gt;   &lt;---------------&gt;
        48  48   16           8   32  32
       +---+---+-----+ +---+-----+---+---+
       |dst|src|type | |...|proto|src|dst| ...
       +---+---+-----+ +---+-----+---+---+
                0x800


       The  latter  is an IPv4 packet not encapsulated inside any outer frame,
       like this:

              IPv4
        &lt;---------------&gt;
              8   32  32
       +---+-----+---+---+
       |...|proto|src|dst| ...
       +---+-----+---+---+


       Matching on <b>packet_type</b> is a pre-requisite for  matching  on  any  data
       field,  but for backward compatibility, when a match on a data field is
       present without a <b>packet_type</b> match, Open  vSwitch  acts  as  though  a
       match  on  <b>(0,0)</b>  (Ethernet)  had  been  supplied. Similarly, when Open
       vSwitch sends flow match information to a controller, e.g. in  a  reply
       to  a  request  to  dump  the flow table, Open vSwitch omits a match on
       packet type (0,0) if it would be implied by a data field match.

<b>CONNECTION</b> <b>TRACKING</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name          Bytes   Mask   RW?   Prereqs   NXM/OXM Support

       ────────────  ──────  ─────  ────  ────────  ────────────────
       <b>ct_state</b>      4       yes    no    none      OVS 2.5+
       <b>ct_zone</b>       2       no     no    none      OVS 2.5+
       <b>ct_mark</b>       4       yes    yes   none      OVS 2.5+

       <b>ct_label</b>      16      yes    yes   none      OVS 2.5+
       <b>ct_nw_src</b>     4       yes    no    CT        OVS 2.8+
       <b>ct_nw_dst</b>     4       yes    no    CT        OVS 2.8+
       <b>ct_ipv6_src</b>   16      yes    no    CT        OVS 2.8+

       <b>ct_ipv6_dst</b>   16      yes    no    CT        OVS 2.8+
       <b>ct_nw_proto</b>   1       no     no    CT        OVS 2.8+
       <b>ct_tp_src</b>     2       yes    no    CT        OVS 2.8+
       <b>ct_tp_dst</b>     2       yes    no    CT        OVS 2.8+

       Open vSwitch supports ``connection tracking,’’  which  allows  bidirec‐
       tional  streams  of  packets to be statefully grouped into connections.
       Open vSwitch connection tracking, for example, identifies the  patterns
       of  TCP  packets that indicates a successfully initiated connection, as
       well as those that indicate that a connection has been torn down.  Open
       vSwitch connection tracking can also identify related connections, such
       as FTP data connections spawned from FTP control connections.

       An individual packet passing through the pipeline may be in one of  two
       states,  ``untracked’’  or  ``tracked,’’ which may be distinguished via
       the ``trk’’ flag in <b>ct_state</b>. A packet is <u>untracked</u> at the beginning of
       the Open vSwitch pipeline and continues to be untracked until the pipe‐
       line invokes the <b>ct</b> action. The connection tracking fields are all  ze‐
       roes  in  an untracked packet. When a flow in the Open vSwitch pipeline
       invokes the <b>ct</b> action, the action initializes the  connection  tracking
       fields and the packet becomes <u>tracked</u> for the remainder of its process‐
       ing.

       The connection tracker stores connection state in  an  internal  table,
       but  it  only adds a new entry to this table when a <b>ct</b> action for a new
       connection invokes <b>ct</b> with the <b>commit</b> parameter. For  a  given  connec‐
       tion,  when  a  pipeline  has executed <b>ct</b>, but not yet with <b>commit</b>, the
       connection is said to be <u>uncommitted</u>. State for an uncommitted  connec‐
       tion is ephemeral and does not persist past the end of the pipeline, so
       some features are only available to committed connections. A connection
       would typically be left uncommitted as a way to drop its packets.

       Connection  tracking  is  an  Open  vSwitch extension to OpenFlow. Open
       vSwitch 2.5 added the initial support for connection  tracking.  Subse‐
       quent versions of Open vSwitch added many refinements and extensions to
       the initial support. Many of these  capabilities  depend  on  the  Open
       vSwitch datapath rather than simply the userspace version. The <b>capabil‐</b>
       <b>ities</b> column in the <b>Datapath</b> table  (see  <b>ovs-vswitchd.conf.db</b>(5))  re‐
       ports the detailed capabilities of a particular Open vSwitch datapath.

       <b>Connection</b> <b>Tracking</b> <b>State</b> <b>Field</b>

       Name:            <b>ct_state</b>
       Width:           32 bits

       Format:          ct state
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read-only

       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_STATE</b> (105) since Open vSwitch 2.5

       This  field holds several flags that can be used to determine the state
       of the connection to which the packet belongs.

       Matches on this field are most conveniently written in  terms  of  sym‐
       bolic  names  (listed below), each preceded by either <b>+</b> for a flag that
       must be set, or <b>-</b> for a flag that must be unset, without any other  de‐
       limiters between the flags. Flags not mentioned are wildcarded. For ex‐
       ample, <b>tcp,ct_state=+trk-new</b> matches TCP packets  that  have  been  run
       through  the  connection tracker and do not establish a new connection.
       Matches can also be written as <u>flags</u><b>/</b><u>mask</u>, where  <u>flags</u>  and  <u>mask</u>  are
       32-bit numbers in decimal or in hexadecimal prefixed by <b>0x</b>.

       The following flags are defined:

              <b>new</b> (0x01)
                     A new connection. Set to 1 if this is an uncommitted con‐
                     nection.

              <b>est</b> (0x02)
                     Part of an existing connection. Set to 1 if packets of  a
                     committed  connection  have  been  seen by conntrack from
                     both directions.

              <b>rel</b> (0x04)
                     Related to an existing connection, e.g. an ICMP  ``desti‐
                     nation  unreachable’’ message or an FTP data connections.
                     This flag will only be 1 if the connection to which  this
                     one is related is committed.

                     Connections identified as <b>rel</b> are separate from the orig‐
                     inating connection and must be committed separately.  All
                     packets  for  a related connection will have the <b>rel</b> flag
                     set, not just the initial packet.

              <b>rpl</b> (0x08)
                     This packet is in the reply direction, meaning that it is
                     in  the opposite direction from the packet that initiated
                     the connection. This flag will only be 1 if  the  connec‐
                     tion is committed.

              <b>inv</b> (0x10)
                     The state is invalid, meaning that the connection tracker
                     couldn’t identify the connection. This flag is  a  catch-
                     all  for  problems  in  the  connection or the connection
                     tracker, such as:

                     •      L3/L4 protocol handler is not  loaded/unavailable.
                            With the Linux kernel datapath, this may mean that
                            the <b>nf_conntrack_ipv4</b> or <b>nf_conntrack_ipv6</b> modules
                            are not loaded.

                     •      L3/L4  protocol handler determines that the packet
                            is malformed.

                     •      Packets are unexpected length for protocol.

              <b>trk</b> (0x20)
                     This packet is tracked, meaning that  it  has  previously
                     traversed  the  connection  tracker.  If this flag is not
                     set, then no other flags will be set.  If  this  flag  is
                     set,  then the packet is tracked and other flags may also
                     be set.

              <b>snat</b> (0x40)
                     This packet was transformed by source address/port trans‐
                     lation  by  a preceding <b>ct</b> action. Open vSwitch 2.6 added
                     this flag.

              <b>dnat</b> (0x80)
                     This packet was transformed by  destination  address/port
                     translation  by  a  preceding <b>ct</b> action. Open vSwitch 2.6
                     added this flag.

       There are additional constraints on these flags, listed  in  decreasing
       order of precedence below:

              1.  If <b>trk</b> is unset, no other flags are set.

              2.  If <b>trk</b> is set, one or more other flags may be set.

              3.  If <b>inv</b> is set, only the <b>trk</b> flag is also set.

              4.  <b>new</b> and <b>est</b> are mutually exclusive.

              5.  <b>new</b> and <b>rpl</b> are mutually exclusive.

              6.  <b>rel</b> may be set in conjunction with any other flags.

       Future versions of Open vSwitch may define new flags.

       <b>Connection</b> <b>Tracking</b> <b>Zone</b> <b>Field</b>

       Name:            <b>ct_zone</b>
       Width:           16 bits
       Format:          hexadecimal
       Masking:         not maskable

       Prerequisites:   none
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_ZONE</b> (106) since Open vSwitch 2.5

       A connection tracking zone, the zone value passed to the most recent <b>ct</b>
       action. Each zone is an independent  connection  tracking  context,  so
       tracking the same packet in multiple contexts requires using the <b>ct</b> ac‐
       tion multiple times.

       <b>Connection</b> <b>Tracking</b> <b>Mark</b> <b>Field</b>

       Name:            <b>ct_mark</b>
       Width:           32 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_MARK</b> (107) since Open vSwitch 2.5

       The metadata committed, by an action within the <b>exec</b> parameter  to  the
       <b>ct</b> action, to the connection to which the current packet belongs.

       <b>Connection</b> <b>Tracking</b> <b>Label</b> <b>Field</b>

       Name:            <b>ct_label</b>
       Width:           128 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             none
       NXM:             <b>NXM_NX_CT_LABEL</b> (108) since Open vSwitch 2.5

       The  label  committed, by an action within the <b>exec</b> parameter to the <b>ct</b>
       action, to the connection to which the current packet belongs.

       Open vSwitch 2.8 introduced the matching support for connection tracker
       original direction 5-tuple fields.

       For non-committed non-related connections the conntrack original direc‐
       tion tuple fields always have the  same  values  as  the  corresponding
       headers in the packet itself. For any other packets of a committed con‐
       nection the conntrack original direction tuple fields reflect the  val‐
       ues from that initial non-committed non-related packet, and thus may be
       different from the actual packet headers, as the actual packet  headers
       may  be  in  reverse  direction (for reply packets), transformed by NAT
       (when <b>nat</b> option was applied to the connection),  or  be  of  different
       protocol  (i.e.,  when  an  ICMP response is sent to an UDP packet). In
       case of related connections, e.g., an FTP data connection, the original
       direction tuple contains the original direction headers from the parent
       connection, e.g., an FTP control connection.

       The following fields are populated by the  <b>ct</b>  action,  and  require  a
       match  to a valid connection tracking state as a prerequisite, in addi‐
       tion to the IP or IPv6 ethertype match. Examples  of  valid  connection
       tracking    state   matches   include   <b>ct_state=+new</b>,   <b>ct_state=+est</b>,
       <b>ct_state=+rel</b>, and <b>ct_state=+trk-inv</b>.

       <b>Connection</b> <b>Tracking</b> <b>Original</b> <b>Direction</b> <b>IPv4</b> <b>Source</b> <b>Address</b> <b>Field</b>

       Name:            <b>ct_nw_src</b>
       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks
       Prerequisites:   CT
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             none
       NXM:             <b>NXM_NX_CT_NW_SRC</b> (120) since Open vSwitch 2.8

       Matches IPv4 conntrack original direction tuple source address. See the
       paragraphs  above for general description to the conntrack original di‐
       rection tuple. Introduced in Open vSwitch 2.8.

       <b>Connection</b> <b>Tracking</b> <b>Original</b> <b>Direction</b> <b>IPv4</b> <b>Destination</b> <b>Address</b> <b>Field</b>

       Name:            <b>ct_nw_dst</b>
       Width:           32 bits
       Format:          IPv4

       Masking:         arbitrary bitwise masks
       Prerequisites:   CT
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_NW_DST</b> (121) since Open vSwitch 2.8

       Matches IPv4 conntrack original direction  tuple  destination  address.
       See the paragraphs above for general description to the conntrack orig‐
       inal direction tuple. Introduced in Open vSwitch 2.8.

       <b>Connection</b> <b>Tracking</b> <b>Original</b> <b>Direction</b> <b>IPv6</b> <b>Source</b> <b>Address</b> <b>Field</b>

       Name:            <b>ct_ipv6_src</b>
       Width:           128 bits
       Format:          IPv6
       Masking:         arbitrary bitwise masks
       Prerequisites:   CT
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_IPV6_SRC</b> (122) since Open vSwitch 2.8

       Matches IPv6 conntrack original direction tuple source address. See the
       paragraphs  above for general description to the conntrack original di‐
       rection tuple. Introduced in Open vSwitch 2.8.

       <b>Connection</b> <b>Tracking</b> <b>Original</b> <b>Direction</b> <b>IPv6</b> <b>Destination</b> <b>Address</b> <b>Field</b>

       Name:            <b>ct_ipv6_dst</b>
       Width:           128 bits
       Format:          IPv6
       Masking:         arbitrary bitwise masks
       Prerequisites:   CT
       Access:          read-only
       OpenFlow 1.0:    not supported

       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_IPV6_DST</b> (123) since Open vSwitch 2.8

       Matches IPv6 conntrack original direction  tuple  destination  address.
       See the paragraphs above for general description to the conntrack orig‐
       inal direction tuple. Introduced in Open vSwitch 2.8.

       <b>Connection</b> <b>Tracking</b> <b>Original</b> <b>Direction</b> <b>IP</b> <b>Protocol</b> <b>Field</b>

       Name:            <b>ct_nw_proto</b>
       Width:           8 bits

       Format:          decimal
       Masking:         not maskable
       Prerequisites:   CT
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_NW_PROTO</b> (119) since Open vSwitch 2.8

       Matches conntrack original direction tuple IP protocol type,  which  is
       specified  as  a decimal number between 0 and 255, inclusive (e.g. 1 to
       match ICMP packets or 6 to match TCP packets). In case of, for example,
       an  ICMP  response  to an UDP packet, this may be different from the IP
       protocol type of the packet itself. See the paragraphs above  for  gen‐
       eral  description to the conntrack original direction tuple. Introduced
       in Open vSwitch 2.8.

       <b>Connection</b> <b>Tracking</b> <b>Original</b>  <b>Direction</b>  <b>Transport</b>  <b>Layer</b>  <b>Source</b>  <b>Port</b>
       <b>Field</b>

       Name:            <b>ct_tp_src</b>
       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   CT

       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_CT_TP_SRC</b> (124) since Open vSwitch 2.8

       Bitwise  match  on  the  conntrack  original  direction tuple transport
       source, when <b>MFF_CT_NW_PROTO</b> has value 6 for TCP, 17 for  UDP,  or  132
       for  SCTP. When <b>MFF_CT_NW_PROTO</b> has value 1 for ICMP, or 58 for ICMPv6,
       the lower 8 bits of <b>MFF_CT_TP_SRC</b> matches the conntrack original direc‐
       tion ICMP type. See the paragraphs above for general description to the
       conntrack original direction tuple. Introduced in Open vSwitch 2.8.

       <b>Connection</b> <b>Tracking</b> <b>Original</b>  <b>Direction</b>  <b>Transport</b>  <b>Layer</b>  <b>Source</b>  <b>Port</b>
       <b>Field</b>

       Name:            <b>ct_tp_dst</b>
       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   CT
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none

       NXM:             <b>NXM_NX_CT_TP_DST</b> (125) since Open vSwitch 2.8

       Bitwise  match on the conntrack original direction tuple transport des‐
       tination port, when <b>MFF_CT_NW_PROTO</b> has value 6 for TCP, 17 for UDP, or
       132  for  SCTP.  When  <b>MFF_CT_NW_PROTO</b>  has value 1 for ICMP, or 58 for
       ICMPv6, the lower 8 bits of <b>MFF_CT_TP_DST</b> matches the conntrack  origi‐
       nal  direction ICMP code. See the paragraphs above for general descrip‐
       tion to the conntrack original  direction  tuple.  Introduced  in  Open
       vSwitch 2.8.

<b>REGISTER</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name       Bytes   Mask   RW?   Prereqs   NXM/OXM Support
       ─────────  ──────  ─────  ────  ────────  ─────────────────────
       <b>metadata</b>   8       yes    yes   none      OF 1.2+ and OVS 1.8+
       <b>reg0</b>       4       yes    yes   none      OVS 1.1+
       <b>reg1</b>       4       yes    yes   none      OVS 1.1+

       <b>reg2</b>       4       yes    yes   none      OVS 1.1+
       <b>reg3</b>       4       yes    yes   none      OVS 1.1+
       <b>reg4</b>       4       yes    yes   none      OVS 1.3+
       <b>reg5</b>       4       yes    yes   none      OVS 1.7+
       <b>reg6</b>       4       yes    yes   none      OVS 1.7+
       <b>reg7</b>       4       yes    yes   none      OVS 1.7+
       <b>reg8</b>       4       yes    yes   none      OVS 2.6+
       <b>reg9</b>       4       yes    yes   none      OVS 2.6+

       <b>reg10</b>      4       yes    yes   none      OVS 2.6+
       <b>reg11</b>      4       yes    yes   none      OVS 2.6+
       <b>reg12</b>      4       yes    yes   none      OVS 2.6+
       <b>reg13</b>      4       yes    yes   none      OVS 2.6+
       <b>reg14</b>      4       yes    yes   none      OVS 2.6+
       <b>reg15</b>      4       yes    yes   none      OVS 2.6+
       <b>xreg0</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xreg1</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+

       <b>xreg2</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xreg3</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xreg4</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xreg5</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xreg6</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xreg7</b>      8       yes    yes   none      OF 1.3+ and OVS 2.4+
       <b>xxreg0</b>     16      yes    yes   none      OVS 2.6+
       <b>xxreg1</b>     16      yes    yes   none      OVS 2.6+

       <b>xxreg2</b>     16      yes    yes   none      OVS 2.6+
       <b>xxreg3</b>     16      yes    yes   none      OVS 2.6+

       These  fields give an OpenFlow switch space for temporary storage while
       the pipeline is running. Whereas metadata fields can have a  meaningful
       initial  value  and  can  persist  across  some  hops  across  OpenFlow
       switches, registers are always initially 0 and their values never  per‐
       sist across inter-switch hops (not even across patch ports).

       <b>OpenFlow</b> <b>Metadata</b> <b>Field</b>

       Name:            <b>metadata</b>
       Width:           64 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write

       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    yes
       OXM:             <b>OXM_OF_METADATA</b>   (2)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.8
       NXM:             none

       This field is the oldest standardized OpenFlow register  field,  intro‐
       duced in OpenFlow 1.1. It was introduced to model the limited number of
       user-defined bits that some ASIC-based switches can carry through their
       pipelines. Because of hardware limitations, OpenFlow allows switches to
       support writing and masking only an  implementation-defined  subset  of
       bits, even no bits at all. The Open vSwitch software switch always sup‐
       ports all 64 bits, but of course an Open vSwitch port to an ASIC  would
       have the same restriction as the ASIC itself.

       This field has an OXM code point, but OpenFlow 1.4 and earlier allow it
       to be modified only with a specialized instruction, not with  a  ``set-
       field’’  action.  OpenFlow  1.5  removes this restriction. Open vSwitch
       does not enforce this restriction, regardless of OpenFlow version.

       <b>Register</b> <b>0</b> <b>Field</b>

       Name:            <b>reg0</b>
       Width:           32 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks

       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_REG0</b> (0) since Open vSwitch 1.1

       This is the first of several Open vSwitch registers, all of which  have
       the same properties. Open vSwitch 1.1 introduced registers 0, 1, 2, and
       3, version 1.3 added register 4, version 1.7 added registers 5, 6,  and
       7, and version 2.6 added registers 8 through 15.

       <b>Extended</b> <b>Register</b> <b>0</b> <b>Field</b>

       Name:            <b>xreg0</b>
       Width:           64 bits
       Format:          hexadecimal

       Masking:         arbitrary bitwise masks
       Prerequisites:   none
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_PKT_REG0</b>   (0)  since  OpenFlow  1.3  and  Open
                        vSwitch 2.4
       NXM:             none

       This is the first of the registers introduced in OpenFlow 1.5. OpenFlow
       1.5  calls these fields just the ``packet registers,’’ but Open vSwitch
       already had 32-bit registers by that name, so  Open  vSwitch  uses  the
       name  ``extended  registers’’  in  an  attempt to reduce confusion. The
       standard allows for up to 128 registers, each 64 bits  wide,  but  Open
       vSwitch  only  implements  4 (in versions 2.4 and 2.5) or 8 (in version
       2.6 and later).

       Each of the 64-bit extended registers overlays two of the 32-bit regis‐
       ters:  <b>xreg0</b>  overlays <b>reg0</b> and <b>reg1</b>, with <b>reg0</b> supplying the most-sig‐
       nificant bits of <b>xreg0</b> and <b>reg1</b> the least-significant. Similarly, <b>xreg1</b>
       overlays <b>reg2</b> and <b>reg3</b>, and so on.

       The  OpenFlow specification says, ``In most cases, the packet registers
       can not be matched in tables, i.e. they usually can not be used in  the
       flow  entry  match  structure’’  [OpenFlow  1.5, section 7.2.3.10], but
       there is no reason for a software switch to impose such a  restriction,
       and Open vSwitch does not.

       <b>Double-Extended</b> <b>Register</b> <b>0</b> <b>Field</b>

       Name:            <b>xxreg0</b>
       Width:           128 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   none

       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_XXREG0</b> (111) since Open vSwitch 2.6

       This  is  the  first of the double-extended registers introduce in Open
       vSwitch 2.6. Each of the 128-bit extended registers  overlays  four  of
       the 32-bit registers: <b>xxreg0</b> overlays <b>reg0</b> through <b>reg3</b>, with <b>reg0</b> sup‐
       plying the most-significant bits of <b>xxreg0</b> and <b>reg3</b> the  least-signifi‐
       cant. <b>xxreg1</b> similarly overlays <b>reg4</b> through <b>reg7</b>, and so on.

<b>LAYER</b> <b>2</b> <b>(ETHERNET)</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name                   Bytes   Mask   RW?   Prereqs    NXM/OXM Support

       ─────────────────────  ──────  ─────  ────  ─────────  ─────────────────────
       <b>eth_src</b> aka <b>dl_src</b>     6       yes    yes   Ethernet   OF 1.2+ and OVS 1.1+
       <b>eth_dst</b> aka <b>dl_dst</b>     6       yes    yes   Ethernet   OF 1.2+ and OVS 1.1+
       <b>eth_type</b> aka <b>dl_type</b>   2       no     no    Ethernet   OF 1.2+ and OVS 1.1+

       Ethernet  is  the  only layer-2 protocol that Open vSwitch supports. As
       with most software, Open vSwitch and OpenFlow regard an Ethernet  frame
       to  begin  with  the  14-byte header and end with the final byte of the
       payload; that is, the frame check sequence is not  considered  part  of
       the frame.

       <b>Ethernet</b> <b>Source</b> <b>Field</b>

       Name:            <b>eth_src</b> (aka <b>dl_src</b>)

       Width:           48 bits
       Format:          Ethernet
       Masking:         arbitrary bitwise masks
       Prerequisites:   Ethernet

       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes


       OXM:             <b>OXM_OF_ETH_SRC</b> (4) since OpenFlow 1.2 and Open vSwitch
                        1.7
       NXM:             <b>NXM_OF_ETH_SRC</b> (2) since Open vSwitch 1.1

       The Ethernet source address:

          Ethernet
        &lt;----------&gt;
        48  48   16
       +---+---+----+
       |dst|src|type| ...
       +---+---+----+


       <b>Ethernet</b> <b>Destination</b> <b>Field</b>

       Name:            <b>eth_dst</b> (aka <b>dl_dst</b>)
       Width:           48 bits
       Format:          Ethernet

       Masking:         arbitrary bitwise masks
       Prerequisites:   Ethernet
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)

       OpenFlow 1.1:    yes
       OXM:             <b>OXM_OF_ETH_DST</b> (3) since OpenFlow 1.2 and Open vSwitch
                        1.7
       NXM:             <b>NXM_OF_ETH_DST</b> (1) since Open vSwitch 1.1

       The Ethernet destination address:

          Ethernet
        &lt;----------&gt;
        48  48   16
       +---+---+----+
       |dst|src|type| ...
       +---+---+----+


       Open  vSwitch  1.8  and later support arbitrary masks for source and/or
       destination. Earlier versions only support masking the destination with
       the following masks:

              <b>01:00:00:00:00:00</b>
                     Match      only      the     multicast     bit.     Thus,
                     <b>dl_dst=01:00:00:00:00:00/01:00:00:00:00:00</b>  matches   all
                     multicast  (including  broadcast)  Ethernet  packets, and
                     <b>dl_dst=00:00:00:00:00:00/01:00:00:00:00:00</b>  matches   all
                     unicast Ethernet packets.

              <b>fe:ff:ff:ff:ff:ff</b>
                     Match all bits except the multicast bit. This is probably
                     not useful.

              <b>ff:ff:ff:ff:ff:ff</b>
                     Exact match (equivalent to omitting the mask).

              <b>00:00:00:00:00:00</b>
                     Wildcard all bits (equivalent to <b>dl_dst=*</b>).

       <b>Ethernet</b> <b>Type</b> <b>Field</b>

       Name:            <b>eth_type</b> (aka <b>dl_type</b>)
       Width:           16 bits
       Format:          hexadecimal
       Masking:         not maskable

       Prerequisites:   Ethernet
       Access:          read-only
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_ETH_TYPE</b>  (5)  since  OpenFlow  1.2  and   Open
                        vSwitch 1.7

       NXM:             <b>NXM_OF_ETH_TYPE</b> (3) since Open vSwitch 1.1

       The most commonly seen Ethernet frames today use a format called ``Eth‐
       ernet II,’’ in which the last two bytes of the Ethernet header  specify
       the  Ethertype. For such a frame, this field is copied from those bytes
       of the header, like so:

             Ethernet
        &lt;----------------&gt;
        48  48      16
       +---+---+----------+
       |dst|src|   type   | ...
       +---+---+----------+
                ≥0x600


       Every Ethernet type has a value 0x600 (1,536) or greater. When the last
       two bytes of the Ethernet header have a value too small to be an Ether‐
       net type, then the value found there is the total length of  the  frame
       in  bytes, excluding the Ethernet header. An 802.2 LLC header typically
       follows the Ethernet header. OpenFlow and Open vSwitch only support LLC
       headers  with  DSAP and SSAP <b>0xaa</b> and control byte <b>0x03</b>, which indicate
       that a SNAP header follows the LLC header. In turn, OpenFlow  and  Open
       vSwitch  only support a SNAP header with organization <b>0x000000</b>. In such
       a case, this field is copied from the type field in  the  SNAP  header,
       like this:

           Ethernet           LLC                SNAP
        &lt;------------&gt;   &lt;------------&gt;   &lt;-----------------&gt;
        48  48    16      8    8    8        24        16
       +---+---+------+ +----+----+----+ +--------+----------+
       |dst|src| type | |DSAP|SSAP|cntl| |  org   |   type   | ...
       +---+---+------+ +----+----+----+ +--------+----------+
                &lt;0x600   0xaa 0xaa 0x03   0x000000 ≥0x600


       When  an 802.1Q header is inserted after the Ethernet source and desti‐
       nation, this field is populated with the  encapsulated  Ethertype,  not
       the 802.1Q Ethertype. With an Ethernet II inner frame, the result looks
       like this:

        Ethernet     802.1Q     Ethertype
        &lt;------&gt;   &lt;--------&gt;   &lt;--------&gt;
         48  48      16   16        16
       +----+---+ +------+---+ +----------+
       |dst |src| | TPID |TCI| |   type   | ...
       +----+---+ +------+---+ +----------+
                   0x8100       ≥0x600


       LLC and SNAP encapsulation look like this with an 802.1Q header:

        Ethernet     802.1Q     Ethertype        LLC                SNAP
        &lt;------&gt;   &lt;--------&gt;   &lt;-------&gt;   &lt;------------&gt;   &lt;-----------------&gt;
         48  48      16   16       16        8    8    8        24        16
       +----+---+ +------+---+ +---------+ +----+----+----+ +--------+----------+
       |dst |src| | TPID |TCI| |  type   | |DSAP|SSAP|cntl| |  org   |   type   | ...
       +----+---+ +------+---+ +---------+ +----+----+----+ +--------+----------+
                   0x8100        &lt;0x600     0xaa 0xaa 0x03   0x000000 ≥0x600


       When a packet doesn’t match any of the header formats described  above,
       Open    vSwitch    and    OpenFlow    set    this    field   to   <b>0x5ff</b>
       (<b>OFP_DL_TYPE_NOT_ETH_TYPE</b>).

<b>VLAN</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name          Bytes             Mask   RW?   Prereqs    NXM/OXM Support

       ────────────  ────────────────  ─────  ────  ─────────  ─────────────────────
       <b>dl_vlan</b>       2 (low 12 bits)   no     yes   Ethernet
       <b>dl_vlan_pcp</b>   1 (low 3 bits)    no     yes   Ethernet

       <b>vlan_vid</b>      2 (low 12 bits)   yes    yes   Ethernet   OF 1.2+ and OVS 1.7+
       <b>vlan_pcp</b>      1 (low 3 bits)    no     yes   VLAN VID   OF 1.2+ and OVS 1.7+
       <b>vlan_tci</b>      2                 yes    yes   Ethernet   OVS 1.1+

       The 802.1Q VLAN header causes more trouble than any other  4  bytes  in
       networking.  OpenFlow  1.0,  1.1, and 1.2+ all treat VLANs differently.
       Open vSwitch extensions add another variant to the  mix.  Open  vSwitch
       reconciles all four treatments as best it can.

   <b>VLAN</b> <b>Header</b> <b>Format</b>
       An 802.1Q VLAN header consists of two 16-bit fields:

          TPID        TCI
        &lt;-------&gt; &lt;---------&gt;
           16      3   1  12
       +---------+---+---+---+
       |Ethertype|PCP|CFI|VID|
       +---------+---+---+---+
         0x8100        0


       The  first  16  bits of the VLAN header, the <u>TPID</u> (Tag Protocol IDenti‐
       fier), is an Ethertype. When the VLAN header is inserted just after the
       source  and  destination  MAC  addresses in a Ethertype frame, the TPID
       serves to identify the presence of the VLAN.  The  standard  TPID,  the
       only one that Open vSwitch supports, is <b>0x8100</b>. OpenFlow 1.0 explicitly
       supports only TPID <b>0x8100</b>. OpenFlow 1.1, but not earlier or later  ver‐
       sions,  also  requires  support  for TPID <b>0x88a8</b> (Open vSwitch does not
       support this). OpenFlow 1.2 through 1.5 do not require support for spe‐
       cific  TPIDs (the ``push vlan header’’ action does say that only <b>0x8100</b>
       and <b>0x88a8</b> should be pushed). No version of OpenFlow provides a way  to
       distinguish or match on the TPID.

       The remaining 16 bits of the VLAN header, the <u>TCI</u> (Tag Control Informa‐
       tion), is subdivided into three subfields:

              •      <u>PCP</u> (Priority Control Point), is a 3-bit 802.1p <u>priority</u>.
                     The  lowest  priority  is  value  1, the second-lowest is
                     value 0, and priority increases from 2 up to highest pri‐
                     ority 7.

              •      <u>CFI</u> (Canonical Format Indicator), is a 1-bit field. On an
                     Ethernet network, its value is always 0. This led  to  it
                     later being repurposed under the name <u>DEI</u> (Drop Eligibil‐
                     ity Indicator). By either name, OpenFlow and Open vSwitch
                     don’t provide any way to match or set this bit.

              •      <u>VID</u> (VLAN IDentifier), is a 12-bit VLAN. If the VID is 0,
                     then the frame is not part of a VLAN. In that  case,  the
                     VLAN  header  is called a <u>priority</u> <u>tag</u> because it is only
                     meaningful for assigning the frame a priority. VID  <b>0xfff</b>
                     (4,095) is reserved.

       See <b>eth_type</b> for illustrations of a complete Ethernet frame with 802.1Q
       tag included.

   <b>Multiple</b> <b>VLANs</b>
       Open vSwitch can match only a single VLAN header. If more than one VLAN
       header  is  present,  then  <b>eth_type</b>  holds  the TPID of the inner VLAN
       header. Open vSwitch stops parsing the packet after the inner TPID,  so
       matching  further  into the packet (e.g. on the inner TCI or L3 fields)
       is not possible.

       OpenFlow only directly supports matching a single VLAN header. In Open‐
       Flow  1.1  or later, one OpenFlow table can match on the outermost VLAN
       header and pop it off, and a later OpenFlow table can match on the next
       outermost header. Open vSwitch does not support this.

   <b>VLAN</b> <b>Field</b> <b>Details</b>
       The  four variants have three different levels of expressiveness: Open‐
       Flow 1.0 and 1.1 VLAN matching are less  powerful  than  OpenFlow  1.2+
       VLAN  matching, which is less powerful than Open vSwitch extension VLAN
       matching.

   <b>OpenFlow</b> <b>1.0</b> <b>VLAN</b> <b>Fields</b>
       OpenFlow 1.0 uses two fields, called <b>dl_vlan</b> and <b>dl_vlan_pcp</b>,  each  of
       which  can  be  either  exact-matched  or  wildcarded,  to specify VLAN
       matches:

              •      When both <b>dl_vlan</b> and  <b>dl_vlan_pcp</b>  are  wildcarded,  the
                     flow matches packets without an 802.1Q header or with any
                     802.1Q header.

              •      The match <b>dl_vlan=0xffff</b> causes  a  flow  to  match  only
                     packets without an 802.1Q header. Such a flow should also
                     wildcard <b>dl_vlan_pcp</b>, since a packet  without  an  802.1Q
                     header  does  not  have  a PCP. OpenFlow does not specify
                     what to do if a match on PCP  is  actually  present,  but
                     Open vSwitch ignores it.

              •      Otherwise,  the  flow matches only packets with an 802.1Q
                     header. If <b>dl_vlan</b> is not wildcarded, then the flow  only
                     matches  packets  with the VLAN ID specified in <b>dl_vlan</b>’s
                     low 12 bits. If <b>dl_vlan_pcp</b> is not wildcarded,  then  the
                     flow  only matches packets with the priority specified in
                     <b>dl_vlan_pcp</b>’s low 3 bits.

                     OpenFlow does not specify how to  interpret  the  high  4
                     bits  of  <b>dl_vlan</b> or the high 5 bits of <b>dl_vlan_pcp</b>. Open
                     vSwitch ignores them.

   <b>OpenFlow</b> <b>1.1</b> <b>VLAN</b> <b>Fields</b>
       VLAN matching in OpenFlow 1.1 is similar to OpenFlow 1.0. The  one  re‐
       finement  is that when <b>dl_vlan</b> matches on <b>0xfffe</b> (<b>OFVPID_ANY</b>), the flow
       matches only packets with an  802.1Q  header,  with  any  VLAN  ID.  If
       <b>dl_vlan_pcp</b>  is  wildcarded, the flow matches any packet with an 802.1Q
       header, regardless of VLAN ID or priority. If <b>dl_vlan_pcp</b> is not  wild‐
       carded,  then the flow only matches packets with the priority specified
       in <b>dl_vlan_pcp</b>’s low 3 bits.

       OpenFlow 1.1 uses the name <b>OFPVID_NONE</b>, instead of <b>OFP_VLAN_NONE</b>, for a
       <b>dl_vlan</b> of <b>0xffff</b>, but it has the same meaning.

       In OpenFlow 1.1, Open vSwitch reports error <b>OFPBMC_BAD_VALUE</b> for an at‐
       tempt to match on <b>dl_vlan</b>  between  4,096  and  <b>0xfffd</b>,  inclusive,  or
       <b>dl_vlan_pcp</b> greater than 7.

   <b>OpenFlow</b> <b>1.2</b> <b>VLAN</b> <b>Fields</b>
       <b>OpenFlow</b> <b>1.2+</b> <b>VLAN</b> <b>ID</b> <b>Field</b>

       Name:            <b>vlan_vid</b>
       Width:           16 bits (only the least-significant 12 bits may be nonzero)
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   Ethernet
       Access:          read/write

       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_VLAN_VID</b> (6) since OpenFlow 1.2 and Open vSwitch 1.7
       NXM:             none

       The  OpenFlow  standard  describes this field as consisting of ``12+1’’
       bits. On ingress, its value is 0 if no 802.1Q header  is  present,  and
       otherwise  it holds the VLAN VID in its least significant 12 bits, with
       bit 12 (<b>0x1000</b> aka <b>OFPVID_PRESENT</b>) also set to 1. The three  most  sig‐
       nificant bits are always zero:

        OXM_OF_VLAN_VID
        &lt;-------------&gt;
         3  1     12
       +---+--+--------+
       |   |P |VLAN ID |
       +---+--+--------+
         0


       As  a  consequence  of this field’s format, one may use it to match the
       VLAN ID in all of the ways available with the OpenFlow 1.0 and 1.1 for‐
       mats, and a few new ways:

              Fully wildcarded
                     Matches any packet, that is, one without an 802.1Q header
                     or with an 802.1Q header with any TCI value.

              Value <b>0x0000</b> (<b>OFPVID_NONE</b>), mask <b>0xffff</b> (or no mask)
                     Matches only packets without an 802.1Q header.

              Value <b>0x1000</b>, mask <b>0x1000</b>
                     Matches any packet with an 802.1Q header,  regardless  of
                     VLAN ID.

              Value <b>0x1009</b>, mask <b>0xffff</b> (or no mask)
                     Match only packets with an 802.1Q header with VLAN ID 9.

              Value <b>0x1001</b>, mask <b>0x1001</b>
                     Matches  only  packets that have an 802.1Q header with an
                     odd-numbered VLAN ID. (This is just an example;  one  can
                     match on any desired VLAN ID bit pattern.)

       <b>OpenFlow</b> <b>1.2+</b> <b>VLAN</b> <b>Priority</b> <b>Field</b>

       Name:            <b>vlan_pcp</b>
       Width:           8 bits (only the least-significant 3 bits may be nonzero)
       Format:          decimal

       Masking:         not maskable
       Prerequisites:   VLAN VID
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)


       OXM:             <b>OXM_OF_VLAN_PCP</b>  (7)  since OpenFlow 1.2 and Open vSwitch
                        1.7
       NXM:             none

       The 3 least significant bits may be used to match the PCP  bits  in  an
       802.1Q header. Other bits are always zero:

        OXM_OF_VLAN_VID
        &lt;-------------&gt;
           5       3
       +--------+------+
       |  zero  | PCP  |
       +--------+------+
           0


       This  field  may  only be used when <b>vlan_vid</b> is not wildcarded and does
       not exact match on 0 (which  only  matches  when  there  is  no  802.1Q
       header).

       See <u>VLAN</u> <u>Comparison</u> <u>Chart</u>, below, for some examples.

   <b>Open</b> <b>vSwitch</b> <b>Extension</b> <b>VLAN</b> <b>Field</b>
       The <b>vlan_tci</b> extension can describe more kinds of VLAN matches than the
       other variants. It is also simpler than the other variants.

       <b>VLAN</b> <b>TCI</b> <b>Field</b>

       Name:            <b>vlan_tci</b>
       Width:           16 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   Ethernet
       Access:          read/write

       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             none
       NXM:             <b>NXM_OF_VLAN_TCI</b> (4) since Open vSwitch 1.1

       For a packet without an 802.1Q header, this field is zero. For a packet
       with  an 802.1Q header, this field is the TCI with the bit in CFI’s po‐
       sition (marked <b>P</b> for ``present’’ below) forced to 1. Thus, for a packet
       in VLAN 9 with priority 7, it has the value <b>0xf009</b>:

        NXM_VLAN_TCI
        &lt;----------&gt;
         3   1   12
       +----+--+----+
       |PCP |P |VID |
       +----+--+----+
         7   1   9


       Usage examples:

              <b>vlan_tci=0</b>
                     Match packets without an 802.1Q header.

              <b>vlan_tci=0x1000/0x1000</b>
                     Match  packets  with an 802.1Q header, regardless of VLAN
                     and priority values.

              <b>vlan_tci=0xf123</b>
                     Match packets tagged with priority 7 in VLAN 0x123.

              <b>vlan_tci=0x1123/0x1fff</b>
                     Match packets tagged with VLAN 0x123 (and any priority).

              <b>vlan_tci=0x5000/0xf000</b>
                     Match packets tagged with priority 2 (in any VLAN).

              <b>vlan_tci=0/0xfff</b>
                     Match packets with no 802.1Q header or tagged with VLAN 0
                     (and any priority).

              <b>vlan_tci=0x5000/0xe000</b>
                     Match packets with no 802.1Q header or tagged with prior‐
                     ity 2 (in any VLAN).

              <b>vlan_tci=0/0xefff</b>
                     Match packets with no 802.1Q header or tagged with VLAN 0
                     and priority 0.

       See <u>VLAN</u> <u>Comparison</u> <u>Chart</u>, below, for more examples.

   <b>VLAN</b> <b>Comparison</b> <b>Chart</b>
       The  following table describes each of several possible matching crite‐
       ria on 802.1Q header may be expressed with each variation of  the  VLAN
       matching fields:

       Criteria        OpenFlow 1.0    OpenFlow 1.1    OpenFlow 1.2+   NXM
                                             _      _      _      _      _

           [1]     ????/1,??/?     ????/1,??/?     0000/0000,--  0000/0000
           [2]     ffff/0,??/?     ffff/0,??/?     0000/ffff,--  0000/ffff
           [3]     0xxx/0,??/1     0xxx/0,??/1     1xxx/ffff,--  1xxx/1fff
           [4]     ????/1,0y/0     fffe/0,0y/0     1000/1000,0y  z000/f000
           [5]     0xxx/0,0y/0     0xxx/0,0y/0     1xxx/ffff,0y  zxxx/ffff
                           [6]     (none)  (none)  1001/1001,--  1001/1001
                                 [7]     (none)  (none)  (none)  3000/3000
                                 [8]     (none)  (none)  (none)  0000/0fff
                                 [9]     (none)  (none)  (none)  0000/f000
                                 [10]    (none)  (none)  (none)  0000/efff

       All  numbers  in the table are expressed in hexadecimal. The columns in
       the table are interpreted as follows:

              Criteria
                     See the list below.

              OpenFlow 1.0
              OpenFlow 1.1
                   wwww/x,yy/z means VLAN ID match value  wwww  with  wildcard
                   bit  x  and  VLAN PCP match value yy with wildcard bit z. ?
                   means that the given bits are ignored (and conventionally 0
                   for  wwww  or  yy, conventionally 1 for x or z). ``(none)’’
                   means that OpenFlow 1.0 (or 1.1) cannot  match  with  these
                   criteria.

              OpenFlow 1.2+
                   xxxx/yyyy,zz  means <b>vlan_vid</b> with value xxxx and mask yyyy,
                   and <b>vlan_pcp</b> (which is not  maskable)  with  value  zz.  --
                   means that <b>vlan_pcp</b> is omitted. ``(none)’’ means that Open‐
                   Flow 1.2 cannot match with these criteria.

              NXM  xxxx/yyyy means <b>vlan_tci</b> with value xxxx and mask yyyy.

       The matching criteria described by the table are:

              [1]    Matches any packet, that is, one without an 802.1Q header
                     or with an 802.1Q header with any TCI value.

              [2]    Matches only packets without an 802.1Q header.

                     OpenFlow  1.0  doesn’t  define the behavior if <b>dl_vlan</b> is
                     set to <b>0xffff</b> and <b>dl_vlan_pcp</b> is  not  wildcarded.  (Open
                     vSwitch always ignores <b>dl_vlan_pcp</b> when <b>dl_vlan</b> is set to
                     <b>0xffff</b>.)

                     OpenFlow 1.1 says explicitly to ignore  <b>dl_vlan_pcp</b>  when
                     <b>dl_vlan</b> is set to <b>0xffff</b>.

                     OpenFlow  1.2  doesn’t  say how to interpret a match with
                     <b>vlan_vid</b> value 0 and a mask with <b>OFPVID_PRESENT</b>  (<b>0x1000</b>)
                     set  to  1 and some other bits in the mask set to 1 also.
                     Open vSwitch interprets it the same  way  as  a  mask  of
                     <b>0x1000</b>.

                     Any  NXM  match with <b>vlan_tci</b> value 0 and the CFI bit set
                     to 1 in the mask is equivalent to the one listed  in  the
                     table.

              [3]    Matches  only packets that have an 802.1Q header with VID
                     xxx (and any PCP).

              [4]    Matches only packets that have an 802.1Q header with  PCP
                     y (and any VID).

                     OpenFlow 1.0 doesn’t clearly define the behavior for this
                     case. Open vSwitch implements it this way.

                     In the NXM value, z equals (y &lt;&lt; 1) | 1.

              [5]    Matches only packets that have an 802.1Q header with  VID
                     xxx and PCP y.

                     In the NXM value, z equals (y &lt;&lt; 1) | 1.

              [6]    Matches  only  packets that have an 802.1Q header with an
                     odd-numbered VID (and any PCP). Only possible with  Open‐
                     Flow 1.2 and NXM. (This is just an example; one can match
                     on any desired VID bit pattern.)

              [7]    Matches only packets that have an 802.1Q header  with  an
                     odd-numbered  PCP  (and any VID). Only possible with NXM.
                     (This is just an example; one can match  on  any  desired
                     VID bit pattern.)

              [8]    Matches  packets  with no 802.1Q header or with an 802.1Q
                     header with a VID of 0. Only possible with NXM.

              [9]    Matches packets with no 802.1Q header or with  an  802.1Q
                     header with a PCP of 0. Only possible with NXM.

              [10]   Matches  packets  with no 802.1Q header or with an 802.1Q
                     header with both VID and PCP of  0.  Only  possible  with
                     NXM.
<b>LAYER</b> <b>2.5:</b> <b>MPLS</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name         Bytes             Mask   RW?   Prereqs   NXM/OXM Support

       ───────────  ────────────────  ─────  ────  ────────  ──────────────────────
       <b>mpls_label</b>   4 (low 20 bits)   no     yes   MPLS      OF 1.2+ and OVS 1.11+
       <b>mpls_tc</b>      1 (low 3 bits)    no     yes   MPLS      OF 1.2+ and OVS 1.11+

       <b>mpls_bos</b>     1 (low 1 bits)    no     no    MPLS      OF 1.3+ and OVS 1.11+
       <b>mpls_ttl</b>     1                 no     yes   MPLS      OVS 2.6+

       One  or  more MPLS headers (more commonly called <u>MPLS</u> <u>labels</u>) follow an
       Ethernet type field that specifies an MPLS Ethernet  type  [RFC  3032].
       Ethertype  <b>0x8847</b>  is  used  for all unicast. Multicast MPLS is divided
       into two specific classes, one of which uses Ethertype <b>0x8847</b>  and  the
       other <b>0x8848</b> [RFC 5332].

       The most common overall packet format is Ethernet II, shown below (SNAP
       encapsulation may be used but is not ordinarily seen in  Ethernet  net‐
       works):

           Ethernet           MPLS
        &lt;------------&gt;   &lt;------------&gt;
        48  48    16      20   3  1  8
       +---+---+------+ +-----+--+-+---+
       |dst|src| type | |label|TC|S|TTL| ...
       +---+---+------+ +-----+--+-+---+
                0x8847


       MPLS  can  be  encapsulated  inside an 802.1Q header, in which case the
       combination looks like this:

        Ethernet     802.1Q     Ethertype        MPLS
        &lt;------&gt;   &lt;--------&gt;   &lt;-------&gt;   &lt;------------&gt;
         48  48      16   16       16        20   3  1  8
       +----+---+ +------+---+ +---------+ +-----+--+-+---+
       |dst |src| | TPID |TCI| |  type   | |label|TC|S|TTL| ...
       +----+---+ +------+---+ +---------+ +-----+--+-+---+
                   0x8100        0x8847


       The fields within an MPLS label are:

              Label, 20 bits.
                     An identifier.

              Traffic control (TC), 3 bits.
                     Used for quality of service.

              Bottom of stack (BOS), 1 bit (labeled just ``S’’ above).
                     0 indicates that another MPLS label follows this one.

                     1 indicates that this MPLS label is the last one  in  the
                     stack, so that some other protocol follows this one.

              Time to live (TTL), 8 bits.
                     Each  hop across an MPLS network decrements the TTL by 1.
                     If it reaches 0, the packet is discarded.

                     OpenFlow does not make the MPLS TTL available as a  match
                     field, but actions are available to set and decrement the
                     TTL. Open vSwitch 2.6 and later makes the MPLS TTL avail‐
                     able as an extension.

   <b>MPLS</b> <b>Label</b> <b>Stacks</b>
       Unlike the other encapsulations supported by OpenFlow and Open vSwitch,
       MPLS labels are routinely used in ``stacks’’  two  or  three  deep  and
       sometimes  even deeper. Open vSwitch currently supports up to three la‐
       bels.

       The OpenFlow specification only supports matching on the outermost MPLS
       label  at  any given time. To match on the second label, one must first
       ``pop’’ the outer label and advance to another  OpenFlow  table,  where
       the  inner  label may be matched. To match on the third label, one must
       pop the two outer labels, and so on.

   <b>MPLS</b> <b>Inner</b> <b>Protocol</b>
       Unlike all other forms of encapsulation that Open vSwitch and  OpenFlow
       support,  an MPLS label does not indicate what inner protocol it encap‐
       sulates. Different deployments determine the inner protocol in  differ‐
       ent ways [RFC 3032]:

              •      A  few  reserved label values do indicate an inner proto‐
                     col. Label 0, the ``IPv4 Explicit NULL Label,’’ indicates
                     inner  IPv4.  Label  2, the ``IPv6 Explicit NULL Label,’’
                     indicates inner IPv6.

              •      Some deployments use  a  single  inner  protocol  consis‐
                     tently.

              •      In  some deployments, the inner protocol must be inferred
                     from the innermost label.

              •      In some deployments, the inner protocol must be  inferred
                     from  the innermost label and the encapsulated data, e.g.
                     to distinguish between  inner  IPv4  and  IPv6  based  on
                     whether the first nibble of the inner protocol data are <b>4</b>
                     or <b>6</b>. OpenFlow and Open vSwitch do not currently  support
                     these cases.

       Open  vSwitch and OpenFlow do not infer the inner protocol, even if re‐
       served label values are in use. Instead, the flow  table  must  specify
       the inner protocol at the time it pops the bottommost MPLS label, using
       the Ethertype argument to the <b>pop_mpls</b> action.

   <b>Field</b> <b>Details</b>
       <b>MPLS</b> <b>Label</b> <b>Field</b>

       Name:            <b>mpls_label</b>
       Width:           32 bits (only the least-significant 20 bits may be nonzero)
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   MPLS
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    yes (exact match only)

       OXM:             <b>OXM_OF_MPLS_LABEL</b> (34) since OpenFlow 1.2 and Open  vSwitch
                        1.11
       NXM:             none

       The  least  significant  20 bits hold the ``label’’ field from the MPLS
       label. Other bits are zero:

        OXM_OF_MPLS_LABEL
        &lt;---------------&gt;
           12       20
       +--------+--------+
       |  zero  | label  |
       +--------+--------+
           0


       Most label values are available for any use by deployments. Values  un‐
       der 16 are reserved.

       <b>MPLS</b> <b>Traffic</b> <b>Class</b> <b>Field</b>

       Name:            <b>mpls_tc</b>
       Width:           8 bits (only the least-significant 3 bits may be nonzero)
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   MPLS

       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_MPLS_TC</b>  (35)  since OpenFlow 1.2 and Open vSwitch
                        1.11
       NXM:             none

       The least significant 3 bits hold the TC field  from  the  MPLS  label.
       Other bits are zero:

        OXM_OF_MPLS_TC
        &lt;------------&gt;
           5       3
       +--------+-----+
       |  zero  | TC  |
       +--------+-----+
           0


       This  field  is  intended  for use for Quality of Service (QoS) and Ex‐
       plicit Congestion Notification purposes, but its particular interpreta‐
       tion is deployment specific.

       Before 2009, this field was named EXP and reserved for experimental use
       [RFC 5462].

       <b>MPLS</b> <b>Bottom</b> <b>of</b> <b>Stack</b> <b>Field</b>

       Name:            <b>mpls_bos</b>
       Width:           8 bits (only the least-significant 1 bits may be nonzero)
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   MPLS
       Access:          read-only
       OpenFlow 1.0:    not supported

       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_MPLS_BOS</b> (36) since OpenFlow 1.3 and Open  vSwitch
                        1.11
       NXM:             none

       The  least  significant  bit  holds  the BOS field from the MPLS label.
       Other bits are zero:

        OXM_OF_MPLS_BOS
        &lt;-------------&gt;
           7       1
       +--------+------+
       |  zero  | BOS  |
       +--------+------+
           0


       This field is useful as part of processing a series  of  incoming  MPLS
       labels.  A  flow that includes a <b>pop_mpls</b> action should generally match
       on <b>mpls_bos</b>:

              •      When <b>mpls_bos</b> is 0, there is another MPLS label following
                     this  one,  so the Ethertype passed to <b>pop_mpls</b> should be
                     an MPLS Ethertype. For example: <b>table=0,</b>  <b>dl_type=0x8847,</b>
                     <b>mpls_bos=0,</b> <b>actions=pop_mpls:0x8847,</b> <b>goto_table:1</b>

              •      When  <b>mpls_bos</b>  is 1, this MPLS label is the last one, so
                     the Ethertype passed to <b>pop_mpls</b>  should  be  a  non-MPLS
                     Ethertype   such   as   IPv4.   For   example:   <b>table=1,</b>
                     <b>dl_type=0x8847,</b>   <b>mpls_bos=1,</b>    <b>actions=pop_mpls:0x0800,</b>
                     <b>goto_table:2</b>

       <b>MPLS</b> <b>Time-to-Live</b> <b>Field</b>

       Name:            <b>mpls_ttl</b>
       Width:           8 bits
       Format:          decimal

       Masking:         not maskable
       Prerequisites:   MPLS
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_MPLS_TTL</b> (30) since Open vSwitch 2.6

       Holds the 8-bit time-to-live field from the MPLS label:

        NXM_NX_MPLS_TTL
        &lt;-------------&gt;
               8
       +---------------+
       |      TTL      |
       +---------------+


<b>LAYER</b> <b>3:</b> <b>IPV4</b> <b>AND</b> <b>IPV6</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name                    Bytes             Mask   RW?   Prereqs     NXM/OXM Support
       ──────────────────────  ────────────────  ─────  ────  ──────────  ─────────────────────
       <b>ip_src</b> aka <b>nw_src</b>       4                 yes    yes   IPv4        OF 1.2+ and OVS 1.1+

       <b>ip_dst</b> aka <b>nw_dst</b>       4                 yes    yes   IPv4        OF 1.2+ and OVS 1.1+
       <b>ipv6_src</b>                16                yes    yes   IPv6        OF 1.2+ and OVS 1.1+
       <b>ipv6_dst</b>                16                yes    yes   IPv6        OF 1.2+ and OVS 1.1+
       <b>ipv6_label</b>              4 (low 20 bits)   yes    yes   IPv6        OF 1.2+ and OVS 1.4+
       <b>nw_proto</b> aka <b>ip_proto</b>   1                 no     no    IPv4/IPv6   OF 1.2+ and OVS 1.1+
       <b>nw_ttl</b>                  1                 no     yes   IPv4/IPv6   OVS 1.4+

       <b>ip_frag</b> aka <b>nw_frag</b>     1 (low 2 bits)    yes    no    IPv4/IPv6   OVS 1.3+
       <b>nw_tos</b>                  1                 no     yes   IPv4/IPv6   OVS 1.1+
       <b>ip_dscp</b>                 1 (low 6 bits)    no     yes   IPv4/IPv6   OF 1.2+ and OVS 1.7+
       <b>nw_ecn</b> aka <b>ip_ecn</b>       1 (low 2 bits)    no     yes   IPv4/IPv6   OF 1.2+ and OVS 1.4+

   <b>IPv4</b> <b>Specific</b> <b>Fields</b>
       These  fields  are  applicable  only to IPv4 flows, that is, flows that
       match on the IPv4 Ethertype <b>0x0800</b>.

       <b>IPv4</b> <b>Source</b> <b>Address</b> <b>Field</b>

       Name:            <b>ip_src</b> (aka <b>nw_src</b>)
       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks

       Prerequisites:   IPv4
       Access:          read/write
       OpenFlow 1.0:    yes (CIDR match only)
       OpenFlow 1.1:    yes
       OXM:             <b>OXM_OF_IPV4_SRC</b>  (11)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_IP_SRC</b> (7) since Open vSwitch 1.1

       The source address from the IPv4 header:

          Ethernet            IPv4
        &lt;-----------&gt;   &lt;---------------&gt;
        48  48   16           8   32  32
       +---+---+-----+ +---+-----+---+---+
       |dst|src|type | |...|proto|src|dst| ...
       +---+---+-----+ +---+-----+---+---+
                0x800


       For historical reasons, in an ARP or RARP flow, Open vSwitch interprets
       matches on <b>nw_src</b> as actually referring to the ARP SPA.

       <b>IPv4</b> <b>Destination</b> <b>Address</b> <b>Field</b>

       Name:            <b>ip_dst</b> (aka <b>nw_dst</b>)
       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks
       Prerequisites:   IPv4
       Access:          read/write
       OpenFlow 1.0:    yes (CIDR match only)

       OpenFlow 1.1:    yes
       OXM:             <b>OXM_OF_IPV4_DST</b>  (12)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_IP_DST</b> (8) since Open vSwitch 1.1

       The destination address from the IPv4 header:

          Ethernet            IPv4
        &lt;-----------&gt;   &lt;---------------&gt;
        48  48   16           8   32  32
       +---+---+-----+ +---+-----+---+---+
       |dst|src|type | |...|proto|src|dst| ...
       +---+---+-----+ +---+-----+---+---+
                0x800


       For historical reasons, in an ARP or RARP flow, Open vSwitch interprets
       matches on <b>nw_dst</b> as actually referring to the ARP TPA.

   <b>IPv6</b> <b>Specific</b> <b>Fields</b>
       These fields apply only to IPv6 flows, that is, flows that match on the
       IPv6 Ethertype <b>0x86dd</b>.

       <b>IPv6</b> <b>Source</b> <b>Address</b> <b>Field</b>

       Name:            <b>ipv6_src</b>
       Width:           128 bits
       Format:          IPv6
       Masking:         arbitrary bitwise masks
       Prerequisites:   IPv6
       Access:          read/write

       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_IPV6_SRC</b>  (26)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.1
       NXM:             <b>NXM_NX_IPV6_SRC</b> (19) since Open vSwitch 1.1

       The source address from the IPv6 header:

           Ethernet            IPv6
        &lt;------------&gt;   &lt;--------------&gt;
        48  48    16          8   128 128
       +---+---+------+ +---+----+---+---+
       |dst|src| type | |...|next|src|dst| ...
       +---+---+------+ +---+----+---+---+
                0x86dd


       Open vSwitch 1.8 added support for bitwise matching;  earlier  versions
       supported only CIDR masks.

       <b>IPv6</b> <b>Destination</b> <b>Address</b> <b>Field</b>

       Name:            <b>ipv6_dst</b>

       Width:           128 bits
       Format:          IPv6
       Masking:         arbitrary bitwise masks
       Prerequisites:   IPv6
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             <b>OXM_OF_IPV6_DST</b>  (27)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.1
       NXM:             <b>NXM_NX_IPV6_DST</b> (20) since Open vSwitch 1.1

       The destination address from the IPv6 header:

           Ethernet            IPv6
        &lt;------------&gt;   &lt;--------------&gt;
        48  48    16          8   128 128
       +---+---+------+ +---+----+---+---+
       |dst|src| type | |...|next|src|dst| ...
       +---+---+------+ +---+----+---+---+
                0x86dd


       Open vSwitch 1.8 added support for bitwise matching;  earlier  versions
       supported only CIDR masks.

       <b>IPv6</b> <b>Flow</b> <b>Label</b> <b>Field</b>

       Name:            <b>ipv6_label</b>
       Width:           32 bits (only the least-significant 20 bits may be nonzero)
       Format:          hexadecimal

       Masking:         arbitrary bitwise masks
       Prerequisites:   IPv6
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_IPV6_FLABEL</b> (28) since OpenFlow 1.2 and Open vSwitch
                        1.7

       NXM:             <b>NXM_NX_IPV6_LABEL</b> (27) since Open vSwitch 1.4

       The least significant 20 bits hold the flow label field from  the  IPv6
       header. Other bits are zero:

        OXM_OF_IPV6_FLABEL
        &lt;----------------&gt;
           12       20
       +--------+---------+
       |  zero  |  label  |
       +--------+---------+
           0


   <b>IPv4/IPv6</b> <b>Fields</b>
       These fields exist with at least approximately the same meaning in both
       IPv4 and IPv6, so they are treated as a single field for matching  pur‐
       poses.  Any  flow that matches on the IPv4 Ethertype <b>0x0800</b> or the IPv6
       Ethertype <b>0x86dd</b> may match on these fields.

       <b>IPv4/v6</b> <b>Protocol</b> <b>Field</b>

       Name:            <b>nw_proto</b> (aka <b>ip_proto</b>)
       Width:           8 bits
       Format:          decimal

       Masking:         not maskable
       Prerequisites:   IPv4/IPv6
       Access:          read-only
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_IP_PROTO</b>  (10)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_IP_PROTO</b> (6) since Open vSwitch 1.1

       Matches the IPv4 or IPv6 protocol type.

       For historical reasons, in an ARP or RARP flow, Open vSwitch interprets
       matches on <b>nw_proto</b> as actually referring to the ARP  opcode.  The  ARP
       opcode  is a 16-bit field, so for matching purposes ARP opcodes greater
       than 255 are treated as 0; this works adequately  because  in  practice
       ARP and RARP only use opcodes 1 through 4.

       <b>IPv4/v6</b> <b>TTL/Hop</b> <b>Limit</b> <b>Field</b>

       Name:            <b>nw_ttl</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   IPv4/IPv6
       Access:          read/write
       OpenFlow 1.0:    not supported

       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_IP_TTL</b> (29) since Open vSwitch 1.4

       The  main  reason  to  match on the TTL or hop limit field is to detect
       whether a <b>dec_ttl</b> action will fail due to a TTL exceeded error. Another
       way that a controller can detect TTL exceeded is to listen for <b>OFPR_IN‐</b>
       <b>VALID_TTL</b> ``packet-in’’ messages via OpenFlow.

       <b>IPv4/v6</b> <b>Fragment</b> <b>Bitmask</b> <b>Field</b>

       Name:            <b>ip_frag</b> (aka <b>nw_frag</b>)
       Width:           8 bits (only the least-significant 2 bits may be nonzero)
       Format:          frag
       Masking:         arbitrary bitwise masks
       Prerequisites:   IPv4/IPv6
       Access:          read-only

       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXM_NX_IP_FRAG</b> (26) since Open vSwitch 1.3

       Specifies what kinds of IP fragments or  non-fragments  to  match.  The
       value  for this field is most conveniently specified as one of the fol‐
       lowing:

              <b>no</b>     Match only non-fragmented packets.

              <b>yes</b>    Matches all fragments.

              <b>first</b>  Matches only fragments with offset 0.

              <b>later</b>  Matches only fragments with nonzero offset.

              <b>not_later</b>
                     Matches non-fragmented packets and  fragments  with  zero
                     offset.

       The field is internally formatted as 2 bits: bit 0 is 1 for an IP frag‐
       ment with any offset (and otherwise 0), and bit 1 is 1 for an IP  frag‐
       ment with nonzero offset (and otherwise 0), like so:

        NXM_NX_IP_FRAG
        &lt;------------&gt;
         6     1    1
       +----+-----+---+
       |zero|later|any|
       +----+-----+---+
         0


       Even  though  2  bits have 4 possible values, this field only uses 3 of
       them:

              •      A packet that is not an IP fragment has value 0.

              •      A packet that is an IP fragment with offset 0 (the  first
                     fragment) has bit 0 set and thus value 1.

              •      A  packet  that is an IP fragment with nonzero offset has
                     bits 0 and 1 set and thus value 3.

       The switch may reject matches against values that can never appear.

       It is important to understand how this field interacts with  the  Open‐
       Flow fragment handling mode:

              •      In  <b>OFPC_FRAG_DROP</b> mode, the OpenFlow switch drops all IP
                     fragments before they reach  the  flow  table,  so  every
                     packet  that  is available for matching will have value 0
                     in this field.

              •      Open vSwitch does not implement <b>OFPC_FRAG_REASM</b> mode, but
                     if  it  did then IP fragments would be reassembled before
                     they reached the flow table and again every packet avail‐
                     able for matching would always have value 0.

              •      In  <b>OFPC_FRAG_NORMAL</b> mode, all three values are possible,
                     but OpenFlow 1.0 says that fragments’ transport ports are
                     always  0,  even for the first fragment, so this does not
                     provide much extra information.

              •      In <b>OFPC_FRAG_NX_MATCH</b> mode, all three values  are  possi‐
                     ble.  For  fragments with offset 0, Open vSwitch makes L4
                     header information available.

       Thus, this field is likely to be most useful for an Open vSwitch switch
       configured  in  <b>OFPC_FRAG_NX_MATCH</b>  mode.  See  the  description of the
       <b>set-frags</b> command in <b>ovs-ofctl</b>(8), for more details.

     <u>IPv4/IPv6</u> <u>TOS</u> <u>Fields</u>

       IPv4 and IPv6 contain a one-byte ``type of service’’ or TOS field  that
       has the following format:

        type of service
        &lt;-------------&gt;
           6       2
       +--------+------+
       |  DSCP  | ECN  |
       +--------+------+


       <b>IPv4/v6</b> <b>DSCP</b> <b>(Bits</b> <b>2-7)</b> <b>Field</b>

       Name:            <b>nw_tos</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   IPv4/IPv6
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)

       OXM:             none
       NXM:             <b>NXM_OF_IP_TOS</b> (5) since Open vSwitch 1.1

       This field is the TOS byte with the two ECN bits cleared to 0:

        NXM_OF_IP_TOS
        &lt;-----------&gt;
          6      2
       +------+------+
       | DSCP | zero |
       +------+------+
                 0


       <b>IPv4/v6</b> <b>DSCP</b> <b>(Bits</b> <b>0-5)</b> <b>Field</b>

       Name:            <b>ip_dscp</b>
       Width:           8 bits (only the least-significant 6 bits may be nonzero)
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   IPv4/IPv6

       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_IP_DSCP</b>  (8)  since  OpenFlow 1.2 and Open vSwitch
                        1.7
       NXM:             none

       This field is the TOS byte shifted right to put the DSCP bits in the  6
       least-significant bits:

        OXM_OF_IP_DSCP
        &lt;------------&gt;
           2      6
       +-------+------+
       | zero  | DSCP |
       +-------+------+
           0


       <b>IPv4/v6</b> <b>ECN</b> <b>Field</b>


       Name:            <b>nw_ecn</b> (aka <b>ip_ecn</b>)
       Width:           8 bits (only the least-significant 2 bits may be nonzero)
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   IPv4/IPv6
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_IP_ECN</b> (9) since OpenFlow 1.2 and Open vSwitch 1.7
       NXM:             <b>NXM_NX_IP_ECN</b> (28) since Open vSwitch 1.4

       This field is the TOS byte with the DSCP bits cleared to 0:

        OXM_OF_IP_ECN
        &lt;-----------&gt;
           6      2
       +-------+-----+
       | zero  | ECN |
       +-------+-----+
           0


<b>LAYER</b> <b>3:</b> <b>ARP</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name      Bytes   Mask   RW?   Prereqs   NXM/OXM Support
       ────────  ──────  ─────  ────  ────────  ─────────────────────
       <b>arp_op</b>    2       no     yes   ARP       OF 1.2+ and OVS 1.1+
       <b>arp_spa</b>   4       yes    yes   ARP       OF 1.2+ and OVS 1.1+
       <b>arp_tpa</b>   4       yes    yes   ARP       OF 1.2+ and OVS 1.1+
       <b>arp_sha</b>   6       yes    yes   ARP       OF 1.2+ and OVS 1.1+

       <b>arp_tha</b>   6       yes    yes   ARP       OF 1.2+ and OVS 1.1+

       In  theory,  Address Resolution Protocol, or ARP, is a generic protocol
       generic protocol that can be used to obtain the hardware  address  that
       corresponds  to  any higher-level protocol address. In contemporary us‐
       age, ARP is used only in Ethernet networks to obtain the  Ethernet  ad‐
       dress  for a given IPv4 address. OpenFlow and Open vSwitch only support
       this usage of ARP. For this use case, an ARP packet has  the  following
       format, with the ARP fields exposed as Open vSwitch fields highlighted:

          Ethernet                      ARP
        &lt;-----------&gt;   &lt;----------------------------------&gt;
        48  48   16     16   16    8   8  16 48  16  48  16
       +---+---+-----+ +---+-----+---+---+--+---+---+---+---+
       |dst|src|type | |hrd| pro |hln|pln|op|sha|spa|tha|tpa|
       +---+---+-----+ +---+-----+---+---+--+---+---+---+---+
                0x806    1  0x800  6   4


       The  ARP  fields are also used for RARP, the Reverse Address Resolution
       Protocol, which shares ARP’s wire format.

       <b>ARP</b> <b>Opcode</b> <b>Field</b>

       Name:            <b>arp_op</b>
       Width:           16 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   ARP

       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_ARP_OP</b> (21) since OpenFlow 1.2 and Open vSwitch
                        1.7
       NXM:             <b>NXM_OF_ARP_OP</b> (15) since Open vSwitch 1.1

       Even  though  this is a 16-bit field, Open vSwitch does not support ARP
       opcodes greater than 255; it treats them to zero. This works adequately
       because in practice ARP and RARP only use opcodes 1 through 4.

       <b>ARP</b> <b>Source</b> <b>IPv4</b> <b>Address</b> <b>Field</b>

       Name:            <b>arp_spa</b>
       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks
       Prerequisites:   ARP
       Access:          read/write

       OpenFlow 1.0:    yes (CIDR match only)
       OpenFlow 1.1:    yes
       OXM:             <b>OXM_OF_ARP_SPA</b>   (22)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_ARP_SPA</b> (16) since Open vSwitch 1.1

       <b>ARP</b> <b>Target</b> <b>IPv4</b> <b>Address</b> <b>Field</b>

       Name:            <b>arp_tpa</b>

       Width:           32 bits
       Format:          IPv4
       Masking:         arbitrary bitwise masks
       Prerequisites:   ARP
       Access:          read/write
       OpenFlow 1.0:    yes (CIDR match only)
       OpenFlow 1.1:    yes
       OXM:             <b>OXM_OF_ARP_TPA</b>  (23)  since  OpenFlow  1.2  and   Open
                        vSwitch 1.7

       NXM:             <b>NXM_OF_ARP_TPA</b> (17) since Open vSwitch 1.1

       <b>ARP</b> <b>Source</b> <b>Ethernet</b> <b>Address</b> <b>Field</b>

       Name:            <b>arp_sha</b>
       Width:           48 bits
       Format:          Ethernet
       Masking:         arbitrary bitwise masks
       Prerequisites:   ARP

       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_ARP_SHA</b>   (24)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_NX_ARP_SHA</b> (17) since Open vSwitch 1.1

       <b>ARP</b> <b>Target</b> <b>Ethernet</b> <b>Address</b> <b>Field</b>


       Name:            <b>arp_tha</b>
       Width:           48 bits
       Format:          Ethernet
       Masking:         arbitrary bitwise masks
       Prerequisites:   ARP
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported


       OXM:             <b>OXM_OF_ARP_THA</b>  (25)  since  OpenFlow  1.2  and   Open
                        vSwitch 1.7
       NXM:             <b>NXM_NX_ARP_THA</b> (18) since Open vSwitch 1.1

<b>LAYER</b> <b>3:</b> <b>NSH</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name               Bytes             Mask   RW?   Prereqs   NXM/OXM Support

       ─────────────────  ────────────────  ─────  ────  ────────  ────────────────
       <b>nsh_flags</b>          1                 yes    yes   NSH       OVS 2.8+
       <b>nsh_ttl</b>            1                 no     yes   NSH       OVS 2.9+
       <b>nsh_mdtype</b>         1                 no     no    NSH       OVS 2.8+

       <b>nsh_np</b>             1                 no     no    NSH       OVS 2.8+
       <b>nsh_spi</b> aka <b>nsp</b>    4 (low 24 bits)   no     yes   NSH       OVS 2.8+
       <b>nsh_si</b> aka <b>nsi</b>     1                 no     yes   NSH       OVS 2.8+
       <b>nsh_c1</b> aka <b>nshc1</b>   4                 yes    yes   NSH       OVS 2.8+

       <b>nsh_c2</b> aka <b>nshc2</b>   4                 yes    yes   NSH       OVS 2.8+
       <b>nsh_c3</b> aka <b>nshc3</b>   4                 yes    yes   NSH       OVS 2.8+
       <b>nsh_c4</b> aka <b>nshc4</b>   4                 yes    yes   NSH       OVS 2.8+

       Service  functions  are widely deployed and essential in many networks.
       These service functions provide a range of features such  as  security,
       WAN  acceleration,  and server load balancing. Service functions may be
       instantiated at different points in the network infrastructure such  as
       the wide area network, data center, and so forth.

       Prior  to development of the SFC architecture [RFC 7665] and the proto‐
       col specified in this document,  current  service  function  deployment
       models  have been relatively static and bound to topology for insertion
       and policy selection. Furthermore, they do not adapt  well  to  elastic
       service environments enabled by virtualization.

       New  data  center network and cloud architectures require more flexible
       service function deployment models.  Additionally,  the  transition  to
       virtual  platforms  demands  an agile service insertion model that sup‐
       ports dynamic and elastic service delivery. Specifically, the following
       functions are necessary:

              1.  The  movement of service functions and application workloads
                  in the network.

              2.  The ability to easily bind service policy to granular infor‐
                  mation, such as per-subscriber state.

              3.  The  capability  to  steer  traffic to the requisite service
                  function(s).

       The Network Service Header (NSH) specification defines a new data plane
       protocol,  which  is  an encapsulation for service function chains. The
       NSH is designed to encapsulate an original packet or frame, and in turn
       be  encapsulated  by an outer transport encapsulation (which is used to
       deliver the NSH to NSH-aware network elements), as shown below:

       +-----------------------+----------------------------+---------------------+
       |Transport Encapsulation|Network Service Header (NSH)|Original Packet/Frame|
       +-----------------------+----------------------------+---------------------+


       The NSH is composed of the following elements:

              1.  Service Function Path identification.

              2.  Indication of location within a Service Function Path.

              3.  Optional, per packet metadata (fixed length or variable).

       [RFC 7665] provides an overview of a service chaining architecture that
       clearly  defines  the  roles of the various elements and the scope of a
       service function chaining encapsulation. Figure 3 of [RFC 7665] depicts
       the  SFC  architectural components after classification. The NSH is the
       SFC encapsulation referenced in [RFC 7665].

       <b>flags</b> <b>field</b> <b>(2</b> <b>bits)</b> <b>Field</b>

       Name:            <b>nsh_flags</b>
       Width:           8 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   NSH

       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_FLAGS</b> (1) since Open vSwitch 2.8

       <b>TTL</b> <b>field</b> <b>(6</b> <b>bits)</b> <b>Field</b>

       Name:            <b>nsh_ttl</b>
       Width:           8 bits
       Format:          decimal

       Masking:         not maskable
       Prerequisites:   NSH
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             none
       NXM:             <b>NXOXM_NSH_TTL</b> (10) since Open vSwitch 2.9

       <b>mdtype</b> <b>field</b> <b>(8</b> <b>bits)</b> <b>Field</b>


       Name:            <b>nsh_mdtype</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   NSH

       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_MDTYPE</b> (2) since Open vSwitch 2.8

       <b>np</b> <b>(next</b> <b>protocol)</b> <b>field</b> <b>(8</b> <b>bits)</b> <b>Field</b>

       Name:            <b>nsh_np</b>
       Width:           8 bits
       Format:          decimal

       Masking:         not maskable
       Prerequisites:   NSH
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             none
       NXM:             <b>NXOXM_NSH_NP</b> (3) since Open vSwitch 2.8

       <b>spi</b> <b>(service</b> <b>path</b> <b>identifier)</b> <b>field</b> <b>(24</b> <b>bits)</b> <b>Field</b>


       Name:            <b>nsh_spi</b> (aka <b>nsp</b>)
       Width:           32 bits (only the least-significant 24 bits may be nonzero)
       Format:          hexadecimal
       Masking:         not maskable
       Prerequisites:   NSH

       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_SPI</b> (4) since Open vSwitch 2.8

       <b>si</b> <b>(service</b> <b>index)</b> <b>field</b> <b>(8</b> <b>bits)</b> <b>Field</b>

       Name:            <b>nsh_si</b> (aka <b>nsi</b>)
       Width:           8 bits
       Format:          decimal

       Masking:         not maskable
       Prerequisites:   NSH
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             none
       NXM:             <b>NXOXM_NSH_SI</b> (5) since Open vSwitch 2.8

       <b>c1</b> <b>(Network</b> <b>Platform</b> <b>Context)</b> <b>field</b> <b>(32</b> <b>bits)</b> <b>Field</b>


       Name:            <b>nsh_c1</b> (aka <b>nshc1</b>)
       Width:           32 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   NSH

       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_C1</b> (6) since Open vSwitch 2.8

       <b>c2</b> <b>(Network</b> <b>Shared</b> <b>Context)</b> <b>field</b> <b>(32</b> <b>bits)</b> <b>Field</b>

       Name:            <b>nsh_c2</b> (aka <b>nshc2</b>)
       Width:           32 bits
       Format:          hexadecimal

       Masking:         arbitrary bitwise masks
       Prerequisites:   NSH
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             none
       NXM:             <b>NXOXM_NSH_C2</b> (7) since Open vSwitch 2.8

       <b>c3</b> <b>(Service</b> <b>Platform</b> <b>Context)</b> <b>field</b> <b>(32</b> <b>bits)</b> <b>Field</b>


       Name:            <b>nsh_c3</b> (aka <b>nshc3</b>)
       Width:           32 bits
       Format:          hexadecimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   NSH

       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>NXOXM_NSH_C3</b> (8) since Open vSwitch 2.8

       <b>c4</b> <b>(Service</b> <b>Shared</b> <b>Context)</b> <b>field</b> <b>(32</b> <b>bits)</b> <b>Field</b>

       Name:            <b>nsh_c4</b> (aka <b>nshc4</b>)
       Width:           32 bits
       Format:          hexadecimal

       Masking:         arbitrary bitwise masks
       Prerequisites:   NSH
       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             none
       NXM:             <b>NXOXM_NSH_C4</b> (9) since Open vSwitch 2.8

<b>LAYER</b> <b>4:</b> <b>TCP,</b> <b>UDP,</b> <b>AND</b> <b>SCTP</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name                 Bytes             Mask   RW?   Prereqs   NXM/OXM Support

       ───────────────────  ────────────────  ─────  ────  ────────  ─────────────────────
       <b>tcp_src</b> aka <b>tp_src</b>   2                 yes    yes   TCP       OF 1.2+ and OVS 1.1+
       <b>tcp_dst</b> aka <b>tp_dst</b>   2                 yes    yes   TCP       OF 1.2+ and OVS 1.1+
       <b>tcp_flags</b>            2 (low 12 bits)   yes    no    TCP       OF 1.3+ and OVS 2.1+

       <b>udp_src</b>              2                 yes    yes   UDP       OF 1.2+ and OVS 1.1+
       <b>udp_dst</b>              2                 yes    yes   UDP       OF 1.2+ and OVS 1.1+
       <b>sctp_src</b>             2                 yes    yes   SCTP      OF 1.2+ and OVS 2.0+
       <b>sctp_dst</b>             2                 yes    yes   SCTP      OF 1.2+ and OVS 2.0+

       For matching purposes, no distinction is made whether  these  protocols
       are encapsulated within IPv4 or IPv6.

   <b>TCP</b>
       The following diagram shows TCP within IPv4. Open vSwitch also supports
       TCP in IPv6. Only TCP fields implemented as  Open  vSwitch  fields  are
       shown:

          Ethernet            IPv4                   TCP
        &lt;-----------&gt;   &lt;---------------&gt;   &lt;-------------------&gt;
        48  48   16           8   32  32    16  16       12
       +---+---+-----+ +---+-----+---+---+ +---+---+---+-----+---+
       |dst|src|type | |...|proto|src|dst| |src|dst|...|flags|...| ...
       +---+---+-----+ +---+-----+---+---+ +---+---+---+-----+---+
                0x800         6


       <b>TCP</b> <b>Source</b> <b>Port</b> <b>Field</b>

       Name:            <b>tcp_src</b> (aka <b>tp_src</b>)
       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks

       Prerequisites:   TCP
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)


       OXM:             <b>OXM_OF_TCP_SRC</b>   (13)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_TCP_SRC</b> (9) since Open vSwitch 1.1

       Open vSwitch 1.6 added support for bitwise matching.

       <b>TCP</b> <b>Destination</b> <b>Port</b> <b>Field</b>

       Name:            <b>tcp_dst</b> (aka <b>tp_dst</b>)
       Width:           16 bits
       Format:          decimal

       Masking:         arbitrary bitwise masks
       Prerequisites:   TCP
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)

       OXM:             <b>OXM_OF_TCP_DST</b>  (14)  since  OpenFlow  1.2  and   Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_TCP_DST</b> (10) since Open vSwitch 1.1

       Open vSwitch 1.6 added support for bitwise matching.

       <b>TCP</b> <b>Flags</b> <b>Field</b>

       Name:            <b>tcp_flags</b>
       Width:           16 bits (only the least-significant 12 bits may be nonzero)
       Format:          TCP flags

       Masking:         arbitrary bitwise masks
       Prerequisites:   TCP
       Access:          read-only
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported

       OXM:             <b>ONFOXM_ET_TCP_FLAGS</b>   (42)  since  OpenFlow  1.3  and  Open
                        vSwitch 2.4; <b>OXM_OF_TCP_FLAGS</b> (42) since OpenFlow  1.5  and
                        Open vSwitch 2.3
       NXM:             <b>NXM_NX_TCP_FLAGS</b> (34) since Open vSwitch 2.1

       This  field  holds the TCP flags. TCP currently defines 9 flag bits. An
       additional 3 bits are reserved. For more information,  see  [RFC  793],
       [RFC 3168], and [RFC 3540].

       Matches  on  this  field are most conveniently written in terms of sym‐
       bolic names (given in the diagram below), each preceded by either <b>+</b> for
       a  flag  that  must be set, or <b>-</b> for a flag that must be unset, without
       any other delimiters between the flags. Flags not mentioned  are  wild‐
       carded.  For  example, <b>tcp,tcp_flags=+syn-ack</b> matches TCP SYNs that are
       not ACKs, and <b>tcp,tcp_flags=+[200]</b> matches TCP  packets  with  the  re‐
       served [200] flag set. Matches can also be written as <u>flags</u><b>/</b><u>mask</u>, where
       <u>flags</u> and <u>mask</u> are 16-bit numbers in decimal or in hexadecimal prefixed
       by <b>0x</b>.

       The flag bits are:

                 reserved      later RFCs         RFC 793
             &lt;---------------&gt; &lt;--------&gt; &lt;---------------------&gt;
         4     1     1     1   1   1   1   1   1   1   1   1   1
       +----+-----+-----+-----+--+---+---+---+---+---+---+---+---+
       |zero|[800]|[400]|[200]|NS|CWR|ECE|URG|ACK|PSH|RST|SYN|FIN|
       +----+-----+-----+-----+--+---+---+---+---+---+---+---+---+
         0


   <b>UDP</b>
       The following diagram shows UDP within IPv4. Open vSwitch also supports
       UDP in IPv6. Only UDP fields that Open vSwitch exposes  as  fields  are
       shown:

          Ethernet            IPv4              UDP
        &lt;-----------&gt;   &lt;---------------&gt;   &lt;---------&gt;
        48  48   16           8   32  32    16  16
       +---+---+-----+ +---+-----+---+---+ +---+---+---+
       |dst|src|type | |...|proto|src|dst| |src|dst|...| ...
       +---+---+-----+ +---+-----+---+---+ +---+---+---+
                0x800        17


       <b>UDP</b> <b>Source</b> <b>Port</b> <b>Field</b>

       Name:            <b>udp_src</b>

       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   UDP
       Access:          read/write

       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_UDP_SRC</b>   (15)  since  OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_UDP_SRC</b> (11) since Open vSwitch 1.1

       <b>UDP</b> <b>Destination</b> <b>Port</b> <b>Field</b>

       Name:            <b>udp_dst</b>
       Width:           16 bits
       Format:          decimal

       Masking:         arbitrary bitwise masks
       Prerequisites:   UDP
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)

       OXM:             <b>OXM_OF_UDP_DST</b>  (16)  since  OpenFlow  1.2  and   Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_UDP_DST</b> (12) since Open vSwitch 1.1

   <b>SCTP</b>
       The  following  diagram  shows SCTP within IPv4. Open vSwitch also sup‐
       ports SCTP in IPv6. Only SCTP  fields  that  Open  vSwitch  exposes  as
       fields are shown:

          Ethernet            IPv4             SCTP
        &lt;-----------&gt;   &lt;---------------&gt;   &lt;---------&gt;
        48  48   16           8   32  32    16  16
       +---+---+-----+ +---+-----+---+---+ +---+---+---+
       |dst|src|type | |...|proto|src|dst| |src|dst|...| ...
       +---+---+-----+ +---+-----+---+---+ +---+---+---+
                0x800        132


       <b>SCTP</b> <b>Source</b> <b>Port</b> <b>Field</b>


       Name:            <b>sctp_src</b>
       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   SCTP
       Access:          read/write

       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_SCTP_SRC</b>  (17)  since  OpenFlow  1.2  and  Open
                        vSwitch 2.0
       NXM:             none

       <b>SCTP</b> <b>Destination</b> <b>Port</b> <b>Field</b>

       Name:            <b>sctp_dst</b>
       Width:           16 bits
       Format:          decimal
       Masking:         arbitrary bitwise masks
       Prerequisites:   SCTP

       Access:          read/write
       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_SCTP_DST</b>  (18)  since  OpenFlow  1.2  and  Open
                        vSwitch 2.0
       NXM:             none

<b>LAYER</b> <b>4:</b> <b>ICMPV4</b> <b>AND</b> <b>ICMPV6</b> <b>FIELDS</b>
   <b>Summary:</b>
       Name              Bytes   Mask   RW?   Prereqs      NXM/OXM Support
       ────────────────  ──────  ─────  ────  ───────────  ─────────────────────

       <b>icmp_type</b>         1       no     yes   ICMPv4       OF 1.2+ and OVS 1.1+
       <b>icmp_code</b>         1       no     yes   ICMPv4       OF 1.2+ and OVS 1.1+
       <b>icmpv6_type</b>       1       no     yes   ICMPv6       OF 1.2+ and OVS 1.1+
       <b>icmpv6_code</b>       1       no     yes   ICMPv6       OF 1.2+ and OVS 1.1+
       <b>nd_target</b>         16      yes    yes   ND           OF 1.2+ and OVS 1.1+

       <b>nd_sll</b>            6       yes    yes   ND solicit   OF 1.2+ and OVS 1.1+
       <b>nd_tll</b>            6       yes    yes   ND advert    OF 1.2+ and OVS 1.1+
       <b>nd_reserved</b>       4       no     yes   ND           OVS 2.11+
       <b>nd_options_type</b>   1       no     yes   ND           OVS 2.11+

   <b>ICMPv4</b>
          Ethernet            IPv4             ICMPv4
        &lt;-----------&gt;   &lt;---------------&gt;   &lt;-----------&gt;
        48  48   16           8   32  32     8    8
       +---+---+-----+ +---+-----+---+---+ +----+----+---+
       |dst|src|type | |...|proto|src|dst| |type|code|...| ...
       +---+---+-----+ +---+-----+---+---+ +----+----+---+
                0x800         1


       <b>ICMPv4</b> <b>Type</b> <b>Field</b>

       Name:            <b>icmp_type</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   ICMPv4
       Access:          read/write

       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_ICMPV4_TYPE</b>  (19)  since  OpenFlow 1.2 and Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_ICMP_TYPE</b> (13) since Open vSwitch 1.1

       For historical reasons, in an  ICMPv4  flow,  Open  vSwitch  interprets
       matches on <b>tp_src</b> as actually referring to the ICMP type.

       <b>ICMPv4</b> <b>Code</b> <b>Field</b>

       Name:            <b>icmp_code</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable

       Prerequisites:   ICMPv4
       Access:          read/write
       OpenFlow 1.0:    yes (exact match only)
       OpenFlow 1.1:    yes (exact match only)
       OXM:             <b>OXM_OF_ICMPV4_CODE</b>  (20)  since  OpenFlow 1.2 and Open
                        vSwitch 1.7
       NXM:             <b>NXM_OF_ICMP_CODE</b> (14) since Open vSwitch 1.1

       For historical reasons, in an  ICMPv4  flow,  Open  vSwitch  interprets
       matches on <b>tp_dst</b> as actually referring to the ICMP code.

   <b>ICMPv6</b>
           Ethernet            IPv6            ICMPv6
        &lt;------------&gt;   &lt;--------------&gt;   &lt;-----------&gt;
        48  48    16          8   128 128    8    8
       +---+---+------+ +---+----+---+---+ +----+----+---+
       |dst|src| type | |...|next|src|dst| |type|code|...| ...
       +---+---+------+ +---+----+---+---+ +----+----+---+
                0x86dd        58


       <b>ICMPv6</b> <b>Type</b> <b>Field</b>


       Name:            <b>icmpv6_type</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   ICMPv6
       Access:          read/write
       OpenFlow 1.0:    not supported

       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_ICMPV6_TYPE</b>  (29)  since  OpenFlow 1.2 and Open
                        vSwitch 1.7
       NXM:             <b>NXM_NX_ICMPV6_TYPE</b> (21) since Open vSwitch 1.1

       <b>ICMPv6</b> <b>Code</b> <b>Field</b>


       Name:            <b>icmpv6_code</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   ICMPv6
       Access:          read/write
       OpenFlow 1.0:    not supported

       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_ICMPV6_CODE</b> (30) since OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_NX_ICMPV6_CODE</b> (22) since Open vSwitch 1.1

   <b>ICMPv6</b> <b>Neighbor</b> <b>Discovery</b>
           Ethernet            IPv6              ICMPv6            ICMPv6 ND
        &lt;------------&gt;   &lt;--------------&gt;   &lt;--------------&gt;   &lt;---------------&gt;
        48  48    16          8   128 128      8     8          128
       +---+---+------+ +---+----+---+---+ +-------+----+---+ +------+----------+
       |dst|src| type | |...|next|src|dst| | type  |code|...| |target|option ...|
       +---+---+------+ +---+----+---+---+ +-------+----+---+ +------+----------+
                0x86dd        58            135/136  0


       <b>ICMPv6</b> <b>Neighbor</b> <b>Discovery</b> <b>Target</b> <b>IPv6</b> <b>Field</b>

       Name:            <b>nd_target</b>
       Width:           128 bits
       Format:          IPv6
       Masking:         arbitrary bitwise masks
       Prerequisites:   ND
       Access:          read/write

       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_IPV6_ND_TARGET</b> (31) since OpenFlow 1.2 and Open
                        vSwitch 1.7
       NXM:             <b>NXM_NX_ND_TARGET</b> (23) since Open vSwitch 1.1

       <b>ICMPv6</b> <b>Neighbor</b> <b>Discovery</b> <b>Source</b> <b>Ethernet</b> <b>Address</b> <b>Field</b>

       Name:            <b>nd_sll</b>
       Width:           48 bits
       Format:          Ethernet
       Masking:         arbitrary bitwise masks
       Prerequisites:   ND solicit
       Access:          read/write
       OpenFlow 1.0:    not supported

       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_IPV6_ND_SLL</b> (32) since OpenFlow  1.2  and  Open
                        vSwitch 1.7
       NXM:             <b>NXM_NX_ND_SLL</b> (24) since Open vSwitch 1.1

       <b>ICMPv6</b> <b>Neighbor</b> <b>Discovery</b> <b>Target</b> <b>Ethernet</b> <b>Address</b> <b>Field</b>


       Name:            <b>nd_tll</b>
       Width:           48 bits
       Format:          Ethernet
       Masking:         arbitrary bitwise masks
       Prerequisites:   ND advert
       Access:          read/write
       OpenFlow 1.0:    not supported

       OpenFlow 1.1:    not supported
       OXM:             <b>OXM_OF_IPV6_ND_TLL</b>  (33)  since  OpenFlow 1.2 and Open
                        vSwitch 1.7
       NXM:             <b>NXM_NX_ND_TLL</b> (25) since Open vSwitch 1.1

       <b>ICMPv6</b> <b>Neighbor</b> <b>Discovery</b> <b>Reserved</b> <b>Field</b> <b>Field</b>


       Name:            <b>nd_reserved</b>
       Width:           32 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   ND
       Access:          read/write
       OpenFlow 1.0:    not supported

       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>ERICOXM_OF_ICMPV6_ND_RESERVED</b> (1) since  Open  vSwitch
                        2.11

       This is used to set the R,S,O bits in Neighbor Advertisement Messages

       <b>ICMPv6</b> <b>Neighbor</b> <b>Discovery</b> <b>Options</b> <b>Type</b> <b>Field</b> <b>Field</b>

       Name:            <b>nd_options_type</b>
       Width:           8 bits
       Format:          decimal
       Masking:         not maskable
       Prerequisites:   ND
       Access:          read/write

       OpenFlow 1.0:    not supported
       OpenFlow 1.1:    not supported
       OXM:             none
       NXM:             <b>ERICOXM_OF_ICMPV6_ND_OPTIONS_TYPE</b>   (2)   since   Open
                        vSwitch 2.11

       A value of 1 indicates that the option is Source Link Layer. A value of
       2  indicates  that  the  options is Target Link Layer. See RFC 4861 for
       further details.

<b>REFERENCES</b>
              Casado M. Casado, M. J. Freedman, J. Pettit, J. Luo, N. McKeown,
                     and  S.  Shenker,  ``Ethane: Taking Control of the Enter‐
                     prise,’’ Computer Communications Review, October 2007.

              ERSPAN M. Foschiano, K. Ghosh, M. Mehta, ``Cisco Systems’ Encap‐
                     sulated Remote Switch Port Analyzer (ERSPAN),’’ ⟨https://
                     tools.ietf.org/html/draft-foschiano-erspan-03⟩ .

              EXT-56 J. Tonsing, ``Permit one of a set of prerequisites to ap‐
                     ply, e.g. don’t preclude non-Ethernet media,’’ ⟨https://
                     rs.opennetworking.org/bugs/browse/EXT-56⟩  (ONF   members
                     only).

              EXT-112
                     J.  Tourrilhes, ``Support non-Ethernet packets throughout
                     the pipeline,’’ ⟨https://rs.opennetworking.org/bugs/
                     browse/EXT-112⟩ (ONF members only).

              EXT-134
                     J.  Tourrilhes,  ``Match  first  nibble  of the MPLS pay‐
                     load,’’ ⟨https://rs.opennetworking.org/bugs/browse/
                     EXT-134⟩ (ONF members only).

              Geneve J.  Gross,  I.  Ganga, and T. Sridhar, editors, ``Geneve:
                     Generic Network Virtualization Encapsulation,’’ ⟨https://
                     datatracker.ietf.org/doc/draft-ietf-nvo3-geneve/⟩ .

              IEEE OUI
                     IEEE  Standards  Association,  ``MAC  Address Block Large
                     (MA-L),’’ ⟨https://standards.ieee.org/develop/regauth/
                     oui/index.html⟩ .

              NSH    P.   Quinn  and  U.  Elzur,  editors,  ``Network  Service
                     Header,’’ ⟨https://datatracker.ietf.org/doc/
                     draft-ietf-sfc-nsh/⟩ .

              OpenFlow 1.0.1
                     Open  Networking  Foundation,  ``OpenFlow  Switch Errata,
                     Version 1.0.1,’’ June 2012.

              OpenFlow 1.1
                     OpenFlow Consortium, ``OpenFlow Switch Specification Ver‐
                     sion  1.1.0  Implemented (Wire Protocol 0x02),’’ February
                     2011.

              OpenFlow 1.5
                     Open Networking Foundation, ``OpenFlow Switch  Specifica‐
                     tion  Version  1.5.0  (Protocol version 0x06),’’ December
                     2014.

              OpenFlow Extensions 1.3.x Package 2
                     Open Networking Foundation, ``OpenFlow  Extensions  1.3.x
                     Package 2,’’ December 2013.

              TCP Flags Match Field Extension
                     Open  Networking  Foundation, ``TCP flags match field Ex‐
                     tension,’’ December 2014. In [OpenFlow  Extensions  1.3.x
                     Package 2].

              Pepelnjak
                     I. Pepelnjak, ``OpenFlow and Fermi Estimates,’’ ⟨http://
                     blog.ipspace.net/2013/09/openflow-and-fermi-esti‐
                     mates.html⟩ .

              RFC 793
                     ``Transmission Control Protocol,’’ ⟨http://www.ietf.org/
                     rfc/rfc793.txt⟩ .

              RFC 3032
                     E. Rosen, D. Tappan, G. Fedorkow, Y.  Rekhter,  D.  Fari‐
                     nacci,  T.  Li,  and  A. Conta, ``MPLS Label Stack Encod‐
                     ing,’’ ⟨http://www.ietf.org/rfc/rfc3032.txt⟩ .

              RFC 3168
                     K. Ramakrishnan, S. Floyd, and D. Black,  ``The  Addition
                     of Explicit Congestion Notification (ECN) to IP,’’
                     ⟨https://tools.ietf.org/html/rfc3168⟩ .

              RFC 3540
                     N. Spring, D. Wetherall, and D.  Ely,  ``Robust  Explicit
                     Congestion Notification (ECN) Signaling with Nonces,’’
                     ⟨https://tools.ietf.org/html/rfc3540⟩ .

              RFC 4632
                     V. Fuller and T.  Li,  ``Classless  Inter-domain  Routing
                     (CIDR):  The  Internet Address Assignment and Aggregation
                     Plan,’’ ⟨https://tools.ietf.org/html/rfc4632⟩ .

              RFC 5462
                     L. Andersson and R. Asati, ``Multiprotocol Label  Switch‐
                     ing  (MPLS)  Label  Stack Entry: ``EXP’’ Field Renamed to
                     ``Traffic Class’’ Field,’’ ⟨http://www.ietf.org/rfc/
                     rfc5462.txt⟩ .

              RFC 6830
                     D.  Farinacci,  V.  Fuller, D. Meyer, and D. Lewis, ``The
                     Locator/ID Separation Protocol (LISP),’’ ⟨http://
                     www.ietf.org/rfc/rfc6830.txt⟩ .

              RFC 7348
                     M.  Mahalingam, D. Dutt, K. Duda, P. Agarwal, L. Kreeger,
                     T. Sridhar, M. Bursell, and C. Wright, ``Virtual eXtensi‐
                     ble  Local Area Network (VXLAN): A Framework for Overlay‐
                     ing Virtualized Layer 2 Networks over Layer  3  Networks,
                     ’’ ⟨https://tools.ietf.org/html/rfc7348⟩ .

              RFC 7665
                     J. Halpern, Ed. and C. Pignataro, Ed., ``Service Function
                     Chaining (SFC) Architecture,’’ ⟨https://tools.ietf.org/
                     html/rfc7665⟩ .

              Srinivasan
                     V.  Srinivasan, S. Suriy, and G. Varghese, ``Packet Clas‐
                     sification using Tuple Space Search,’’ SIGCOMM 1999.

              Pagiamtzis
                     K. Pagiamtzis and A.  Sheikholeslami,  ``Content-address‐
                     able  memory (CAM) circuits and architectures: A tutorial
                     and survey,’’ IEEE Journal of Solid-State Circuits,  vol.
                     41, no. 3, pp. 712-727, March 2006.

              VXLAN Group Policy Option
                     M.  Smith and L. Kreeger, `` VXLAN Group Policy Option.’’
                     Internet-Draft.  ⟨https://tools.ietf.org/html/
                     draft-smith-vxlan-group-policy⟩ .

<b>AUTHORS</b>
       Ben Pfaff, with advice from Justin Pettit and Jean Tourrilhes.



Open vSwitch                        2.17.90                      ovs-fields(7)
</pre></body></html>
